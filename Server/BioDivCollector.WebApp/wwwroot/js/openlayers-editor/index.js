!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("ole", [], e) : "object" == typeof exports ? exports.ole = e() : t.ole = e() }(window, (function () { return function (t) { var e = {}; function n(i) { if (e[i]) return e[i].exports; var r = e[i] = { i: i, l: !1, exports: {} }; return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports } return n.m = t, n.c = e, n.d = function (t, e, i) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }) }, n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) n.d(i, r, function (e) { return t[e] }.bind(null, r)); return i }, n.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, "a", e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "", n(n.s = 15) }([, function (t, e, n) { t.exports = function () { "use strict"; function t(t, i, r, s, o) { !function t(n, i, r, s, o) { for (; s > r;) { if (s - r > 600) { var a = s - r + 1, l = i - r + 1, h = Math.log(a), c = .5 * Math.exp(2 * h / 3), u = .5 * Math.sqrt(h * c * (a - c) / a) * (l - a / 2 < 0 ? -1 : 1), f = Math.max(r, Math.floor(i - l * c / a + u)), p = Math.min(s, Math.floor(i + (a - l) * c / a + u)); t(n, i, f, p, o) } var d = n[i], g = r, _ = s; for (e(n, r, i), o(n[s], d) > 0 && e(n, r, s); g < _;) { for (e(n, g, _), g++, _--; o(n[g], d) < 0;)g++; for (; o(n[_], d) > 0;)_-- } 0 === o(n[r], d) ? e(n, r, _) : (_++, e(n, _, s)), _ <= i && (r = _ + 1), i <= _ && (s = _ - 1) } }(t, i, r || 0, s || t.length - 1, o || n) } function e(t, e, n) { var i = t[e]; t[e] = t[n], t[n] = i } function n(t, e) { return t < e ? -1 : t > e ? 1 : 0 } var i = function (t) { void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear() }; function r(t, e, n) { if (!n) return e.indexOf(t); for (var i = 0; i < e.length; i++)if (n(t, e[i])) return i; return -1 } function s(t, e) { o(t, 0, t.children.length, e, t) } function o(t, e, n, i, r) { r || (r = d(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0; for (var s = e; s < n; s++) { var o = t.children[s]; a(r, t.leaf ? i(o) : o) } return r } function a(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function l(t, e) { return t.minX - e.minX } function h(t, e) { return t.minY - e.minY } function c(t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function u(t) { return t.maxX - t.minX + (t.maxY - t.minY) } function f(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function p(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function d(t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function g(e, n, i, r, s) { for (var o = [n, i]; o.length;)if (!((i = o.pop()) - (n = o.pop()) <= r)) { var a = n + Math.ceil((i - n) / r / 2) * r; t(e, a, n, i, s), o.push(n, a, a, i) } } return i.prototype.all = function () { return this._all(this.data, []) }, i.prototype.search = function (t) { var e = this.data, n = []; if (!p(t, e)) return n; for (var i = this.toBBox, r = []; e;) { for (var s = 0; s < e.children.length; s++) { var o = e.children[s], a = e.leaf ? i(o) : o; p(t, a) && (e.leaf ? n.push(o) : f(t, a) ? this._all(o, n) : r.push(o)) } e = r.pop() } return n }, i.prototype.collides = function (t) { var e = this.data; if (!p(t, e)) return !1; for (var n = []; e;) { for (var i = 0; i < e.children.length; i++) { var r = e.children[i], s = e.leaf ? this.toBBox(r) : r; if (p(t, s)) { if (e.leaf || f(t, s)) return !0; n.push(r) } } e = n.pop() } return !1 }, i.prototype.load = function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (var e = 0; e < t.length; e++)this.insert(t[e]); return this } var n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { var i = this.data; this.data = n, n = i } this._insert(n, this.data.height - n.height - 1, !0) } else this.data = n; return this }, i.prototype.insert = function (t) { return t && this._insert(t, this.data.height - 1), this }, i.prototype.clear = function () { return this.data = d([]), this }, i.prototype.remove = function (t, e) { if (!t) return this; for (var n, i, s, o = this.data, a = this.toBBox(t), l = [], h = []; o || l.length;) { if (o || (o = l.pop(), i = l[l.length - 1], n = h.pop(), s = !0), o.leaf) { var c = r(t, o.children, e); if (-1 !== c) return o.children.splice(c, 1), l.push(o), this._condense(l), this } s || o.leaf || !f(o, a) ? i ? (n++, o = i.children[n], s = !1) : o = null : (l.push(o), h.push(n), n = 0, i = o, o = o.children[0]) } return this }, i.prototype.toBBox = function (t) { return t }, i.prototype.compareMinX = function (t, e) { return t.minX - e.minX }, i.prototype.compareMinY = function (t, e) { return t.minY - e.minY }, i.prototype.toJSON = function () { return this.data }, i.prototype.fromJSON = function (t) { return this.data = t, this }, i.prototype._all = function (t, e) { for (var n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, i.prototype._build = function (t, e, n, i) { var r, o = n - e + 1, a = this._maxEntries; if (o <= a) return s(r = d(t.slice(e, n + 1)), this.toBBox), r; i || (i = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, i - 1))), (r = d([])).leaf = !1, r.height = i; var l = Math.ceil(o / a), h = l * Math.ceil(Math.sqrt(a)); g(t, e, n, h, this.compareMinX); for (var c = e; c <= n; c += h) { var u = Math.min(c + h - 1, n); g(t, c, u, l, this.compareMinY); for (var f = c; f <= u; f += l) { var p = Math.min(f + l - 1, u); r.children.push(this._build(t, f, p, i - 1)) } } return s(r, this.toBBox), r }, i.prototype._chooseSubtree = function (t, e, n, i) { for (; i.push(e), !e.leaf && i.length - 1 !== n;) { for (var r = 1 / 0, s = 1 / 0, o = void 0, a = 0; a < e.children.length; a++) { var l = e.children[a], h = c(l), u = (f = t, p = l, (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - h); u < s ? (s = u, r = h < r ? h : r, o = l) : u === s && h < r && (r = h, o = l) } e = o || e.children[0] } var f, p; return e }, i.prototype._insert = function (t, e, n) { var i = n ? t : this.toBBox(t), r = [], s = this._chooseSubtree(i, this.data, e, r); for (s.children.push(t), a(s, i); e >= 0 && r[e].children.length > this._maxEntries;)this._split(r, e), e--; this._adjustParentBBoxes(i, r, e) }, i.prototype._split = function (t, e) { var n = t[e], i = n.children.length, r = this._minEntries; this._chooseSplitAxis(n, r, i); var o = this._chooseSplitIndex(n, r, i), a = d(n.children.splice(o, n.children.length - o)); a.height = n.height, a.leaf = n.leaf, s(n, this.toBBox), s(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) }, i.prototype._splitRoot = function (t, e) { this.data = d([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, s(this.data, this.toBBox) }, i.prototype._chooseSplitIndex = function (t, e, n) { for (var i, r, s, a, l, h, u, f = 1 / 0, p = 1 / 0, d = e; d <= n - e; d++) { var g = o(t, 0, d, this.toBBox), _ = o(t, d, n, this.toBBox), y = (r = g, s = _, a = void 0, l = void 0, h = void 0, u = void 0, a = Math.max(r.minX, s.minX), l = Math.max(r.minY, s.minY), h = Math.min(r.maxX, s.maxX), u = Math.min(r.maxY, s.maxY), Math.max(0, h - a) * Math.max(0, u - l)), m = c(g) + c(_); y < f ? (f = y, i = d, p = m < p ? m : p) : y === f && m < p && (p = m, i = d) } return i || n - e }, i.prototype._chooseSplitAxis = function (t, e, n) { var i = t.leaf ? this.compareMinX : l, r = t.leaf ? this.compareMinY : h; this._allDistMargin(t, e, n, i) < this._allDistMargin(t, e, n, r) && t.children.sort(i) }, i.prototype._allDistMargin = function (t, e, n, i) { t.children.sort(i); for (var r = this.toBBox, s = o(t, 0, e, r), l = o(t, n - e, n, r), h = u(s) + u(l), c = e; c < n - e; c++) { var f = t.children[c]; a(s, t.leaf ? r(f) : f), h += u(s) } for (var p = n - e - 1; p >= e; p--) { var d = t.children[p]; a(l, t.leaf ? r(d) : d), h += u(l) } return h }, i.prototype._adjustParentBBoxes = function (t, e, n) { for (var i = n; i >= 0; i--)a(e[i], t) }, i.prototype._condense = function (t) { for (var e = t.length - 1, n = void 0; e >= 0; e--)0 === t[e].children.length ? e > 0 ? (n = t[e - 1].children).splice(n.indexOf(t[e]), 1) : this.clear() : s(t[e], this.toBBox) }, i }() }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='572.538' height='556.094' viewBox='0 0 536.755 521.338'%3E%3Cg fill='none' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M491.978 104.858L375.053 322.633l-197.995 33.528-52.112 120.562 50.508-120.765 200-30z' stroke='%23000' stroke-width='90'%3E%3C/path%3E%3Cpath d='M491.978 104.858L375.053 322.633l-197.995 33.528-52.112 120.562 50.508-120.765 200-30z' stroke='%23fff' stroke-width='40'%3E%3C/path%3E%3Cpath d='M381.978 14.858L265.053 232.633 67.058 266.16 14.946 386.723l50.508-120.765 200-30z' stroke='%238a8a8a' stroke-width='30'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, , , function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' viewBox='0 0 127 127'%3E%3Cg fill='none'%3E%3Cpath stroke='%23000' stroke-width='18.4' d='M22.204 117.293l94.925-95.075.074 95-94.999.075z'%3E%3C/path%3E%3Cpath stroke='%23fff' stroke-linecap='square' stroke-width='7.2' d='M61.749 56.184l10.607 10.607m3.535-24.749l7.071 7.071M47.607 70.326l7.071 7.071m-21.213 7.071l7.071 7.071M90.033 27.9l7.071 7.071m7.071-21.213l7.071 7.071M19.323 98.61l7.071 7.072'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' stroke-linecap='round' stroke-linejoin='round' clip-rule='evenodd' viewBox='0 0 114 114'%3E%3Cg stroke='%23000'%3E%3Cpath fill='none' stroke-width='11.74' d='M107.709 63.043a50.913 50.913 0 0 1-15.894 31.298c-20.648 19.253-52.994 18.122-72.248-2.526C.314 71.167 1.445 38.821 22.093 19.567 42.741.314 75.088 1.445 94.341 22.093'%3E%3C/path%3E%3Cpath fill-rule='nonzero' stroke-linecap='butt' stroke-linejoin='miter' stroke-width='4.12' d='M103.388 15.93L86.749 28.708l16.305 4.011.334-16.789z'%3E%3C/path%3E%3Cpath fill='none' stroke-width='3.2' d='M56.773 41.22v15.734h15.734M56.773 72.688V56.954H41.038'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='110.005' height='110.001'%3E%3Cpath opacity='.01' fill='ivory' d='M0 0h110v110H0z'%3E%3C/path%3E%3Cpath d='M107.378 62.365a50.914 50.914 0 0 1-15.895 31.298c-20.648 19.253-52.994 18.122-72.247-2.526C-.018 70.49 1.113 38.143 21.76 18.89 42.41-.364 74.756.767 94.01 21.415' fill='none' stroke='%23000' stroke-width='5.245' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E%3Cpath d='M103.056 15.253L86.417 28.03l16.306 4.01z' stroke='%23000' stroke-width='.524'%3E%3C/path%3E%3Cpath d='M56.44 40.542v15.734h15.735M56.44 72.01V56.277H40.707' fill='none' stroke='%23000' stroke-width='3.199' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='454.681' height='120mm' viewBox='0 0 426.264 425.197'%3E%3Cg transform='translate(-163.736 -357.276)' fill='none' stroke='%23000' stroke-linejoin='round'%3E%3Cpath d='M530 657.362v120m-60-60h120' stroke-width='30'%3E%3C/path%3E%3Ccircle cx='311.724' cy='540.541' r='96.687' stroke-width='28.51' stroke-linecap='round'%3E%3C/circle%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='454.681' height='120mm' viewBox='0 0 426.264 425.197'%3E%3Cg fill='none' stroke='%23000' stroke-linejoin='round'%3E%3Cpath d='M366.264 300.087v120' stroke-width='30'%3E%3C/path%3E%3Cpath d='M176.264 415.087L344.548 210.64 270.812 12.457 70.549 76.515 10 237.716l166.265 177.37' stroke-width='20' stroke-linecap='round'%3E%3C/path%3E%3Cpath d='M306.264 360.087h120' stroke-width='30'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='454.681' height='120mm' viewBox='0 0 426.264 425.197'%3E%3Cg transform='translate(-163.736 -357.276)'%3E%3Cpath d='M530 657.362v120' fill='none' stroke='%23000' stroke-width='30' stroke-linejoin='round'%3E%3C/path%3E%3Cpath d='M189.492 753.127l52.112-120.562 197.995-33.528 116.925-217.774' fill='none' stroke='%23000' stroke-width='20' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E%3Cpath d='M470 717.362h120' fill='none' stroke='%23000' stroke-width='30' stroke-linejoin='round'%3E%3C/path%3E%3Ccircle cx='190' cy='752.362' r='25'%3E%3C/circle%3E%3Ccircle cx='555' cy='382.362' r='25'%3E%3C/circle%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='572.538' height='556.094' viewBox='0 0 26 26'%3E%3Cg fill='none' stroke-width='1'%3E%3Cpath fill='%23000' d='M7,2.014l13.162,12.328l-5.377,0.488l-0.977,0.088l0.406,0.894l3.263,7.145l-2.406,1.058l-3.113-7.222 l-0.391-0.91l-0.722,0.678l-3.819,3.582L7,2.014 M7,0.014c-0.27,0-0.54,0.054-0.797,0.166C5.472,0.497,4.999,1.219,5,2.017 l0.026,18.127c0.001,0.797,0.476,1.518,1.206,1.834c0.256,0.109,0.525,0.164,0.793,0.164c0.5,0,0.991-0.188,1.369-0.541 l2.463-2.311l2.377,5.516c0.211,0.489,0.61,0.874,1.104,1.069c0.235,0.093,0.484,0.139,0.732,0.139 c0.274,0,0.549-0.057,0.806-0.169l2.406-1.059c0.489-0.215,0.873-0.618,1.063-1.118c0.19-0.501,0.173-1.056-0.05-1.543l-2.498-5.47 l3.544-0.322c0.785-0.07,1.454-0.596,1.711-1.342c0.256-0.744,0.051-1.57-0.524-2.109L8.367,0.554C7.989,0.2,7.498,0.014,7,0.014 L7,0.014z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='453.495' height='454.649' viewBox='0 0 425.151 426.233'%3E%3Cg transform='translate(-171.22 -351.49)' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='308.946' cy='490.286' r='123.744' fill='%23fff' stroke='%238a8a8a' stroke-width='20'%3E%3C/circle%3E%3Ccircle cx='446.97' cy='628.322' r='138.23' fill='none' stroke='%238a8a8a' stroke-width='22.341'%3E%3C/circle%3E%3Cpath d='M307.462 363.99A123.744 123.744 0 0 0 183.72 487.734a123.744 123.744 0 0 0 123.742 123.744 123.744 123.744 0 0 0 .563-.02 138.23 138.23 0 0 0-.768 14.311 138.23 138.23 0 0 0 138.23 138.23 138.23 138.23 0 0 0 138.23-138.23 138.23 138.23 0 0 0-138.23-138.23 138.23 138.23 0 0 0-14.316.898 123.744 123.744 0 0 0 .035-.703A123.744 123.744 0 0 0 307.462 363.99z' fill='none' stroke='%23000' stroke-width='25'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='449.247' height='449.259' viewBox='0 0 421.169 421.181'%3E%3Cg transform='translate(-175.202 -356.542)' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='308.946' cy='490.286' r='123.744' fill='%23fff' stroke='%238a8a8a' stroke-width='20'%3E%3C/circle%3E%3Ccircle cx='446.97' cy='628.322' r='138.23' fill='none' stroke='%238a8a8a' stroke-width='22.341'%3E%3C/circle%3E%3Cpath d='M433.42 488.781a138.23 138.23 0 0 0-126.962 126.996 123.744 123.744 0 0 0 3.34.166A123.744 123.744 0 0 0 433.542 492.2a123.744 123.744 0 0 0-.121-3.418z' fill='%23fff' stroke='%23000' stroke-width='25'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e) { t.exports = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='449.247' height='449.259' viewBox='0 0 421.169 421.181'%3E%3Cg transform='translate(-175.202 -356.542)' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='308.946' cy='490.286' r='123.744' fill='%23fff' stroke='%238a8a8a' stroke-width='20'%3E%3C/circle%3E%3Ccircle cx='446.97' cy='628.322' r='138.23' fill='none' stroke='%238a8a8a' stroke-width='22.341'%3E%3C/circle%3E%3Cpath d='M308.946 366.542a123.744 123.744 0 0 0-123.744 123.744A123.744 123.744 0 0 0 308.946 614.03a123.744 123.744 0 0 0 .563-.02 138.23 138.23 0 0 1 123.146-123.023 123.744 123.744 0 0 0 .035-.7 123.744 123.744 0 0 0-123.744-123.745z' fill='%23fff' stroke='%23000' stroke-width='25'%3E%3C/path%3E%3C/g%3E%3C/svg%3E" }, function (t, e, n) { t.exports = n(20) }, function (t, e, n) { var i = n(17), r = n(18); "string" == typeof (r = r.__esModule ? r.default : r) && (r = [[t.i, r, ""]]); var s = { insert: "head", singleton: !1 }; i(r, s); t.exports = r.locals || {} }, function (t, e, n) { "use strict"; var i, r = function () { return void 0 === i && (i = Boolean(window && document && document.all && !window.atob)), i }, s = function () { var t = {}; return function (e) { if (void 0 === t[e]) { var n = document.querySelector(e); if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try { n = n.contentDocument.head } catch (t) { n = null } t[e] = n } return t[e] } }(), o = []; function a(t) { for (var e = -1, n = 0; n < o.length; n++)if (o[n].identifier === t) { e = n; break } return e } function l(t, e) { for (var n = {}, i = [], r = 0; r < t.length; r++) { var s = t[r], l = e.base ? s[0] + e.base : s[0], h = n[l] || 0, c = "".concat(l, " ").concat(h); n[l] = h + 1; var u = a(c), f = { css: s[1], media: s[2], sourceMap: s[3] }; -1 !== u ? (o[u].references++, o[u].updater(f)) : o.push({ identifier: c, updater: _(f, e), references: 1 }), i.push(c) } return i } function h(t) { var e = document.createElement("style"), i = t.attributes || {}; if (void 0 === i.nonce) { var r = n.nc; r && (i.nonce = r) } if (Object.keys(i).forEach((function (t) { e.setAttribute(t, i[t]) })), "function" == typeof t.insert) t.insert(e); else { var o = s(t.insert || "head"); if (!o) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); o.appendChild(e) } return e } var c, u = (c = [], function (t, e) { return c[t] = e, c.filter(Boolean).join("\n") }); function f(t, e, n, i) { var r = n ? "" : i.media ? "@media ".concat(i.media, " {").concat(i.css, "}") : i.css; if (t.styleSheet) t.styleSheet.cssText = u(e, r); else { var s = document.createTextNode(r), o = t.childNodes; o[e] && t.removeChild(o[e]), o.length ? t.insertBefore(s, o[e]) : t.appendChild(s) } } function p(t, e, n) { var i = n.css, r = n.media, s = n.sourceMap; if (r ? t.setAttribute("media", r) : t.removeAttribute("media"), s && "undefined" != typeof btoa && (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " */")), t.styleSheet) t.styleSheet.cssText = i; else { for (; t.firstChild;)t.removeChild(t.firstChild); t.appendChild(document.createTextNode(i)) } } var d = null, g = 0; function _(t, e) { var n, i, r; if (e.singleton) { var s = g++; n = d || (d = h(e)), i = f.bind(null, n, s, !1), r = f.bind(null, n, s, !0) } else n = h(e), i = p.bind(null, n, e), r = function () { !function (t) { if (null === t.parentNode) return !1; t.parentNode.removeChild(t) }(n) }; return i(t), function (e) { if (e) { if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return; i(t = e) } else r() } } t.exports = function (t, e) { (e = e || {}).singleton || "boolean" == typeof e.singleton || (e.singleton = r()); var n = l(t = t || [], e); return function (t) { if (t = t || [], "[object Array]" === Object.prototype.toString.call(t)) { for (var i = 0; i < n.length; i++) { var r = a(n[i]); o[r].references-- } for (var s = l(t, e), h = 0; h < n.length; h++) { var c = a(n[h]); 0 === o[c].references && (o[c].updater(), o.splice(c, 1)) } n = s } } } }, function (t, e, n) { (e = n(19)(!1)).push([t.i, "#ole-toolbar {\n  position: absolute;\n  right: 20px;\n  top: 20px;\n}\n\n/* shadow */\n#ole-toolbar button.ole-control,\n.ole-dialog {\n  box-shadow: 0 3px 3px 0 rgba(0, 0, 0, 0.2);\n}\n\n/* buttons */\n#ole-toolbar button.ole-control {\n  background: #fafafa;\n  border: 0;\n  color: #999;\n  cursor: pointer;\n  font-size: 14px;\n  line-height: 36px;\n  height: 45px;\n  transition: all 0.3s ease-out;\n  padding: 5px;\n}\n\n#ole-toolbar button.ole-control:first-child {\n  border-radius: 4px 0 0 4px;\n}\n\n#ole-toolbar button.ole-control:last-child {\n  border-radius: 0 4px 4px 0;\n}\n\n#ole-toolbar button.ole-control:hover {\n  color: #5c5c5c;\n}\n\n#ole-toolbar button.ole-control:focus {\n  outline: 0;\n}\n\n#ole-toolbar button.ole-control.active {\n  box-shadow: 0 4px 4px 0 rgba(0, 0, 0, 0.3);\n  color: #5c5c5c;\n  filter: brightness(90%);\n}\n\n#ole-toolbar button.ole-control img {\n  height: 35px;\n}\n\n/* dialog */\n.ole-dialog {\n  background: #fafafa;\n  border-radius: 4px;\n  right: 20px;\n  padding: 10px;\n  position: absolute;\n  text-align: left;\n  top: 75px;\n  width: 330px;\n  z-index: 2;\n}\n\n/* font */\n#ole-toolbar,\n.ole-dialog {\n  font-family: Arial, sans-serif;\n  font-size: 14px;\n}\n\n#width-input {\n  width: 50px;\n}\n", ""]), t.exports = e }, function (t, e, n) { "use strict"; t.exports = function (t) { var e = []; return e.toString = function () { return this.map((function (e) { var n = function (t, e) { var n = t[1] || "", i = t[3]; if (!i) return n; if (e && "function" == typeof btoa) { var r = (o = i, a = btoa(unescape(encodeURIComponent(JSON.stringify(o)))), l = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(a), "/*# ".concat(l, " */")), s = i.sources.map((function (t) { return "/*# sourceURL=".concat(i.sourceRoot || "").concat(t, " */") })); return [n].concat(s).concat([r]).join("\n") } var o, a, l; return [n].join("\n") }(e, t); return e[2] ? "@media ".concat(e[2], " {").concat(n, "}") : n })).join("") }, e.i = function (t, n, i) { "string" == typeof t && (t = [[null, t, ""]]); var r = {}; if (i) for (var s = 0; s < this.length; s++) { var o = this[s][0]; null != o && (r[o] = !0) } for (var a = 0; a < t.length; a++) { var l = [].concat(t[a]); i && r[l[0]] || (n && (l[2] ? l[2] = "".concat(n, " and ").concat(l[2]) : l[2] = n), e.push(l)) } }, e } }, function (t, e, n) { "use strict"; n.r(e), n.d(e, "control", (function () { return r })), n.d(e, "service", (function () { return s })), n.d(e, "interaction", (function () { return i })), n.d(e, "Editor", (function () { return _t })); var i = {}; n.r(i), n.d(i, "Select", (function () { return Yl })); var r = {}; n.r(r), n.d(r, "Control", (function () { return Dn })), n.d(r, "CAD", (function () { return la })), n.d(r, "Rotate", (function () { return Ca })), n.d(r, "Draw", (function () { return dl })), n.d(r, "Modify", (function () { return fh })), n.d(r, "Buffer", (function () { return pp })), n.d(r, "Union", (function () { return Id })), n.d(r, "Intersection", (function () { return Dd })), n.d(r, "Difference", (function () { return Vd })); var s = {}; function o() { return function () { throw new Error("Unimplemented abstract method.") }() } n.r(s), n.d(s, "Storage", (function () { return eg })), n.d(s, "LocalStorage", (function () { return cg })); var a = 0; function l(t) { return t.ol_uid || (t.ol_uid = String(++a)) } var h, c = (h = function (t, e) { return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } h(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }), u = function (t) { function e(e) { var n = this, i = "Assertion failed. See https://openlayers.org/en/" + ("v" + "6.4.3".split("-")[0]) + "/doc/errors/#" + e + " for details."; return (n = t.call(this, i) || this).code = e, n.name = "AssertionError", n.message = i, n } return c(e, t), e }(Error); var f = function () { function t(t) { this.propagationStopped, this.type = t, this.target = null } return t.prototype.preventDefault = function () { this.propagationStopped = !0 }, t.prototype.stopPropagation = function () { this.propagationStopped = !0 }, t }(), p = "propertychange", d = function () { function t() { this.disposed = !1 } return t.prototype.dispose = function () { this.disposed || (this.disposed = !0, this.disposeInternal()) }, t.prototype.disposeInternal = function () { }, t }(); function g(t, e) { return t > e ? 1 : t < e ? -1 : 0 } function _(t, e) { return t.indexOf(e) >= 0 } function y(t, e, n) { for (; e < n;) { var i = t[e]; t[e] = t[n], t[n] = i, ++e, --n } } function m(t, e) { for (var n = Array.isArray(e) ? e : [e], i = n.length, r = 0; r < i; r++)t[t.length] = n[r] } function v(t, e) { var n = t.length; if (n !== e.length) return !1; for (var i = 0; i < n; i++)if (t[i] !== e[i]) return !1; return !0 } function x() { return !0 } function E() { return !1 } function I() { } var C = "function" == typeof Object.assign ? Object.assign : function (t, e) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var n = Object(t), i = 1, r = arguments.length; i < r; ++i) { var s = arguments[i]; if (null != s) for (var o in s) s.hasOwnProperty(o) && (n[o] = s[o]) } return n }; function w(t) { for (var e in t) delete t[e] } var S = "function" == typeof Object.values ? Object.values : function (t) { var e = []; for (var n in t) e.push(t[n]); return e }; function b(t) { var e; for (e in t) return !1; return !e } var O = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), T = function (t) { function e(e) { var n = t.call(this) || this; return n.eventTarget_ = e, n.pendingRemovals_ = null, n.dispatching_ = null, n.listeners_ = null, n } return O(e, t), e.prototype.addEventListener = function (t, e) { if (t && e) { var n = this.listeners_ || (this.listeners_ = {}), i = n[t] || (n[t] = []); -1 === i.indexOf(e) && i.push(e) } }, e.prototype.dispatchEvent = function (t) { var e = "string" == typeof t ? new f(t) : t, n = e.type; e.target || (e.target = this.eventTarget_ || this); var i, r = this.listeners_ && this.listeners_[n]; if (r) { var s = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {}); n in s || (s[n] = 0, o[n] = 0), ++s[n]; for (var a = 0, l = r.length; a < l; ++a)if (!1 === (i = "handleEvent" in r[a] ? r[a].handleEvent(e) : r[a].call(this, e)) || e.propagationStopped) { i = !1; break } if (--s[n], 0 === s[n]) { var h = o[n]; for (delete o[n]; h--;)this.removeEventListener(n, I); delete s[n] } return i } }, e.prototype.disposeInternal = function () { this.listeners_ && w(this.listeners_) }, e.prototype.getListeners = function (t) { return this.listeners_ && this.listeners_[t] || void 0 }, e.prototype.hasListener = function (t) { return !!this.listeners_ && (t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0) }, e.prototype.removeEventListener = function (t, e) { var n = this.listeners_ && this.listeners_[t]; if (n) { var i = n.indexOf(e); -1 !== i && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (n[i] = I, ++this.pendingRemovals_[t]) : (n.splice(i, 1), 0 === n.length && delete this.listeners_[t])) } }, e }(d), R = "change", N = "error", L = "contextmenu", P = "click", M = "dblclick", D = "load"; function A(t, e, n, i, r) { if (i && i !== t && (n = n.bind(i)), r) { var s = n; n = function () { t.removeEventListener(e, n), s.apply(this, arguments) } } var o = { target: t, type: e, listener: n }; return t.addEventListener(e, n), o } function F(t, e, n, i) { return A(t, e, n, i, !0) } function k(t) { t && t.target && (t.target.removeEventListener(t.type, t.listener), w(t)) } var G = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); function j(t) { if (Array.isArray(t)) for (var e = 0, n = t.length; e < n; ++e)k(t[e]); else k(t) } var B = function (t) { function e() { var e = t.call(this) || this; return e.revision_ = 0, e } return G(e, t), e.prototype.changed = function () { ++this.revision_, this.dispatchEvent(R) }, e.prototype.getRevision = function () { return this.revision_ }, e.prototype.on = function (t, e) { if (Array.isArray(t)) { for (var n = t.length, i = new Array(n), r = 0; r < n; ++r)i[r] = A(this, t[r], e); return i } return A(this, t, e) }, e.prototype.once = function (t, e) { var n; if (Array.isArray(t)) { var i = t.length; n = new Array(i); for (var r = 0; r < i; ++r)n[r] = F(this, t[r], e) } else n = F(this, t, e); return e.ol_key = n, n }, e.prototype.un = function (t, e) { var n = e.ol_key; if (n) j(n); else if (Array.isArray(t)) for (var i = 0, r = t.length; i < r; ++i)this.removeEventListener(t[i], e); else this.removeEventListener(t, e) }, e }(T), Y = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), q = function (t) { function e(e, n, i) { var r = t.call(this, e) || this; return r.key = n, r.oldValue = i, r } return Y(e, t), e }(f), X = function (t) { function e(e) { var n = t.call(this) || this; return l(n), n.values_ = null, void 0 !== e && n.setProperties(e), n } return Y(e, t), e.prototype.get = function (t) { var e; return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e }, e.prototype.getKeys = function () { return this.values_ && Object.keys(this.values_) || [] }, e.prototype.getProperties = function () { return this.values_ && C({}, this.values_) || {} }, e.prototype.hasProperties = function () { return !!this.values_ }, e.prototype.notify = function (t, e) { var n; n = U(t), this.dispatchEvent(new q(n, t, e)), n = p, this.dispatchEvent(new q(n, t, e)) }, e.prototype.set = function (t, e, n) { var i = this.values_ || (this.values_ = {}); if (n) i[t] = e; else { var r = i[t]; i[t] = e, r !== e && this.notify(t, r) } }, e.prototype.setProperties = function (t, e) { for (var n in t) this.set(n, t[n], e) }, e.prototype.unset = function (t, e) { if (this.values_ && t in this.values_) { var n = this.values_[t]; delete this.values_[t], b(this.values_) && (this.values_ = null), e || this.notify(t, n) } }, e }(B), z = {}; function U(t) { return z.hasOwnProperty(t) ? z[t] : z[t] = "change:" + t } var V = X, W = "add", H = "remove", K = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Z = "length", J = function (t) { function e(e, n, i) { var r = t.call(this, e) || this; return r.element = n, r.index = i, r } return K(e, t), e }(f), Q = function (t) { function e(e, n) { var i = t.call(this) || this, r = n || {}; if (i.unique_ = !!r.unique, i.array_ = e || [], i.unique_) for (var s = 0, o = i.array_.length; s < o; ++s)i.assertUnique_(i.array_[s], s); return i.updateLength_(), i } return K(e, t), e.prototype.clear = function () { for (; this.getLength() > 0;)this.pop() }, e.prototype.extend = function (t) { for (var e = 0, n = t.length; e < n; ++e)this.push(t[e]); return this }, e.prototype.forEach = function (t) { for (var e = this.array_, n = 0, i = e.length; n < i; ++n)t(e[n], n, e) }, e.prototype.getArray = function () { return this.array_ }, e.prototype.item = function (t) { return this.array_[t] }, e.prototype.getLength = function () { return this.get(Z) }, e.prototype.insertAt = function (t, e) { this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new J(W, e, t)) }, e.prototype.pop = function () { return this.removeAt(this.getLength() - 1) }, e.prototype.push = function (t) { this.unique_ && this.assertUnique_(t); var e = this.getLength(); return this.insertAt(e, t), this.getLength() }, e.prototype.remove = function (t) { for (var e = this.array_, n = 0, i = e.length; n < i; ++n)if (e[n] === t) return this.removeAt(n) }, e.prototype.removeAt = function (t) { var e = this.array_[t]; return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new J(H, e, t)), e }, e.prototype.setAt = function (t, e) { var n = this.getLength(); if (t < n) { this.unique_ && this.assertUnique_(e, t); var i = this.array_[t]; this.array_[t] = e, this.dispatchEvent(new J(H, i, t)), this.dispatchEvent(new J(W, e, t)) } else { for (var r = n; r < t; ++r)this.insertAt(r, void 0); this.insertAt(t, e) } }, e.prototype.updateLength_ = function () { this.set(Z, this.array_.length) }, e.prototype.assertUnique_ = function (t, e) { for (var n = 0, i = this.array_.length; n < i; ++n)if (this.array_[n] === t && n !== e) throw new u(58) }, e }(V), $ = "postrender", tt = "undefined" != typeof navigator && void 0 !== navigator.userAgent ? navigator.userAgent.toLowerCase() : "", et = (tt.indexOf("firefox"), -1 !== tt.indexOf("safari") && tt.indexOf("chrom"), -1 !== tt.indexOf("webkit") && tt.indexOf("edge"), tt.indexOf("macintosh"), "undefined" != typeof devicePixelRatio && devicePixelRatio, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof OffscreenCanvas && self instanceof WorkerGlobalScope), nt = "undefined" != typeof Image && Image.prototype.decode; !function () { var t = !1; try { var e = Object.defineProperty({}, "passive", { get: function () { t = !0 } }); window.addEventListener("_", null, e), window.removeEventListener("_", null, e) } catch (t) { } }(); function it(t, e, n) { var i = n && n.length ? n.shift() : et ? new OffscreenCanvas(t || 300, e || 300) : document.createElement("canvas"); return t && (i.width = t), e && (i.height = e), i.getContext("2d") } function rt(t) { return t && t.parentNode ? t.parentNode.removeChild(t) : null } var st = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), ot = function (t) { function e(e) { var n = t.call(this) || this, i = e.element; return !i || e.target || i.style.pointerEvents || (i.style.pointerEvents = "auto"), n.element = i || null, n.target_ = null, n.map_ = null, n.listenerKeys = [], e.render && (n.render = e.render), e.target && n.setTarget(e.target), n } return st(e, t), e.prototype.disposeInternal = function () { rt(this.element), t.prototype.disposeInternal.call(this) }, e.prototype.getMap = function () { return this.map_ }, e.prototype.setMap = function (t) { this.map_ && rt(this.element); for (var e = 0, n = this.listenerKeys.length; e < n; ++e)k(this.listenerKeys[e]); (this.listenerKeys.length = 0, this.map_ = t, this.map_) && ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== I && this.listenerKeys.push(A(t, $, this.render, this)), t.render()) }, e.prototype.render = function (t) { }, e.prototype.setTarget = function (t) { this.target_ = "string" == typeof t ? document.getElementById(t) : t }, e }(V); n(16); function at(t) { return (at = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function lt(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function ht(t, e) { return (ht = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function ct(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = pt(t); if (e) { var r = pt(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return ut(this, n) } } function ut(t, e) { return !e || "object" !== at(e) && "function" != typeof e ? ft(t) : e } function ft(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function pt(t) { return (pt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var dt = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && ht(t, e) }(s, t); var e, n, i, r = ct(s); function s(t, e, n) { var i; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s); var o = document.createElement("div"); return o.setAttribute("id", "ole-toolbar"), (i = r.call(this, { element: n || o })).controls = e, i.map = t, n || i.map.getTargetElement().appendChild(i.element), i.load(), i.controls.on("change:length", i.load.bind(ft(i))), i } return e = s, (n = [{ key: "load", value: function () { for (var t = 0; t < this.controls.getLength(); t += 1) { var e = this.controls.item(t).getElement(); this.element.appendChild(e) } } }, { key: "destroy", value: function () { for (var t = 0; t < this.controls.getLength(); t += 1) { var e = this.controls.item(t).getElement(); this.element.removeChild(e) } } }]) && lt(e.prototype, n), i && lt(e, i), s }(ot); function gt(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } var _t = function () { function t(e, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.map = e, this.controls = new Q, this.activeControls = new Q, this.services = new Q, this.options = n || {}, this.editFeature = null, void 0 === this.options.showToolbar && (this.options.showToolbar = !0), this.options.showToolbar && (this.toolbar = new dt(this.map, this.controls, this.options.target)) } var e, n, i; return e = t, (n = [{ key: "addControl", value: function (t) { var e = this; t.setMap(this.map), t.setEditor(this), t.addEventListener("change:active", (function (t) { e.activeStateChange(t.detail.control) })), this.controls.push(t) } }, { key: "addService", value: function (t) { t.setMap(this.map), t.setEditor(this), t.activate(), this.services.push(t) } }, { key: "addControls", value: function (t) { for (var e = t instanceof Q ? t : new Q(t), n = 0; n < e.getLength(); n += 1)this.addControl(e.item(n)) } }, { key: "remove", value: function () { this.controls.forEach((function (t) { t.deactivate(!0) })), this.toolbar && this.toolbar.destroy() } }, { key: "getControls", value: function () { return this.controls } }, { key: "getActiveControls", value: function () { return this.activeControls } }, { key: "setEditFeature", value: function (t) { this.editFeature = t } }, { key: "getEditFeature", value: function () { return this.editFeature } }, { key: "activeStateChange", value: function (t) { if (t.getActive() && t.standalone) for (var e = 0; e < this.controls.getLength(); e += 1) { var n = this.controls.item(e); n !== t && n.getActive() && n.standalone && (n.deactivate(), this.activeControls.remove(n)) } t.getActive() ? this.activeControls.push(t) : this.activeControls.remove(t) } }]) && gt(e.prototype, n), i && gt(e, i), t }(), yt = n(1), mt = n.n(yt), vt = 0, xt = 1, Et = 2, It = 4, Ct = 8, wt = 16; function St(t, e) { if (!t) throw new u(e) } function bt(t) { for (var e = Pt(), n = 0, i = t.length; n < i; ++n)Gt(e, t[n]); return e } function Ot(t, e, n) { return n ? (n[0] = t[0] - e, n[1] = t[1] - e, n[2] = t[2] + e, n[3] = t[3] + e, n) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e] } function Tt(t, e, n) { var i, r; return (i = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0) * i + (r = n < t[1] ? t[1] - n : t[3] < n ? n - t[3] : 0) * r } function Rt(t, e) { return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3] } function Nt(t, e, n) { return t[0] <= e && e <= t[2] && t[1] <= n && n <= t[3] } function Lt(t, e) { var n = t[0], i = t[1], r = t[2], s = t[3], o = e[0], a = e[1], l = vt; return o < n ? l |= wt : o > r && (l |= It), a < i ? l |= Ct : a > s && (l |= Et), l === vt && (l = xt), l } function Pt() { return [1 / 0, 1 / 0, -1 / 0, -1 / 0] } function Mt(t, e, n, i, r) { return r ? (r[0] = t, r[1] = e, r[2] = n, r[3] = i, r) : [t, e, n, i] } function Dt(t) { return Mt(1 / 0, 1 / 0, -1 / 0, -1 / 0, t) } function At(t, e) { var n = t[0], i = t[1]; return Mt(n, i, n, i, e) } function Ft(t, e, n, i, r) { return jt(Dt(r), t, e, n, i) } function kt(t, e) { return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3] } function Gt(t, e) { e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]) } function jt(t, e, n, i, r) { for (; n < i; n += r)Bt(t, e[n], e[n + 1]); return t } function Bt(t, e, n) { t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], n), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], n) } function Yt(t, e) { var n; return (n = e(qt(t))) || (n = e(Xt(t))) || (n = e(Wt(t))) ? n : (n = e(Vt(t))) || !1 } function qt(t) { return [t[0], t[1]] } function Xt(t) { return [t[2], t[1]] } function zt(t) { return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2] } function Ut(t) { return t[3] - t[1] } function Vt(t) { return [t[0], t[3]] } function Wt(t) { return [t[2], t[3]] } function Ht(t) { return t[2] - t[0] } function Kt(t, e) { return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1] } function Zt(t, e, n, i) { var r = []; if (i > 1) for (var s = t[2] - t[0], o = t[3] - t[1], a = 0; a < i; ++a)r.push(t[0] + s * a / i, t[1], t[2], t[1] + o * a / i, t[2] - s * a / i, t[3], t[0], t[3] - o * a / i); else r = [t[0], t[1], t[2], t[1], t[2], t[3], t[0], t[3]]; e(r, r, 2); for (var l = [], h = [], c = (a = 0, r.length); a < c; a += 2)l.push(r[a]), h.push(r[a + 1]); return function (t, e, n) { return Mt(Math.min.apply(null, t), Math.min.apply(null, e), Math.max.apply(null, t), Math.max.apply(null, e), n) }(l, h, n) } var Jt = function () { function t(t) { this.rbush_ = new mt.a(t), this.items_ = {} } return t.prototype.insert = function (t, e) { var n = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e }; this.rbush_.insert(n), this.items_[l(e)] = n }, t.prototype.load = function (t, e) { for (var n = new Array(e.length), i = 0, r = e.length; i < r; i++) { var s = t[i], o = e[i], a = { minX: s[0], minY: s[1], maxX: s[2], maxY: s[3], value: o }; n[i] = a, this.items_[l(o)] = a } this.rbush_.load(n) }, t.prototype.remove = function (t) { var e = l(t), n = this.items_[e]; return delete this.items_[e], null !== this.rbush_.remove(n) }, t.prototype.update = function (t, e) { var n = this.items_[l(e)]; kt([n.minX, n.minY, n.maxX, n.maxY], t) || (this.remove(e), this.insert(t, e)) }, t.prototype.getAll = function () { return this.rbush_.all().map((function (t) { return t.value })) }, t.prototype.getInExtent = function (t) { var e = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] }; return this.rbush_.search(e).map((function (t) { return t.value })) }, t.prototype.forEach = function (t) { return this.forEach_(this.getAll(), t) }, t.prototype.forEachInExtent = function (t, e) { return this.forEach_(this.getInExtent(t), e) }, t.prototype.forEach_ = function (t, e) { for (var n, i = 0, r = t.length; i < r; i++)if (n = e(t[i])) return n; return n }, t.prototype.isEmpty = function () { return b(this.items_) }, t.prototype.clear = function () { this.rbush_.clear(), this.items_ = {} }, t.prototype.getExtent = function (t) { var e = this.rbush_.toJSON(); return Mt(e.minX, e.minY, e.maxX, e.maxY, t) }, t.prototype.concat = function (t) { for (var e in this.rbush_.load(t.rbush_.all()), t.items_) this.items_[e] = t.items_[e] }, t }(), Qt = "undefined", $t = "ready", te = { DEGREES: "degrees", FEET: "ft", METERS: "m", PIXELS: "pixels", TILE_PIXELS: "tile-pixels", USFEET: "us-ft" }, ee = {}; ee[te.DEGREES] = 2 * Math.PI * 6370997 / 360, ee[te.FEET] = .3048, ee[te.METERS] = 1, ee[te.USFEET] = 1200 / 3937; var ne = te, ie = function () { function t(t) { this.code_ = t.code, this.units_ = t.units, this.extent_ = void 0 !== t.extent ? t.extent : null, this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null, this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : "enu", this.global_ = void 0 !== t.global && t.global, this.canWrapX_ = !(!this.global_ || !this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit } return t.prototype.canWrapX = function () { return this.canWrapX_ }, t.prototype.getCode = function () { return this.code_ }, t.prototype.getExtent = function () { return this.extent_ }, t.prototype.getUnits = function () { return this.units_ }, t.prototype.getMetersPerUnit = function () { return this.metersPerUnit_ || ee[this.units_] }, t.prototype.getWorldExtent = function () { return this.worldExtent_ }, t.prototype.getAxisOrientation = function () { return this.axisOrientation_ }, t.prototype.isGlobal = function () { return this.global_ }, t.prototype.setGlobal = function (t) { this.global_ = t, this.canWrapX_ = !(!t || !this.extent_) }, t.prototype.getDefaultTileGrid = function () { return this.defaultTileGrid_ }, t.prototype.setDefaultTileGrid = function (t) { this.defaultTileGrid_ = t }, t.prototype.setExtent = function (t) { this.extent_ = t, this.canWrapX_ = !(!this.global_ || !t) }, t.prototype.setWorldExtent = function (t) { this.worldExtent_ = t }, t.prototype.setGetPointResolution = function (t) { this.getPointResolutionFunc_ = t }, t.prototype.getPointResolutionFunc = function () { return this.getPointResolutionFunc_ }, t }(); function re(t, e, n) { return Math.min(Math.max(t, e), n) } var se = "cosh" in Math ? Math.cosh : function (t) { var e = Math.exp(t); return (e + 1 / e) / 2 }; "log2" in Math && Math.log2; function oe(t, e, n, i, r, s) { var o = r - n, a = s - i; if (0 !== o || 0 !== a) { var l = ((t - n) * o + (e - i) * a) / (o * o + a * a); l > 1 ? (n = r, i = s) : l > 0 && (n += o * l, i += a * l) } return ae(t, e, n, i) } function ae(t, e, n, i) { var r = n - t, s = i - e; return r * r + s * s } function le(t, e) { var n = t % e; return n * e < 0 ? n + e : n } function he(t, e, n) { return t + n * (e - t) } var ce = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), ue = 6378137 * Math.PI, fe = [-ue, -ue, ue, ue], pe = [-180, -85, 180, 85], de = function (t) { function e(e) { return t.call(this, { code: e, units: ne.METERS, extent: fe, global: !0, worldExtent: pe, getPointResolution: function (t, e) { return t / se(e[1] / 6378137) } }) || this } return ce(e, t), e }(ie), ge = [new de("EPSG:3857"), new de("EPSG:102100"), new de("EPSG:102113"), new de("EPSG:900913"), new de("urn:ogc:def:crs:EPSG:6.18:3:3857"), new de("urn:ogc:def:crs:EPSG::3857"), new de("http://www.opengis.net/gml/srs/epsg.xml#3857")]; function _e(t, e, n) { var i = t.length, r = n > 1 ? n : 2, s = e; void 0 === s && (s = r > 2 ? t.slice() : new Array(i)); for (var o = ue, a = 0; a < i; a += r) { s[a] = o * t[a] / 180; var l = 6378137 * Math.log(Math.tan(Math.PI * (+t[a + 1] + 90) / 360)); l > o ? l = o : l < -o && (l = -o), s[a + 1] = l } return s } function ye(t, e, n) { var i = t.length, r = n > 1 ? n : 2, s = e; void 0 === s && (s = r > 2 ? t.slice() : new Array(i)); for (var o = 0; o < i; o += r)s[o] = 180 * t[o] / ue, s[o + 1] = 360 * Math.atan(Math.exp(t[o + 1] / 6378137)) / Math.PI - 90; return s } var me = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), ve = [-180, -90, 180, 90], xe = 6378137 * Math.PI / 180, Ee = function (t) { function e(e, n) { return t.call(this, { code: e, units: ne.DEGREES, extent: ve, axisOrientation: n, global: !0, metersPerUnit: xe, worldExtent: ve }) || this } return me(e, t), e }(ie), Ie = [new Ee("CRS:84"), new Ee("EPSG:4326", "neu"), new Ee("urn:ogc:def:crs:EPSG::4326", "neu"), new Ee("urn:ogc:def:crs:EPSG:6.6:4326", "neu"), new Ee("urn:ogc:def:crs:OGC:1.3:CRS84"), new Ee("urn:ogc:def:crs:OGC:2:84"), new Ee("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new Ee("urn:x-ogc:def:crs:EPSG:4326", "neu")], Ce = {}; var we = {}; function Se(t, e, n) { var i = t.getCode(), r = e.getCode(); i in we || (we[i] = {}), we[i][r] = n } var be = "Point", Oe = "LineString", Te = "LinearRing", Re = "Polygon", Ne = "MultiPoint", Le = "MultiLineString", Pe = "MultiPolygon", Me = "GeometryCollection", De = "Circle"; function Ae(t, e) { var n, i, r = t[0], s = t[1], o = e[0], a = e[1], l = o[0], h = o[1], c = a[0], u = a[1], f = c - l, p = u - h, d = 0 === f && 0 === p ? 0 : (f * (r - l) + p * (s - h)) / (f * f + p * p || 0); return d <= 0 ? (n = l, i = h) : d >= 1 ? (n = c, i = u) : (n = l + d * f, i = h + d * p), [n, i] } function Fe(t, e) { for (var n = !0, i = t.length - 1; i >= 0; --i)if (t[i] != e[i]) { n = !1; break } return n } function ke(t, e) { var n = t[0] - e[0], i = t[1] - e[1]; return n * n + i * i } function Ge(t, e) { return Math.sqrt(ke(t, e)) } function je(t, e) { return ke(t, Ae(t, e)) } function Be(t, e, n) { var i = e.getExtent(), r = 0; if (e.canWrapX() && (t[0] < i[0] || t[0] > i[2])) { var s = n || Ht(i); r = Math.floor((t[0] - i[0]) / s) } return r } function Ye(t, e, n) { var i; if (void 0 !== e) { for (var r = 0, s = t.length; r < s; ++r)e[r] = t[r]; i = e } else i = t.slice(); return i } function qe(t, e, n) { if (void 0 !== e && t !== e) { for (var i = 0, r = t.length; i < r; ++i)e[i] = t[i]; t = e } return t } function Xe(t) { !function (t, e) { Ce[t] = e }(t.getCode(), t), Se(t, t, Ye) } function ze(t) { return "string" == typeof t ? Ce[t] || null : t || null } function Ue(t) { !function (t) { t.forEach(Xe) }(t), t.forEach((function (e) { t.forEach((function (t) { e !== t && Se(e, t, Ye) })) })) } function Ve(t, e) { var n = function (t, e) { var n; return t in we && e in we[t] && (n = we[t][e]), n }(t.getCode(), e.getCode()); return n || (n = qe), n } function We(t, e) { return Ve(ze(t), ze(e)) } function He(t, e, n) { return We(e, n)(t, void 0, t.length) } function Ke(t, e, n, i) { return Zt(t, We(e, n), void 0, i) } var Ze, Je, Qe, $e = null; function tn() { return $e } function en(t, e) { return $e ? He(t, e, $e) : t } function nn(t, e) { return $e ? He(t, $e, e) : t } function rn(t, e) { return $e ? Ke(t, e, $e) : t } function sn(t, e) { return $e ? Ke(t, $e, e) : t } Ue(ge), Ue(Ie), Ze = ge, Je = _e, Qe = ye, Ie.forEach((function (t) { Ze.forEach((function (e) { Se(t, e, Je), Se(e, t, Qe) })) })); var on = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); function an(t) { return t ? Array.isArray(t) ? function (e) { return t } : "function" == typeof t ? t : function (e) { return [t] } : null } var ln = function (t) { function e(e) { var n = t.call(this) || this; return n.projection_ = ze(e.projection), n.attributions_ = an(e.attributions), n.attributionsCollapsible_ = void 0 === e.attributionsCollapsible || e.attributionsCollapsible, n.loading = !1, n.state_ = void 0 !== e.state ? e.state : $t, n.wrapX_ = void 0 !== e.wrapX && e.wrapX, n } return on(e, t), e.prototype.getAttributions = function () { return this.attributions_ }, e.prototype.getAttributionsCollapsible = function () { return this.attributionsCollapsible_ }, e.prototype.getProjection = function () { return this.projection_ }, e.prototype.getResolutions = function () { return o() }, e.prototype.getState = function () { return this.state_ }, e.prototype.getWrapX = function () { return this.wrapX_ }, e.prototype.getContextOptions = function () { }, e.prototype.refresh = function () { this.changed() }, e.prototype.setAttributions = function (t) { this.attributions_ = an(t), this.changed() }, e.prototype.setState = function (t) { this.state_ = t, this.changed() }, e }(V), hn = "addfeature", cn = "changefeature", un = "clear", fn = "removefeature"; function pn(t, e) { return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]] } var dn = "arraybuffer", gn = "json", _n = "text", yn = "xml", mn = !1; function vn(t, e) { return function (t, e, n, i) { return function (r, s, o) { var a = new XMLHttpRequest; a.open("GET", "function" == typeof t ? t(r, s, o) : t, !0), e.getType() == dn && (a.responseType = "arraybuffer"), a.withCredentials = mn, a.onload = function (t) { if (!a.status || a.status >= 200 && a.status < 300) { var s = e.getType(), l = void 0; s == gn || s == _n ? l = a.responseText : s == yn ? (l = a.responseXML) || (l = (new DOMParser).parseFromString(a.responseText, "application/xml")) : s == dn && (l = a.response), l ? n.call(this, e.readFeatures(l, { extent: r, featureProjection: o }), e.readProjection(l)) : i.call(this) } else i.call(this) }.bind(this), a.onerror = function () { i.call(this) }.bind(this), a.send() } }(t, e, (function (t, e) { "function" == typeof this.addFeatures && this.addFeatures(t) }), I) } var xn = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), En = function (t) { function e(e, n) { var i = t.call(this, e) || this; return i.feature = n, i } return xn(e, t), e }(f), In = function (t) { function e(e) { var n = this, i = e || {}; (n = t.call(this, { attributions: i.attributions, projection: void 0, state: $t, wrapX: void 0 === i.wrapX || i.wrapX }) || this).loader_ = I, n.format_ = i.format, n.overlaps_ = void 0 === i.overlaps || i.overlaps, n.url_ = i.url, void 0 !== i.loader ? n.loader_ = i.loader : void 0 !== n.url_ && (St(n.format_, 7), n.loader_ = vn(n.url_, n.format_)), n.strategy_ = void 0 !== i.strategy ? i.strategy : pn; var r, s, o = void 0 === i.useSpatialIndex || i.useSpatialIndex; return n.featuresRtree_ = o ? new Jt : null, n.loadedExtentsRtree_ = new Jt, n.nullGeometryFeatures_ = {}, n.idIndex_ = {}, n.uidIndex_ = {}, n.featureChangeKeys_ = {}, n.featuresCollection_ = null, Array.isArray(i.features) ? s = i.features : i.features && (s = (r = i.features).getArray()), o || void 0 !== r || (r = new Q(s)), void 0 !== s && n.addFeaturesInternal(s), void 0 !== r && n.bindFeaturesCollection_(r), n } return xn(e, t), e.prototype.addFeature = function (t) { this.addFeatureInternal(t), this.changed() }, e.prototype.addFeatureInternal = function (t) { var e = l(t); if (this.addToIndex_(e, t)) { this.setupChangeEvents_(e, t); var n = t.getGeometry(); if (n) { var i = n.getExtent(); this.featuresRtree_ && this.featuresRtree_.insert(i, t) } else this.nullGeometryFeatures_[e] = t; this.dispatchEvent(new En(hn, t)) } else this.featuresCollection_ && this.featuresCollection_.remove(t) }, e.prototype.setupChangeEvents_ = function (t, e) { this.featureChangeKeys_[t] = [A(e, R, this.handleFeatureChange_, this), A(e, p, this.handleFeatureChange_, this)] }, e.prototype.addToIndex_ = function (t, e) { var n = !0, i = e.getId(); return void 0 !== i && (i.toString() in this.idIndex_ ? n = !1 : this.idIndex_[i.toString()] = e), n && (St(!(t in this.uidIndex_), 30), this.uidIndex_[t] = e), n }, e.prototype.addFeatures = function (t) { this.addFeaturesInternal(t), this.changed() }, e.prototype.addFeaturesInternal = function (t) { for (var e = [], n = [], i = [], r = 0, s = t.length; r < s; r++) { var o = l(h = t[r]); this.addToIndex_(o, h) && n.push(h) } r = 0; for (var a = n.length; r < a; r++) { var h; o = l(h = n[r]); this.setupChangeEvents_(o, h); var c = h.getGeometry(); if (c) { var u = c.getExtent(); e.push(u), i.push(h) } else this.nullGeometryFeatures_[o] = h } this.featuresRtree_ && this.featuresRtree_.load(e, i); r = 0; for (var f = n.length; r < f; r++)this.dispatchEvent(new En(hn, n[r])) }, e.prototype.bindFeaturesCollection_ = function (t) { var e = !1; this.addEventListener(hn, (function (n) { e || (e = !0, t.push(n.feature), e = !1) })), this.addEventListener(fn, (function (n) { e || (e = !0, t.remove(n.feature), e = !1) })), t.addEventListener(W, function (t) { e || (e = !0, this.addFeature(t.element), e = !1) }.bind(this)), t.addEventListener(H, function (t) { e || (e = !0, this.removeFeature(t.element), e = !1) }.bind(this)), this.featuresCollection_ = t }, e.prototype.clear = function (t) { if (t) { for (var e in this.featureChangeKeys_) { this.featureChangeKeys_[e].forEach(k) } this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}) } else if (this.featuresRtree_) for (var n in this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this)), this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[n]); this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {}; var i = new En(un); this.dispatchEvent(i), this.changed() }, e.prototype.forEachFeature = function (t) { if (this.featuresRtree_) return this.featuresRtree_.forEach(t); this.featuresCollection_ && this.featuresCollection_.forEach(t) }, e.prototype.forEachFeatureAtCoordinateDirect = function (t, e) { var n = [t[0], t[1], t[0], t[1]]; return this.forEachFeatureInExtent(n, (function (n) { return n.getGeometry().intersectsCoordinate(t) ? e(n) : void 0 })) }, e.prototype.forEachFeatureInExtent = function (t, e) { if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e); this.featuresCollection_ && this.featuresCollection_.forEach(e) }, e.prototype.forEachFeatureIntersectingExtent = function (t, e) { return this.forEachFeatureInExtent(t, (function (n) { if (n.getGeometry().intersectsExtent(t)) { var i = e(n); if (i) return i } })) }, e.prototype.getFeaturesCollection = function () { return this.featuresCollection_ }, e.prototype.getFeatures = function () { var t; return this.featuresCollection_ ? t = this.featuresCollection_.getArray() : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), b(this.nullGeometryFeatures_) || m(t, S(this.nullGeometryFeatures_))), t }, e.prototype.getFeaturesAtCoordinate = function (t) { var e = []; return this.forEachFeatureAtCoordinateDirect(t, (function (t) { e.push(t) })), e }, e.prototype.getFeaturesInExtent = function (t) { return this.featuresRtree_ ? this.featuresRtree_.getInExtent(t) : this.featuresCollection_ ? this.featuresCollection_.getArray() : [] }, e.prototype.getClosestFeatureToCoordinate = function (t, e) { var n = t[0], i = t[1], r = null, s = [NaN, NaN], o = 1 / 0, a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0], l = e || x; return this.featuresRtree_.forEachInExtent(a, (function (t) { if (l(t)) { var e = t.getGeometry(), h = o; if ((o = e.closestPointXY(n, i, s, o)) < h) { r = t; var c = Math.sqrt(o); a[0] = n - c, a[1] = i - c, a[2] = n + c, a[3] = i + c } } })), r }, e.prototype.getExtent = function (t) { return this.featuresRtree_.getExtent(t) }, e.prototype.getFeatureById = function (t) { var e = this.idIndex_[t.toString()]; return void 0 !== e ? e : null }, e.prototype.getFeatureByUid = function (t) { var e = this.uidIndex_[t]; return void 0 !== e ? e : null }, e.prototype.getFormat = function () { return this.format_ }, e.prototype.getOverlaps = function () { return this.overlaps_ }, e.prototype.getUrl = function () { return this.url_ }, e.prototype.handleFeatureChange_ = function (t) { var e = t.target, n = l(e), i = e.getGeometry(); if (i) { var r = i.getExtent(); n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(r, e)) : this.featuresRtree_ && this.featuresRtree_.update(r, e) } else n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[n] = e); var s = e.getId(); if (void 0 !== s) { var o = s.toString(); this.idIndex_[o] !== e && (this.removeFromIdIndex_(e), this.idIndex_[o] = e) } else this.removeFromIdIndex_(e), this.uidIndex_[n] = e; this.changed(), this.dispatchEvent(new En(cn, e)) }, e.prototype.hasFeature = function (t) { var e = t.getId(); return void 0 !== e ? e in this.idIndex_ : l(t) in this.uidIndex_ }, e.prototype.isEmpty = function () { return this.featuresRtree_.isEmpty() && b(this.nullGeometryFeatures_) }, e.prototype.loadFeatures = function (t, e, n) { var i = this.loadedExtentsRtree_, r = this.strategy_(t, e); this.loading = !1; for (var s = function (t, s) { var a = r[t]; i.forEachInExtent(a, (function (t) { return Rt(t.extent, a) })) || (o.loader_.call(o, a, e, n), i.insert(a, { extent: a.slice() }), o.loading = o.loader_ !== I) }, o = this, a = 0, l = r.length; a < l; ++a)s(a) }, e.prototype.refresh = function () { this.clear(!0), this.loadedExtentsRtree_.clear(), t.prototype.refresh.call(this) }, e.prototype.removeLoadedExtent = function (t) { var e, n = this.loadedExtentsRtree_; n.forEachInExtent(t, (function (n) { if (kt(n.extent, t)) return e = n, !0 })), e && n.remove(e) }, e.prototype.removeFeature = function (t) { var e = l(t); e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t), this.removeFeatureInternal(t), this.changed() }, e.prototype.removeFeatureInternal = function (t) { var e = l(t); this.featureChangeKeys_[e].forEach(k), delete this.featureChangeKeys_[e]; var n = t.getId(); void 0 !== n && delete this.idIndex_[n.toString()], delete this.uidIndex_[e], this.dispatchEvent(new En(fn, t)) }, e.prototype.removeFromIdIndex_ = function (t) { var e = !1; for (var n in this.idIndex_) if (this.idIndex_[n] === t) { delete this.idIndex_[n], e = !0; break } return e }, e.prototype.setLoader = function (t) { this.loader_ = t }, e.prototype.setUrl = function (t) { St(this.format_, 7), this.setLoader(vn(t, this.format_)) }, e }(ln); function Cn(t) { return (Cn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function wn(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function Sn(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? wn(Object(n), !0).forEach((function (e) { bn(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : wn(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function bn(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function On(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function Tn(t, e, n) { return (Tn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Mn(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function Rn(t, e) { return (Rn = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Nn(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Mn(t); if (e) { var r = Mn(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return Ln(this, n) } } function Ln(t, e) { return !e || "object" !== Cn(e) && "function" != typeof e ? Pn(t) : e } function Pn(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Mn(t) { return (Mn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Dn = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Rn(t, e) }(s, t); var e, n, i, r = Nn(s); function s(t) { var e; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s); var n = null; if (t.element || ((n = document.createElement("button")).className = "ole-control ".concat(t.className)), (e = r.call(this, { element: t.element || n })).dialogTarget = t.dialogTarget, e.properties = Sn({}, t), e.className = t.className, e.title = t.title, n) { var i = document.createElement("img"); i.src = t.image, n.appendChild(i), n.title = e.title, n.addEventListener("click", e.onClick.bind(Pn(e))) } return e.source = t.source || new In({ features: t.features }), e.layerFilter = t.layerFilter || function (t) { return !e.source || t && t.getSource() === e.source }, e.editor = null, e.standalone = !0, e } return e = s, (n = [{ key: "getElement", value: function () { return this.element } }, { key: "onClick", value: function () { this.active ? this.deactivate() : this.activate() } }, { key: "setMap", value: function (t) { this.map = t, Tn(Mn(s.prototype), "setMap", this).call(this, this.map) } }, { key: "setEditor", value: function (t) { this.editor = t } }, { key: "activate", value: function (t) { this.active = !0, this.element.className += " active", t || this.dispatchEvent({ type: "change:active", target: this, detail: { control: this } }), this.openDialog() } }, { key: "deactivate", value: function (t) { this.active = !1, this.element.classList.remove("active"), t || this.dispatchEvent({ type: "change:active", target: this, detail: { control: this } }), this.closeDialog() } }, { key: "getActive", value: function () { return this.active } }, { key: "openDialog", value: function () { this.closeDialog(), this.getDialogTemplate && (this.dialogDiv = document.createElement("div"), this.dialogDiv.innerHTML = '\n        <div class="ole-dialog">\n          '.concat(this.getDialogTemplate(), "\n        </div>\n      "), (this.dialogTarget || this.map.getTargetElement()).appendChild(this.dialogDiv)) } }, { key: "closeDialog", value: function () { this.dialogDiv && ((this.dialogTarget || this.map.getTargetElement()).removeChild(this.dialogDiv), this.dialogDiv = null) } }, { key: "setProperties", value: function (t, e) { this.properties = Sn(Sn({}, this.properties), t), e || this.dispatchEvent({ type: "propertychange", target: this, detail: { properties: this.properties, control: this } }) } }, { key: "getProperties", value: function () { return Sn({}, this.properties) } }]) && On(e.prototype, n), i && On(e, i), s }(ot), An = 0, Fn = 1, kn = 2, Gn = 3; function jn(t, e) { return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : (e[0] = t, e[1] = t), e) } var Bn = function () { function t(t) { this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = jn(t.scale), this.displacement_ = t.displacement } return t.prototype.clone = function () { var e = this.getScale(); return new t({ opacity: this.getOpacity(), scale: Array.isArray(e) ? e.slice() : e, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice() }) }, t.prototype.getOpacity = function () { return this.opacity_ }, t.prototype.getRotateWithView = function () { return this.rotateWithView_ }, t.prototype.getRotation = function () { return this.rotation_ }, t.prototype.getScale = function () { return this.scale_ }, t.prototype.getScaleArray = function () { return this.scaleArray_ }, t.prototype.getDisplacement = function () { return this.displacement_ }, t.prototype.getAnchor = function () { return o() }, t.prototype.getImage = function (t) { return o() }, t.prototype.getHitDetectionImage = function () { return o() }, t.prototype.getPixelRatio = function (t) { return 1 }, t.prototype.getImageState = function () { return o() }, t.prototype.getImageSize = function () { return o() }, t.prototype.getHitDetectionImageSize = function () { return o() }, t.prototype.getOrigin = function () { return o() }, t.prototype.getSize = function () { return o() }, t.prototype.setOpacity = function (t) { this.opacity_ = t }, t.prototype.setRotateWithView = function (t) { this.rotateWithView_ = t }, t.prototype.setRotation = function (t) { this.rotation_ = t }, t.prototype.setScale = function (t) { this.scale_ = t, this.scaleArray_ = jn(t) }, t.prototype.listenImageChange = function (t) { o() }, t.prototype.load = function () { o() }, t.prototype.unlistenImageChange = function (t) { o() }, t }(), Yn = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, qn = /^([a-z]*)$|^hsla?\(.*\)$/i; function Xn(t) { var e = document.createElement("div"); if (e.style.color = t, "" !== e.style.color) { document.body.appendChild(e); var n = getComputedStyle(e).color; return document.body.removeChild(e), n } return "" } var zn, Un, Vn = (zn = {}, Un = 0, function (t) { var e; if (zn.hasOwnProperty(t)) e = zn[t]; else { if (Un >= 1024) { var n = 0; for (var i in zn) 0 == (3 & n++) && (delete zn[i], --Un) } e = function (t) { var e, n, i, r, s; if (qn.exec(t) && (t = Xn(t)), Yn.exec(t)) { var o = t.length - 1, a = void 0; a = o <= 4 ? 1 : 2; var l = 4 === o || 8 === o; e = parseInt(t.substr(1 + 0 * a, a), 16), n = parseInt(t.substr(1 + 1 * a, a), 16), i = parseInt(t.substr(1 + 2 * a, a), 16), r = l ? parseInt(t.substr(1 + 3 * a, a), 16) : 255, 1 == a && (e = (e << 4) + e, n = (n << 4) + n, i = (i << 4) + i, l && (r = (r << 4) + r)), s = [e, n, i, r / 255] } else 0 == t.indexOf("rgba(") ? Hn(s = t.slice(5, -1).split(",").map(Number)) : 0 == t.indexOf("rgb(") ? ((s = t.slice(4, -1).split(",").map(Number)).push(1), Hn(s)) : St(!1, 14); return s }(t), zn[t] = e, ++Un } return e }); function Wn(t) { return Array.isArray(t) ? t : Vn(t) } function Hn(t) { return t[0] = re(t[0] + .5 | 0, 0, 255), t[1] = re(t[1] + .5 | 0, 0, 255), t[2] = re(t[2] + .5 | 0, 0, 255), t[3] = re(t[3], 0, 1), t } function Kn(t) { var e = t[0]; e != (0 | e) && (e = e + .5 | 0); var n = t[1]; n != (0 | n) && (n = n + .5 | 0); var i = t[2]; return i != (0 | i) && (i = i + .5 | 0), "rgba(" + e + "," + n + "," + i + "," + (void 0 === t[3] ? 1 : t[3]) + ")" } function Zn(t) { return Array.isArray(t) ? Kn(t) : t } var Jn = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", "?\\s*([-,\\\"\\'\\sa-z]+?)\\s*$"].join(""), "i"), Qn = ["style", "variant", "weight", "size", "lineHeight", "family"], $n = function (t) { var e = t.match(Jn); if (!e) return null; for (var n = { lineHeight: "normal", size: "1.2em", style: "normal", weight: "normal", variant: "normal" }, i = 0, r = Qn.length; i < r; ++i) { var s = e[i + 1]; void 0 !== s && (n[Qn[i]] = s) } return n.families = n.family.split(/,\s?/), n }; new Array(6); function ti(t, e, n, i, r, s, o) { return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t[4] = s, t[5] = o, t } function ei(t, e) { var n = e[0], i = e[1]; return e[0] = t[0] * n + t[2] * i + t[4], e[1] = t[1] * n + t[3] * i + t[5], e } function ni(t, e, n, i, r, s, o, a) { var l = Math.sin(s), h = Math.cos(s); return t[0] = i * h, t[1] = r * l, t[2] = -i * l, t[3] = r * h, t[4] = o * i * h - a * i * l + e, t[5] = o * r * l + a * r * h + n, t } function ii(t, e) { var n, i = (n = e)[0] * n[3] - n[1] * n[2]; St(0 !== i, 32); var r = e[0], s = e[1], o = e[2], a = e[3], l = e[4], h = e[5]; return t[0] = a / i, t[1] = -s / i, t[2] = -o / i, t[3] = r / i, t[4] = (o * h - a * l) / i, t[5] = -(r * h - s * l) / i, t } function ri(t) { return "matrix(" + t.join(", ") + ")" } var si = [], oi = [0, 0, 0, 0], ai = new V; (new T).setSize = function () { console.warn("labelCache is deprecated.") }; var li, hi, ci, ui = null, fi = {}, pi = function () { var t, e, n = ["monospace", "serif"], i = n.length, r = "wmytzilWMYTZIL@#/&?$%10"; function s(t, s, o) { for (var a = !0, l = 0; l < i; ++l) { var h = n[l]; if (e = _i(t + " " + s + " 32px " + h, r), o != h) { var c = _i(t + " " + s + " 32px " + o + "," + h, r); a = a && c != e } } return !!a } function o() { for (var e = !0, n = ai.getKeys(), i = 0, r = n.length; i < r; ++i) { var o = n[i]; ai.get(o) < 100 && (s.apply(this, o.split("\n")) ? (w(fi), ui = null, li = void 0, ai.set(o, 100)) : (ai.set(o, ai.get(o) + 1, !0), e = !1)) } e && (clearInterval(t), t = void 0) } return function (e) { var n = $n(e); if (n) for (var i = n.families, r = 0, a = i.length; r < a; ++r) { var l = i[r], h = n.style + "\n" + n.weight + "\n" + l; void 0 === ai.get(h) && (ai.set(h, 100, !0), s(n.style, n.weight, l) || (ai.set(h, 0, !0), void 0 === t && (t = setInterval(o, 32)))) } } }(), di = (ci = fi, function (t) { var e = ci[t]; if (null == e) if (et) { var n = $n(t), i = gi(t, "g"), r = isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight); fi[t] = r * (i.actualBoundingBoxAscent + i.actualBoundingBoxDescent) } else hi || ((hi = document.createElement("div")).innerHTML = "M", hi.style.margin = "0 !important", hi.style.padding = "0 !important", hi.style.position = "absolute !important", hi.style.left = "-99999px !important"), hi.style.font = t, document.body.appendChild(hi), e = hi.offsetHeight, ci[t] = e, document.body.removeChild(hi); return e }); function gi(t, e) { return ui || (ui = it(1, 1)), t != li && (ui.font = t, li = ui.font), ui.measureText(e) } function _i(t, e) { return gi(t, e).width } function yi(t, e, n) { if (e in n) return n[e]; var i = _i(t, e); return n[e] = i, i } function mi(t, e, n, i) { 0 !== e && (t.translate(n, i), t.rotate(e), t.translate(-n, -i)) } function vi(t, e, n, i, r, s, o, a, l, h, c) { t.save(), 1 !== n && (t.globalAlpha *= n), e && t.setTransform.apply(t, e), i.contextInstructions ? (t.translate(l, h), t.scale(c[0], c[1]), function (t, e) { for (var n = t.contextInstructions, i = 0, r = n.length; i < r; i += 2)Array.isArray(n[i + 1]) ? e[n[i]].apply(e, n[i + 1]) : e[n[i]] = n[i + 1] }(i, t)) : c[0] < 0 || c[1] < 0 ? (t.translate(l, h), t.scale(c[0], c[1]), t.drawImage(i, r, s, o, a, 0, 0, o, a)) : t.drawImage(i, r, s, o, a, l, h, o * c[0], a * c[1]), t.restore() } var xi = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Ei = function (t) { function e(e) { var n = this, i = void 0 !== e.rotateWithView && e.rotateWithView; return (n = t.call(this, { opacity: 1, rotateWithView: i, rotation: void 0 !== e.rotation ? e.rotation : 0, scale: 1, displacement: void 0 !== e.displacement ? e.displacement : [0, 0] }) || this).canvas_ = {}, n.hitDetectionCanvas_ = null, n.fill_ = void 0 !== e.fill ? e.fill : null, n.origin_ = [0, 0], n.points_ = e.points, n.radius_ = void 0 !== e.radius ? e.radius : e.radius1, n.radius2_ = e.radius2, n.angle_ = void 0 !== e.angle ? e.angle : 0, n.stroke_ = void 0 !== e.stroke ? e.stroke : null, n.anchor_ = null, n.size_ = null, n.imageSize_ = null, n.hitDetectionImageSize_ = null, n.render(), n } return xi(e, t), e.prototype.clone = function () { var t = new e({ fill: this.getFill() ? this.getFill().clone() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this.getRadius2(), angle: this.getAngle(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice() }); return t.setOpacity(this.getOpacity()), t.setScale(this.getScale()), t }, e.prototype.getAnchor = function () { return this.anchor_ }, e.prototype.getAngle = function () { return this.angle_ }, e.prototype.getFill = function () { return this.fill_ }, e.prototype.getHitDetectionImage = function () { if (!this.hitDetectionCanvas_) { var t = this.createRenderOptions(); this.createHitDetectionCanvas_(t) } return this.hitDetectionCanvas_ }, e.prototype.getImage = function (t) { if (!this.canvas_[t || 1]) { var e = this.createRenderOptions(), n = it(e.size * t || 1, e.size * t || 1); this.draw_(e, n, 0, 0, t || 1), this.canvas_[t || 1] = n.canvas } return this.canvas_[t || 1] }, e.prototype.getPixelRatio = function (t) { return t }, e.prototype.getImageSize = function () { return this.imageSize_ }, e.prototype.getHitDetectionImageSize = function () { return this.hitDetectionImageSize_ }, e.prototype.getImageState = function () { return kn }, e.prototype.getOrigin = function () { return this.origin_ }, e.prototype.getPoints = function () { return this.points_ }, e.prototype.getRadius = function () { return this.radius_ }, e.prototype.getRadius2 = function () { return this.radius2_ }, e.prototype.getSize = function () { return this.size_ }, e.prototype.getStroke = function () { return this.stroke_ }, e.prototype.listenImageChange = function (t) { }, e.prototype.load = function () { }, e.prototype.unlistenImageChange = function (t) { }, e.prototype.createRenderOptions = function () { var t, e = "round", n = "round", i = 0, r = null, s = 0, o = 0; return this.stroke_ && (null === (t = this.stroke_.getColor()) && (t = "#000"), t = Zn(t), void 0 === (o = this.stroke_.getWidth()) && (o = 1), r = this.stroke_.getLineDash(), s = this.stroke_.getLineDashOffset(), void 0 === (n = this.stroke_.getLineJoin()) && (n = "round"), void 0 === (e = this.stroke_.getLineCap()) && (e = "round"), void 0 === (i = this.stroke_.getMiterLimit()) && (i = 10)), { strokeStyle: t, strokeWidth: o, size: 2 * (this.radius_ + o) + 1, lineCap: e, lineDash: r, lineDashOffset: s, lineJoin: n, miterLimit: i } }, e.prototype.render = function () { var t = this.createRenderOptions(), e = it(t.size, t.size); this.draw_(t, e, 0, 0, 1), this.canvas_[1] = e.canvas; var n = e.canvas.width, i = n, r = this.getDisplacement(); this.hitDetectionImageSize_ = [t.size, t.size], this.createHitDetectionCanvas_(t), this.anchor_ = [n / 2 - r[0], n / 2 + r[1]], this.size_ = [n, n], this.imageSize_ = [i, i] }, e.prototype.draw_ = function (t, e, n, i, r) { var s, o, a; e.setTransform(r, 0, 0, r, 0, 0), e.translate(n, i), e.beginPath(); var l = this.points_; if (l === 1 / 0) e.arc(t.size / 2, t.size / 2, this.radius_, 0, 2 * Math.PI, !0); else { var h = void 0 !== this.radius2_ ? this.radius2_ : this.radius_; for (h !== this.radius_ && (l *= 2), s = 0; s <= l; s++)o = 2 * s * Math.PI / l - Math.PI / 2 + this.angle_, a = s % 2 == 0 ? this.radius_ : h, e.lineTo(t.size / 2 + a * Math.cos(o), t.size / 2 + a * Math.sin(o)) } if (this.fill_) { var c = this.fill_.getColor(); null === c && (c = "#000"), e.fillStyle = Zn(c), e.fill() } this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, e.setLineDash && t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke()), e.closePath() }, e.prototype.createHitDetectionCanvas_ = function (t) { if (this.hitDetectionCanvas_ = this.getImage(1), this.fill_) { var e = this.fill_.getColor(), n = 0; if ("string" == typeof e && (e = Wn(e)), null === e ? n = 1 : Array.isArray(e) && (n = 4 === e.length ? e[3] : 1), 0 === n) { var i = it(t.size, t.size); this.hitDetectionCanvas_ = i.canvas, this.drawHitDetectionCanvas_(t, i, 0, 0) } } }, e.prototype.drawHitDetectionCanvas_ = function (t, e, n, i) { e.translate(n, i), e.beginPath(); var r = this.points_; if (r === 1 / 0) e.arc(t.size / 2, t.size / 2, this.radius_, 0, 2 * Math.PI, !0); else { var s = void 0 !== this.radius2_ ? this.radius2_ : this.radius_; s !== this.radius_ && (r *= 2); var o = void 0, a = void 0, l = void 0; for (o = 0; o <= r; o++)l = 2 * o * Math.PI / r - Math.PI / 2 + this.angle_, a = o % 2 == 0 ? this.radius_ : s, e.lineTo(t.size / 2 + a * Math.cos(l), t.size / 2 + a * Math.sin(l)) } e.fillStyle = "#000", e.fill(), this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.stroke()), e.closePath() }, e }(Bn), Ii = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Ci = function (t) { function e(e) { var n = e || {}; return t.call(this, { points: 1 / 0, fill: n.fill, radius: n.radius, stroke: n.stroke, displacement: void 0 !== n.displacement ? n.displacement : [0, 0] }) || this } return Ii(e, t), e.prototype.clone = function () { var t = new e({ fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, radius: this.getRadius(), displacement: this.getDisplacement().slice() }); return t.setOpacity(this.getOpacity()), t.setScale(this.getScale()), t }, e.prototype.setRadius = function (t) { this.radius_ = t, this.render() }, e }(Ei), wi = function () { function t(t) { var e = t || {}; this.color_ = void 0 !== e.color ? e.color : null } return t.prototype.clone = function () { var e = this.getColor(); return new t({ color: Array.isArray(e) ? e.slice() : e || void 0 }) }, t.prototype.getColor = function () { return this.color_ }, t.prototype.setColor = function (t) { this.color_ = t }, t }(), Si = function () { function t(t) { var e = t || {}; this.color_ = void 0 !== e.color ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = void 0 !== e.lineDash ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width } return t.prototype.clone = function () { var e = this.getColor(); return new t({ color: Array.isArray(e) ? e.slice() : e || void 0, lineCap: this.getLineCap(), lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this.getLineJoin(), miterLimit: this.getMiterLimit(), width: this.getWidth() }) }, t.prototype.getColor = function () { return this.color_ }, t.prototype.getLineCap = function () { return this.lineCap_ }, t.prototype.getLineDash = function () { return this.lineDash_ }, t.prototype.getLineDashOffset = function () { return this.lineDashOffset_ }, t.prototype.getLineJoin = function () { return this.lineJoin_ }, t.prototype.getMiterLimit = function () { return this.miterLimit_ }, t.prototype.getWidth = function () { return this.width_ }, t.prototype.setColor = function (t) { this.color_ = t }, t.prototype.setLineCap = function (t) { this.lineCap_ = t }, t.prototype.setLineDash = function (t) { this.lineDash_ = t }, t.prototype.setLineDashOffset = function (t) { this.lineDashOffset_ = t }, t.prototype.setLineJoin = function (t) { this.lineJoin_ = t }, t.prototype.setMiterLimit = function (t) { this.miterLimit_ = t }, t.prototype.setWidth = function (t) { this.width_ = t }, t }(), bi = function () { function t(t) { var e = t || {}; this.geometry_ = null, this.geometryFunction_ = Ni, void 0 !== e.geometry && this.setGeometry(e.geometry), this.fill_ = void 0 !== e.fill ? e.fill : null, this.image_ = void 0 !== e.image ? e.image : null, this.renderer_ = void 0 !== e.renderer ? e.renderer : null, this.stroke_ = void 0 !== e.stroke ? e.stroke : null, this.text_ = void 0 !== e.text ? e.text : null, this.zIndex_ = e.zIndex } return t.prototype.clone = function () { var e = this.getGeometry(); return e && "object" == typeof e && (e = e.clone()), new t({ geometry: e, fill: this.getFill() ? this.getFill().clone() : void 0, image: this.getImage() ? this.getImage().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex() }) }, t.prototype.getRenderer = function () { return this.renderer_ }, t.prototype.setRenderer = function (t) { this.renderer_ = t }, t.prototype.getGeometry = function () { return this.geometry_ }, t.prototype.getGeometryFunction = function () { return this.geometryFunction_ }, t.prototype.getFill = function () { return this.fill_ }, t.prototype.setFill = function (t) { this.fill_ = t }, t.prototype.getImage = function () { return this.image_ }, t.prototype.setImage = function (t) { this.image_ = t }, t.prototype.getStroke = function () { return this.stroke_ }, t.prototype.setStroke = function (t) { this.stroke_ = t }, t.prototype.getText = function () { return this.text_ }, t.prototype.setText = function (t) { this.text_ = t }, t.prototype.getZIndex = function () { return this.zIndex_ }, t.prototype.setGeometry = function (t) { "function" == typeof t ? this.geometryFunction_ = t : "string" == typeof t ? this.geometryFunction_ = function (e) { return e.get(t) } : t ? void 0 !== t && (this.geometryFunction_ = function () { return t }) : this.geometryFunction_ = Ni, this.geometry_ = t }, t.prototype.setZIndex = function (t) { this.zIndex_ = t }, t }(); var Oi = null; function Ti(t, e) { if (!Oi) { var n = new wi({ color: "rgba(255,255,255,0.4)" }), i = new Si({ color: "#3399CC", width: 1.25 }); Oi = [new bi({ image: new Ci({ fill: n, stroke: i, radius: 5 }), fill: n, stroke: i })] } return Oi } function Ri() { var t = {}, e = [255, 255, 255, 1], n = [0, 153, 255, 1]; return t[Re] = [new bi({ fill: new wi({ color: [255, 255, 255, .5] }) })], t[Pe] = t[Re], t[Oe] = [new bi({ stroke: new Si({ color: e, width: 5 }) }), new bi({ stroke: new Si({ color: n, width: 3 }) })], t[Le] = t[Oe], t[De] = t[Re].concat(t[Oe]), t[be] = [new bi({ image: new Ci({ radius: 6, fill: new wi({ color: n }), stroke: new Si({ color: e, width: 1.5 }) }), zIndex: 1 / 0 })], t[Ne] = t[be], t[Me] = t[Re].concat(t[Oe], t[be]), t } function Ni(t) { return t.getGeometry() } var Li = bi; function Pi(t, e, n, i, r, s) { for (var o = s || [], a = 0, l = e; l < n; l += i) { var h = t[l], c = t[l + 1]; o[a++] = r[0] * h + r[2] * c + r[4], o[a++] = r[1] * h + r[3] * c + r[5] } return s && o.length != a && (o.length = a), o } function Mi(t, e, n, i, r, s, o) { for (var a = o || [], l = Math.cos(r), h = Math.sin(r), c = s[0], u = s[1], f = 0, p = e; p < n; p += i) { var d = t[p] - c, g = t[p + 1] - u; a[f++] = c + d * l - g * h, a[f++] = u + d * h + g * l; for (var _ = p + 2; _ < p + i; ++_)a[f++] = t[_] } return o && a.length != f && (a.length = f), a } function Di(t, e, n, i, r, s, o) { for (var a = o || [], l = 0, h = e; h < n; h += i) { a[l++] = t[h] + r, a[l++] = t[h + 1] + s; for (var c = h + 2; c < h + i; ++c)a[l++] = t[c] } return o && a.length != l && (a.length = l), a } var Ai = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Fi = [1, 0, 0, 1, 0, 0], ki = function (t) { function e() { var e, n, i, r, s, o = t.call(this) || this; return o.extent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o.extentRevision_ = -1, o.simplifiedGeometryMaxMinSquaredTolerance = 0, o.simplifiedGeometryRevision = 0, o.simplifyTransformedInternal = (e = function (t, e, n) { if (!n) return this.getSimplifiedGeometry(e); var i = this.clone(); return i.applyTransform(n), i.getSimplifiedGeometry(e) }, s = !1, function () { var t = Array.prototype.slice.call(arguments); return s && this === r && v(t, i) || (s = !0, r = this, i = t, n = e.apply(this, arguments)), n }), o } return Ai(e, t), e.prototype.simplifyTransformed = function (t, e) { return this.simplifyTransformedInternal(this.getRevision(), t, e) }, e.prototype.clone = function () { return o() }, e.prototype.closestPointXY = function (t, e, n, i) { return o() }, e.prototype.containsXY = function (t, e) { var n = this.getClosestPoint([t, e]); return n[0] === t && n[1] === e }, e.prototype.getClosestPoint = function (t, e) { var n = e || [NaN, NaN]; return this.closestPointXY(t[0], t[1], n, 1 / 0), n }, e.prototype.intersectsCoordinate = function (t) { return this.containsXY(t[0], t[1]) }, e.prototype.computeExtent = function (t) { return o() }, e.prototype.getExtent = function (t) { if (this.extentRevision_ != this.getRevision()) { var e = this.computeExtent(this.extent_); (isNaN(e[0]) || isNaN(e[1])) && Dt(e), this.extentRevision_ = this.getRevision() } return function (t, e) { return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t }(this.extent_, t) }, e.prototype.rotate = function (t, e) { o() }, e.prototype.scale = function (t, e, n) { o() }, e.prototype.simplify = function (t) { return this.getSimplifiedGeometry(t * t) }, e.prototype.getSimplifiedGeometry = function (t) { return o() }, e.prototype.getType = function () { return o() }, e.prototype.applyTransform = function (t) { o() }, e.prototype.intersectsExtent = function (t) { return o() }, e.prototype.translate = function (t, e) { o() }, e.prototype.transform = function (t, e) { var n = ze(t), i = n.getUnits() == ne.TILE_PIXELS ? function (t, i, r) { var s = n.getExtent(), o = n.getWorldExtent(), a = Ut(o) / Ut(s); return ni(Fi, o[0], o[3], a, -a, 0, 0, 0), Pi(t, 0, t.length, r, Fi, i), We(n, e)(t, i, r) } : We(n, e); return this.applyTransform(i), this }, e }(V), Gi = "XY", ji = "XYZ", Bi = "XYM", Yi = "XYZM", qi = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); function Xi(t) { var e; return t == Gi ? e = 2 : t == ji || t == Bi ? e = 3 : t == Yi && (e = 4), e } var zi = function (t) { function e() { var e = t.call(this) || this; return e.layout = Gi, e.stride = 2, e.flatCoordinates = null, e } return qi(e, t), e.prototype.computeExtent = function (t) { return Ft(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t) }, e.prototype.getCoordinates = function () { return o() }, e.prototype.getFirstCoordinate = function () { return this.flatCoordinates.slice(0, this.stride) }, e.prototype.getFlatCoordinates = function () { return this.flatCoordinates }, e.prototype.getLastCoordinate = function () { return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride) }, e.prototype.getLayout = function () { return this.layout }, e.prototype.getSimplifiedGeometry = function (t) { if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t <= this.simplifiedGeometryMaxMinSquaredTolerance) return this; var e = this.getSimplifiedGeometryInternal(t); return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this) }, e.prototype.getSimplifiedGeometryInternal = function (t) { return this }, e.prototype.getStride = function () { return this.stride }, e.prototype.setFlatCoordinates = function (t, e) { this.stride = Xi(t), this.layout = t, this.flatCoordinates = e }, e.prototype.setCoordinates = function (t, e) { o() }, e.prototype.setLayout = function (t, e, n) { var i; if (t) i = Xi(t); else { for (var r = 0; r < n; ++r) { if (0 === e.length) return this.layout = Gi, void (this.stride = 2); e = e[0] } t = function (t) { var e; 2 == t ? e = Gi : 3 == t ? e = ji : 4 == t && (e = Yi); return e }(i = e.length) } this.layout = t, this.stride = i }, e.prototype.applyTransform = function (t) { this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed()) }, e.prototype.rotate = function (t, e) { var n = this.getFlatCoordinates(); if (n) { var i = this.getStride(); Mi(n, 0, n.length, i, t, e, n), this.changed() } }, e.prototype.scale = function (t, e, n) { var i = e; void 0 === i && (i = t); var r = n; r || (r = zt(this.getExtent())); var s = this.getFlatCoordinates(); if (s) { var o = this.getStride(); !function (t, e, n, i, r, s, o, a) { for (var l = a || [], h = o[0], c = o[1], u = 0, f = e; f < n; f += i) { var p = t[f] - h, d = t[f + 1] - c; l[u++] = h + r * p, l[u++] = c + s * d; for (var g = f + 2; g < f + i; ++g)l[u++] = t[g] } a && l.length != u && (l.length = u) }(s, 0, s.length, o, t, i, r, s), this.changed() } }, e.prototype.translate = function (t, e) { var n = this.getFlatCoordinates(); if (n) { var i = this.getStride(); Di(n, 0, n.length, i, t, e, n), this.changed() } }, e }(ki); function Ui(t, e, n, i) { for (var r = 0, s = n.length; r < s; ++r)t[e++] = n[r]; return e } function Vi(t, e, n, i) { for (var r = 0, s = n.length; r < s; ++r)for (var o = n[r], a = 0; a < i; ++a)t[e++] = o[a]; return e } function Wi(t, e, n, i, r) { for (var s = r || [], o = 0, a = 0, l = n.length; a < l; ++a) { var h = Vi(t, e, n[a], i); s[o++] = h, e = h } return s.length = o, s } var Hi = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Ki = function (t) { function e(e, n) { var i = t.call(this) || this; return i.setCoordinates(e, n), i } return Hi(e, t), e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout) }, e.prototype.closestPointXY = function (t, e, n, i) { var r = this.flatCoordinates, s = ae(t, e, r[0], r[1]); if (s < i) { for (var o = this.stride, a = 0; a < o; ++a)n[a] = r[a]; return n.length = o, s } return i }, e.prototype.getCoordinates = function () { return this.flatCoordinates ? this.flatCoordinates.slice() : [] }, e.prototype.computeExtent = function (t) { return At(this.flatCoordinates, t) }, e.prototype.getType = function () { return be }, e.prototype.intersectsExtent = function (t) { return Nt(t, this.flatCoordinates[0], this.flatCoordinates[1]) }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ui(this.flatCoordinates, 0, t, this.stride), this.changed() }, e }(zi); function Zi(t, e, n, i, r, s, o) { var a, l = t[e], h = t[e + 1], c = t[n] - l, u = t[n + 1] - h; if (0 === c && 0 === u) a = e; else { var f = ((r - l) * c + (s - h) * u) / (c * c + u * u); if (f > 1) a = n; else { if (f > 0) { for (var p = 0; p < i; ++p)o[p] = he(t[e + p], t[n + p], f); return void (o.length = i) } a = e } } for (p = 0; p < i; ++p)o[p] = t[a + p]; o.length = i } function Ji(t, e, n, i, r) { var s = t[e], o = t[e + 1]; for (e += i; e < n; e += i) { var a = t[e], l = t[e + 1], h = ae(s, o, a, l); h > r && (r = h), s = a, o = l } return r } function Qi(t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s) { var a = n[s]; r = Ji(t, e, a, i, r), e = a } return r } function $i(t, e, n, i, r, s, o, a, l, h, c) { if (e == n) return h; var u, f; if (0 === r) { if ((f = ae(o, a, t[e], t[e + 1])) < h) { for (u = 0; u < i; ++u)l[u] = t[e + u]; return l.length = i, f } return h } for (var p = c || [NaN, NaN], d = e + i; d < n;)if (Zi(t, d - i, d, i, o, a, p), (f = ae(o, a, p[0], p[1])) < h) { for (h = f, u = 0; u < i; ++u)l[u] = p[u]; l.length = i, d += i } else d += i * Math.max((Math.sqrt(f) - Math.sqrt(h)) / r | 0, 1); if (s && (Zi(t, n - i, e, i, o, a, p), (f = ae(o, a, p[0], p[1])) < h)) { for (h = f, u = 0; u < i; ++u)l[u] = p[u]; l.length = i } return h } function tr(t, e, n, i, r, s, o, a, l, h, c) { for (var u = c || [NaN, NaN], f = 0, p = n.length; f < p; ++f) { var d = n[f]; h = $i(t, e, d, i, r, s, o, a, l, h, u), e = d } return h } function er(t, e, n, i, r, s, o) { var a = (n - e) / i; if (a < 3) { for (; e < n; e += i)s[o++] = t[e], s[o++] = t[e + 1]; return o } var l = new Array(a); l[0] = 1, l[a - 1] = 1; for (var h = [e, n - i], c = 0; h.length > 0;) { for (var u = h.pop(), f = h.pop(), p = 0, d = t[f], g = t[f + 1], _ = t[u], y = t[u + 1], m = f + i; m < u; m += i) { var v = oe(t[m], t[m + 1], d, g, _, y); v > p && (c = m, p = v) } p > r && (l[(c - e) / i] = 1, f + i < c && h.push(f, c), c + i < u && h.push(c, u)) } for (m = 0; m < a; ++m)l[m] && (s[o++] = t[e + m * i], s[o++] = t[e + m * i + 1]); return o } function nr(t, e, n, i, r, s, o, a) { for (var l = 0, h = n.length; l < h; ++l) { var c = n[l]; o = er(t, e, c, i, r, s, o), a.push(o), e = c } return o } function ir(t, e) { return e * Math.round(t / e) } function rr(t, e, n, i, r, s, o) { if (e == n) return o; var a, l, h = ir(t[e], r), c = ir(t[e + 1], r); e += i, s[o++] = h, s[o++] = c; do { if (a = ir(t[e], r), l = ir(t[e + 1], r), (e += i) == n) return s[o++] = a, s[o++] = l, o } while (a == h && l == c); for (; e < n;) { var u = ir(t[e], r), f = ir(t[e + 1], r); if (e += i, u != a || f != l) { var p = a - h, d = l - c, g = u - h, _ = f - c; p * _ == d * g && (p < 0 && g < p || p == g || p > 0 && g > p) && (d < 0 && _ < d || d == _ || d > 0 && _ > d) ? (a = u, l = f) : (s[o++] = a, s[o++] = l, h = a, c = l, a = u, l = f) } } return s[o++] = a, s[o++] = l, o } function sr(t, e, n, i, r, s, o, a) { for (var l = 0, h = n.length; l < h; ++l) { var c = n[l]; o = rr(t, e, c, i, r, s, o), a.push(o), e = c } return o } function or(t, e, n, i, r) { for (var s, o = [t[e], t[e + 1]], a = []; e + i < n; e += i) { if (a[0] = t[e + i], a[1] = t[e + i + 1], s = r(o, a)) return s; o[0] = a[0], o[1] = a[1] } return !1 } function ar(t, e, n, i, r) { for (var s = void 0 !== r ? r : [], o = 0, a = e; a < n; a += i)s[o++] = t.slice(a, a + i); return s.length = o, s } function lr(t, e, n, i, r) { for (var s = void 0 !== r ? r : [], o = 0, a = 0, l = n.length; a < l; ++a) { var h = n[a]; s[o++] = ar(t, e, h, i, s[o]), e = h } return s.length = o, s } function hr(t, e, n, i, r) { for (var s = void 0 !== r ? r : [], o = 0, a = 0, l = n.length; a < l; ++a) { var h = n[a]; s[o++] = lr(t, e, h, i, s[o]), e = h[h.length - 1] } return s.length = o, s } function cr(t, e, n, i, r, s, o) { var a, l, h = (n - e) / i; if (1 === h) a = e; else if (2 === h) a = e, l = r; else if (0 !== h) { for (var c = t[e], u = t[e + 1], f = 0, p = [0], d = e + i; d < n; d += i) { var _ = t[d], y = t[d + 1]; f += Math.sqrt((_ - c) * (_ - c) + (y - u) * (y - u)), p.push(f), c = _, u = y } var m = r * f, v = function (t, e, n) { for (var i, r, s = n || g, o = 0, a = t.length, l = !1; o < a;)(r = +s(t[i = o + (a - o >> 1)], e)) < 0 ? o = i + 1 : (a = i, l = !r); return l ? o : ~o }(p, m); v < 0 ? (l = (m - p[-v - 2]) / (p[-v - 1] - p[-v - 2]), a = e + (-v - 2) * i) : a = e + v * i } var x = o > 1 ? o : 2, E = s || new Array(x); for (d = 0; d < x; ++d)E[d] = void 0 === a ? NaN : void 0 === l ? t[a + d] : he(t[a + d], t[a + i + d], l); return E } function ur(t, e, n, i, r, s) { if (n == e) return null; var o; if (r < t[e + i - 1]) return s ? ((o = t.slice(e, e + i))[i - 1] = r, o) : null; if (t[n - 1] < r) return s ? ((o = t.slice(n - i, n))[i - 1] = r, o) : null; if (r == t[e + i - 1]) return t.slice(e, e + i); for (var a = e / i, l = n / i; a < l;) { var h = a + l >> 1; r < t[(h + 1) * i - 1] ? l = h : a = h + 1 } var c = t[a * i - 1]; if (r == c) return t.slice((a - 1) * i, (a - 1) * i + i); var u = (r - c) / (t[(a + 1) * i - 1] - c); o = []; for (var f = 0; f < i - 1; ++f)o.push(he(t[(a - 1) * i + f], t[a * i + f], u)); return o.push(r), o } function fr(t, e, n, i, r) { return !Yt(r, (function (r) { return !pr(t, e, n, i, r[0], r[1]) })) } function pr(t, e, n, i, r, s) { for (var o = 0, a = t[n - i], l = t[n - i + 1]; e < n; e += i) { var h = t[e], c = t[e + 1]; l <= s ? c > s && (h - a) * (s - l) - (r - a) * (c - l) > 0 && o++ : c <= s && (h - a) * (s - l) - (r - a) * (c - l) < 0 && o--, a = h, l = c } return 0 !== o } function dr(t, e, n, i, r, s) { if (0 === n.length) return !1; if (!pr(t, e, n[0], i, r, s)) return !1; for (var o = 1, a = n.length; o < a; ++o)if (pr(t, n[o - 1], n[o], i, r, s)) return !1; return !0 } function gr(t, e, n, i, r) { var s = jt([1 / 0, 1 / 0, -1 / 0, -1 / 0], t, e, n, i); return !!Kt(r, s) && (!!Rt(r, s) || (s[0] >= r[0] && s[2] <= r[2] || (s[1] >= r[1] && s[3] <= r[3] || or(t, e, n, i, (function (t, e) { return function (t, e, n) { var i = !1, r = Lt(t, e), s = Lt(t, n); if (r === xt || s === xt) i = !0; else { var o = t[0], a = t[1], l = t[2], h = t[3], c = e[0], u = e[1], f = n[0], p = n[1], d = (p - u) / (f - c), g = void 0, _ = void 0; s & Et && !(r & Et) && (i = (g = f - (p - h) / d) >= o && g <= l), i || !(s & It) || r & It || (i = (_ = p - (f - l) * d) >= a && _ <= h), i || !(s & Ct) || r & Ct || (i = (g = f - (p - a) / d) >= o && g <= l), i || !(s & wt) || r & wt || (i = (_ = p - (f - o) * d) >= a && _ <= h) } return i }(r, t, e) }))))) } function _r(t, e, n, i, r) { if (!function (t, e, n, i, r) { return !!gr(t, e, n, i, r) || (!!pr(t, e, n, i, r[0], r[1]) || (!!pr(t, e, n, i, r[0], r[3]) || (!!pr(t, e, n, i, r[2], r[1]) || !!pr(t, e, n, i, r[2], r[3])))) }(t, e, n[0], i, r)) return !1; if (1 === n.length) return !0; for (var s = 1, o = n.length; s < o; ++s)if (fr(t, n[s - 1], n[s], i, r) && !gr(t, n[s - 1], n[s], i, r)) return !1; return !0 } function yr(t, e, n, i) { for (var r = t[e], s = t[e + 1], o = 0, a = e + i; a < n; a += i) { var l = t[a], h = t[a + 1]; o += Math.sqrt((l - r) * (l - r) + (h - s) * (h - s)), r = l, s = h } return o } var mr = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), vr = function (t) { function e(e, n) { var i = t.call(this) || this; return i.flatMidpoint_ = null, i.flatMidpointRevision_ = -1, i.maxDelta_ = -1, i.maxDeltaRevision_ = -1, void 0 === n || Array.isArray(e[0]) ? i.setCoordinates(e, n) : i.setFlatCoordinates(n, e), i } return mr(e, t), e.prototype.appendCoordinate = function (t) { this.flatCoordinates ? m(this.flatCoordinates, t) : this.flatCoordinates = t.slice(), this.changed() }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout) }, e.prototype.closestPointXY = function (t, e, n, i) { return i < Tt(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Ji(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), $i(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, n, i)) }, e.prototype.forEachSegment = function (t) { return or(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t) }, e.prototype.getCoordinateAtM = function (t, e) { if (this.layout != Bi && this.layout != Yi) return null; var n = void 0 !== e && e; return ur(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n) }, e.prototype.getCoordinates = function () { return ar(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) }, e.prototype.getCoordinateAt = function (t, e) { return cr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride) }, e.prototype.getLength = function () { return yr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) }, e.prototype.getFlatMidpoint = function () { return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_ }, e.prototype.getSimplifiedGeometryInternal = function (t) { var n = []; return n.length = er(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n, 0), new e(n, Gi) }, e.prototype.getType = function () { return Oe }, e.prototype.intersectsExtent = function (t) { return gr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t) }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Vi(this.flatCoordinates, 0, t, this.stride), this.changed() }, e }(zi); function xr(t, e, n, i) { for (var r = 0, s = t[n - i], o = t[n - i + 1]; e < n; e += i) { var a = t[e], l = t[e + 1]; r += o * a - s * l, s = a, o = l } return r / 2 } function Er(t, e, n, i) { for (var r = 0, s = 0, o = n.length; s < o; ++s) { var a = n[s]; r += xr(t, e, a, i), e = a } return r } var Ir = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Cr = function (t) { function e(e, n) { var i = t.call(this) || this; return i.maxDelta_ = -1, i.maxDeltaRevision_ = -1, void 0 === n || Array.isArray(e[0]) ? i.setCoordinates(e, n) : i.setFlatCoordinates(n, e), i } return Ir(e, t), e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout) }, e.prototype.closestPointXY = function (t, e, n, i) { return i < Tt(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Ji(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), $i(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, n, i)) }, e.prototype.getArea = function () { return xr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) }, e.prototype.getCoordinates = function () { return ar(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) }, e.prototype.getSimplifiedGeometryInternal = function (t) { var n = []; return n.length = er(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n, 0), new e(n, Gi) }, e.prototype.getType = function () { return Te }, e.prototype.intersectsExtent = function (t) { return !1 }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Vi(this.flatCoordinates, 0, t, this.stride), this.changed() }, e }(zi); function wr(t, e, n, i, r, s, o) { for (var a, l, h, c, u, f, p, d = r[s + 1], _ = [], y = 0, m = n.length; y < m; ++y) { var v = n[y]; for (c = t[v - i], f = t[v - i + 1], a = e; a < v; a += i)u = t[a], p = t[a + 1], (d <= f && p <= d || f <= d && d <= p) && (h = (d - f) / (p - f) * (u - c) + c, _.push(h)), c = u, f = p } var x = NaN, E = -1 / 0; for (_.sort(g), c = _[0], a = 1, l = _.length; a < l; ++a) { u = _[a]; var I = Math.abs(u - c); I > E && dr(t, e, n, i, h = (c + u) / 2, d) && (x = h, E = I), c = u } return isNaN(x) && (x = r[s]), o ? (o.push(x, d, E), o) : [x, d, E] } function Sr(t, e, n, i) { for (; e < n - i;) { for (var r = 0; r < i; ++r) { var s = t[e + r]; t[e + r] = t[n - i + r], t[n - i + r] = s } e += i, n -= i } } function br(t, e, n, i) { for (var r = !0, s = 0; s < i; ++s)if (t[e + s] !== t[n - i + s]) { r = !1; break } r && (n -= i); var o = function (t, e, n, i) { for (var r = -1, s = 1 / 0, o = 1 / 0, a = e; a < n; a += i) { var l = t[a], h = t[a + 1]; h > s || (h == s && l >= o || (r = a, s = h, o = l)) } return r }(t, e, n, i), a = o - i; a < e && (a = n - i); var l = o + i; l >= n && (l = e); var h = t[a], c = t[a + 1], u = t[o], f = t[o + 1], p = t[l], d = t[l + 1]; return u * d + h * f + c * p - (c * u + f * p + h * d) < 0 } function Or(t, e, n, i, r) { for (var s = void 0 !== r && r, o = 0, a = n.length; o < a; ++o) { var l = n[o], h = br(t, e, l, i); if (0 === o) { if (s && h || !s && !h) return !1 } else if (s && !h || !s && h) return !1; e = l } return !0 } function Tr(t, e, n, i, r) { for (var s = void 0 !== r && r, o = 0, a = n.length; o < a; ++o) { var l = n[o], h = br(t, e, l, i); (0 === o ? s && h || !s && !h : s && !h || !s && h) && Sr(t, e, l, i), e = l } return e } function Rr(t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s)e = Tr(t, e, n[s], i, r); return e } var Nr = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Lr = function (t) { function e(e, n, i) { var r = t.call(this) || this; return r.ends_ = [], r.flatInteriorPointRevision_ = -1, r.flatInteriorPoint_ = null, r.maxDelta_ = -1, r.maxDeltaRevision_ = -1, r.orientedRevision_ = -1, r.orientedFlatCoordinates_ = null, void 0 !== n && i ? (r.setFlatCoordinates(n, e), r.ends_ = i) : r.setCoordinates(e, n), r } return Nr(e, t), e.prototype.appendLinearRing = function (t) { this.flatCoordinates ? m(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed() }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice()) }, e.prototype.closestPointXY = function (t, e, n, i) { return i < Tt(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Qi(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), tr(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, n, i)) }, e.prototype.containsXY = function (t, e) { return dr(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e) }, e.prototype.getArea = function () { return Er(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride) }, e.prototype.getCoordinates = function (t) { var e; return void 0 !== t ? Tr(e = this.getOrientedFlatCoordinates().slice(), 0, this.ends_, this.stride, t) : e = this.flatCoordinates, lr(e, 0, this.ends_, this.stride) }, e.prototype.getEnds = function () { return this.ends_ }, e.prototype.getFlatInteriorPoint = function () { if (this.flatInteriorPointRevision_ != this.getRevision()) { var t = zt(this.getExtent()); this.flatInteriorPoint_ = wr(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0), this.flatInteriorPointRevision_ = this.getRevision() } return this.flatInteriorPoint_ }, e.prototype.getInteriorPoint = function () { return new Ki(this.getFlatInteriorPoint(), Bi) }, e.prototype.getLinearRingCount = function () { return this.ends_.length }, e.prototype.getLinearRing = function (t) { return t < 0 || this.ends_.length <= t ? null : new Cr(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout) }, e.prototype.getLinearRings = function () { for (var t = this.layout, e = this.flatCoordinates, n = this.ends_, i = [], r = 0, s = 0, o = n.length; s < o; ++s) { var a = n[s], l = new Cr(e.slice(r, a), t); i.push(l), r = a } return i }, e.prototype.getOrientedFlatCoordinates = function () { if (this.orientedRevision_ != this.getRevision()) { var t = this.flatCoordinates; Or(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Tr(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision() } return this.orientedFlatCoordinates_ }, e.prototype.getSimplifiedGeometryInternal = function (t) { var n = [], i = []; return n.length = sr(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), n, 0, i), new e(n, Gi, i) }, e.prototype.getType = function () { return Re }, e.prototype.intersectsExtent = function (t) { return _r(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t) }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []); var n = Wi(this.flatCoordinates, 0, t, this.stride, this.ends_); this.flatCoordinates.length = 0 === n.length ? 0 : n[n.length - 1], this.changed() }, e }(zi), Pr = Lr; function Mr(t, e, n) { for (var i = e || 32, r = t.getStride(), s = t.getLayout(), o = t.getCenter(), a = r * (i + 1), l = new Array(a), h = 0; h < a; h += r) { l[h] = 0, l[h + 1] = 0; for (var c = 2; c < r; c++)l[h + c] = o[c] } var u = [l.length], f = new Lr(l, s, u); return Dr(f, o, t.getRadius(), n), f } function Dr(t, e, n, i) { for (var r = t.getFlatCoordinates(), s = t.getStride(), o = r.length / s - 1, a = i || 0, l = 0; l <= o; ++l) { var h = l * s, c = a + 2 * le(l, o) * Math.PI / o; r[h] = e[0] + n * Math.cos(c), r[h + 1] = e[1] + n * Math.sin(c) } t.changed() } var Ar = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Fr = function (t) { function e(e, n) { var i = t.call(this) || this; return n && !Array.isArray(e[0]) ? i.setFlatCoordinates(n, e) : i.setCoordinates(e, n), i } return Ar(e, t), e.prototype.appendPoint = function (t) { this.flatCoordinates ? m(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.changed() }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout) }, e.prototype.closestPointXY = function (t, e, n, i) { if (i < Tt(this.getExtent(), t, e)) return i; for (var r = this.flatCoordinates, s = this.stride, o = 0, a = r.length; o < a; o += s) { var l = ae(t, e, r[o], r[o + 1]); if (l < i) { i = l; for (var h = 0; h < s; ++h)n[h] = r[o + h]; n.length = s } } return i }, e.prototype.getCoordinates = function () { return ar(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) }, e.prototype.getPoint = function (t) { var e = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0; return t < 0 || e <= t ? null : new Ki(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout) }, e.prototype.getPoints = function () { for (var t = this.flatCoordinates, e = this.layout, n = this.stride, i = [], r = 0, s = t.length; r < s; r += n) { var o = new Ki(t.slice(r, r + n), e); i.push(o) } return i }, e.prototype.getType = function () { return Ne }, e.prototype.intersectsExtent = function (t) { for (var e = this.flatCoordinates, n = this.stride, i = 0, r = e.length; i < r; i += n) { if (Nt(t, e[i], e[i + 1])) return !0 } return !1 }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Vi(this.flatCoordinates, 0, t, this.stride), this.changed() }, e }(zi), kr = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); var Gr = function (t) { function e(e) { var n = t.call(this) || this; if (n.id_ = void 0, n.geometryName_ = "geometry", n.style_ = null, n.styleFunction_ = void 0, n.geometryChangeKey_ = null, n.addEventListener(U(n.geometryName_), n.handleGeometryChanged_), e) if ("function" == typeof e.getSimplifiedGeometry) { var i = e; n.setGeometry(i) } else { var r = e; n.setProperties(r) } return n } return kr(e, t), e.prototype.clone = function () { var t = new e(this.hasProperties() ? this.getProperties() : null); t.setGeometryName(this.getGeometryName()); var n = this.getGeometry(); n && t.setGeometry(n.clone()); var i = this.getStyle(); return i && t.setStyle(i), t }, e.prototype.getGeometry = function () { return this.get(this.geometryName_) }, e.prototype.getId = function () { return this.id_ }, e.prototype.getGeometryName = function () { return this.geometryName_ }, e.prototype.getStyle = function () { return this.style_ }, e.prototype.getStyleFunction = function () { return this.styleFunction_ }, e.prototype.handleGeometryChange_ = function () { this.changed() }, e.prototype.handleGeometryChanged_ = function () { this.geometryChangeKey_ && (k(this.geometryChangeKey_), this.geometryChangeKey_ = null); var t = this.getGeometry(); t && (this.geometryChangeKey_ = A(t, R, this.handleGeometryChange_, this)), this.changed() }, e.prototype.setGeometry = function (t) { this.set(this.geometryName_, t) }, e.prototype.setStyle = function (t) { this.style_ = t, this.styleFunction_ = t ? function (t) { if ("function" == typeof t) return t; var e; Array.isArray(t) ? e = t : (St("function" == typeof t.getZIndex, 41), e = [t]); return function () { return e } }(t) : void 0, this.changed() }, e.prototype.setId = function (t) { this.id_ = t, this.changed() }, e.prototype.setGeometryName = function (t) { this.removeEventListener(U(this.geometryName_), this.handleGeometryChanged_), this.geometryName_ = t, this.addEventListener(U(this.geometryName_), this.handleGeometryChanged_), this.handleGeometryChanged_() }, e }(V), jr = "opacity", Br = "visible", Yr = "extent", qr = "zIndex", Xr = "maxResolution", zr = "minResolution", Ur = "maxZoom", Vr = "minZoom", Wr = "source", Hr = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Kr = function (t) { function e(e) { var n = t.call(this) || this, i = C({}, e); return i[jr] = void 0 !== e.opacity ? e.opacity : 1, St("number" == typeof i[jr], 64), i[Br] = void 0 === e.visible || e.visible, i[qr] = e.zIndex, i[Xr] = void 0 !== e.maxResolution ? e.maxResolution : 1 / 0, i[zr] = void 0 !== e.minResolution ? e.minResolution : 0, i[Vr] = void 0 !== e.minZoom ? e.minZoom : -1 / 0, i[Ur] = void 0 !== e.maxZoom ? e.maxZoom : 1 / 0, n.className_ = void 0 !== i.className ? e.className : "ol-layer", delete i.className, n.setProperties(i), n.state_ = null, n } return Hr(e, t), e.prototype.getClassName = function () { return this.className_ }, e.prototype.getLayerState = function (t) { var e = this.state_ || { layer: this, managed: void 0 === t || t }, n = this.getZIndex(); return e.opacity = re(Math.round(100 * this.getOpacity()) / 100, 0, 1), e.sourceState = this.getSourceState(), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = void 0 !== n ? n : !1 === e.managed ? 1 / 0 : 0, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e }, e.prototype.getLayersArray = function (t) { return o() }, e.prototype.getLayerStatesArray = function (t) { return o() }, e.prototype.getExtent = function () { return this.get(Yr) }, e.prototype.getMaxResolution = function () { return this.get(Xr) }, e.prototype.getMinResolution = function () { return this.get(zr) }, e.prototype.getMinZoom = function () { return this.get(Vr) }, e.prototype.getMaxZoom = function () { return this.get(Ur) }, e.prototype.getOpacity = function () { return this.get(jr) }, e.prototype.getSourceState = function () { return o() }, e.prototype.getVisible = function () { return this.get(Br) }, e.prototype.getZIndex = function () { return this.get(qr) }, e.prototype.setExtent = function (t) { this.set(Yr, t) }, e.prototype.setMaxResolution = function (t) { this.set(Xr, t) }, e.prototype.setMinResolution = function (t) { this.set(zr, t) }, e.prototype.setMaxZoom = function (t) { this.set(Ur, t) }, e.prototype.setMinZoom = function (t) { this.set(Vr, t) }, e.prototype.setOpacity = function (t) { St("number" == typeof t, 64), this.set(jr, t) }, e.prototype.setVisible = function (t) { this.set(Br, t) }, e.prototype.setZIndex = function (t) { this.set(qr, t) }, e.prototype.disposeInternal = function () { this.state_ && (this.state_.layer = null, this.state_ = null), t.prototype.disposeInternal.call(this) }, e }(V), Zr = "prerender", Jr = "postrender", Qr = "precompose", $r = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); var ts = function (t) { function e(e) { var n = this, i = C({}, e); delete i.source, (n = t.call(this, i) || this).mapPrecomposeKey_ = null, n.mapRenderKey_ = null, n.sourceChangeKey_ = null, n.renderer_ = null, e.render && (n.render = e.render), e.map && n.setMap(e.map), n.addEventListener(U(Wr), n.handleSourcePropertyChange_); var r = e.source ? e.source : null; return n.setSource(r), n } return $r(e, t), e.prototype.getLayersArray = function (t) { var e = t || []; return e.push(this), e }, e.prototype.getLayerStatesArray = function (t) { var e = t || []; return e.push(this.getLayerState()), e }, e.prototype.getSource = function () { return this.get(Wr) || null }, e.prototype.getSourceState = function () { var t = this.getSource(); return t ? t.getState() : Qt }, e.prototype.handleSourceChange_ = function () { this.changed() }, e.prototype.handleSourcePropertyChange_ = function () { this.sourceChangeKey_ && (k(this.sourceChangeKey_), this.sourceChangeKey_ = null); var t = this.getSource(); t && (this.sourceChangeKey_ = A(t, R, this.handleSourceChange_, this)), this.changed() }, e.prototype.getFeatures = function (t) { return this.renderer_.getFeatures(t) }, e.prototype.render = function (t, e) { var n = this.getRenderer(); if (n.prepareFrame(t)) return n.renderFrame(t, e) }, e.prototype.setMap = function (t) { this.mapPrecomposeKey_ && (k(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (k(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = A(t, Qr, (function (t) { var e = t.frameState.layerStatesArray, n = this.getLayerState(!1); St(!e.some((function (t) { return t.layer === n.layer })), 67), e.push(n) }), this), this.mapRenderKey_ = A(this, R, t.render, t), this.changed()) }, e.prototype.setSource = function (t) { this.set(Wr, t) }, e.prototype.getRenderer = function () { return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_ }, e.prototype.hasRenderer = function () { return !!this.renderer_ }, e.prototype.createRenderer = function () { return null }, e.prototype.disposeInternal = function () { this.setSource(null), t.prototype.disposeInternal.call(this) }, e }(Kr), es = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), ns = "renderOrder", is = function (t) { function e(e) { var n = this, i = e || {}, r = C({}, i); return delete r.style, delete r.renderBuffer, delete r.updateWhileAnimating, delete r.updateWhileInteracting, (n = t.call(this, r) || this).declutter_ = void 0 !== i.declutter && i.declutter, n.renderBuffer_ = void 0 !== i.renderBuffer ? i.renderBuffer : 100, n.style_ = null, n.styleFunction_ = void 0, n.setStyle(i.style), n.updateWhileAnimating_ = void 0 !== i.updateWhileAnimating && i.updateWhileAnimating, n.updateWhileInteracting_ = void 0 !== i.updateWhileInteracting && i.updateWhileInteracting, n } return es(e, t), e.prototype.getDeclutter = function () { return this.declutter_ }, e.prototype.getFeatures = function (e) { return t.prototype.getFeatures.call(this, e) }, e.prototype.getRenderBuffer = function () { return this.renderBuffer_ }, e.prototype.getRenderOrder = function () { return this.get(ns) }, e.prototype.getStyle = function () { return this.style_ }, e.prototype.getStyleFunction = function () { return this.styleFunction_ }, e.prototype.getUpdateWhileAnimating = function () { return this.updateWhileAnimating_ }, e.prototype.getUpdateWhileInteracting = function () { return this.updateWhileInteracting_ }, e.prototype.setRenderOrder = function (t) { this.set(ns, t) }, e.prototype.setStyle = function (t) { this.style_ = void 0 !== t ? t : Ti, this.styleFunction_ = null === t ? void 0 : function (t) { var e; if ("function" == typeof t) e = t; else { var n; if (Array.isArray(t)) n = t; else St("function" == typeof t.getZIndex, 41), n = [t]; e = function () { return n } } return e }(this.style_), this.changed() }, e }(ts), rs = { BEGIN_GEOMETRY: 0, BEGIN_PATH: 1, CIRCLE: 2, CLOSE_PATH: 3, CUSTOM: 4, DRAW_CHARS: 5, DRAW_IMAGE: 6, END_GEOMETRY: 7, FILL: 8, MOVE_TO_LINE_TO: 9, SET_FILL_STYLE: 10, SET_STROKE_STYLE: 11, STROKE: 12 }, ss = [rs.FILL], os = [rs.STROKE], as = [rs.BEGIN_PATH], ls = [rs.CLOSE_PATH], hs = rs, cs = function () { function t() { } return t.prototype.drawCustom = function (t, e, n) { }, t.prototype.drawGeometry = function (t) { }, t.prototype.setStyle = function (t) { }, t.prototype.drawCircle = function (t, e) { }, t.prototype.drawFeature = function (t, e) { }, t.prototype.drawGeometryCollection = function (t, e) { }, t.prototype.drawLineString = function (t, e) { }, t.prototype.drawMultiLineString = function (t, e) { }, t.prototype.drawMultiPoint = function (t, e) { }, t.prototype.drawMultiPolygon = function (t, e) { }, t.prototype.drawPoint = function (t, e) { }, t.prototype.drawPolygon = function (t, e) { }, t.prototype.drawText = function (t, e) { }, t.prototype.setFillStrokeStyle = function (t, e) { }, t.prototype.setImageStyle = function (t, e) { }, t.prototype.setTextStyle = function (t, e) { }, t }(), us = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), fs = function (t) { function e(e, n, i, r) { var s = t.call(this) || this; return s.tolerance = e, s.maxExtent = n, s.pixelRatio = r, s.maxLineWidth = 0, s.resolution = i, s.beginGeometryInstruction1_ = null, s.beginGeometryInstruction2_ = null, s.bufferedMaxExtent_ = null, s.instructions = [], s.coordinates = [], s.tmpCoordinate_ = [], s.hitDetectionInstructions = [], s.state = {}, s } return us(e, t), e.prototype.applyPixelRatio = function (t) { var e = this.pixelRatio; return 1 == e ? t : t.map((function (t) { return t * e })) }, e.prototype.appendFlatCoordinates = function (t, e, n, i, r, s) { var o = this.coordinates.length, a = this.getBufferedMaxExtent(); s && (e += i); var l, h, c, u = t[e], f = t[e + 1], p = this.tmpCoordinate_, d = !0; for (l = e + i; l < n; l += i)p[0] = t[l], p[1] = t[l + 1], (c = Lt(a, p)) !== h ? (d && (this.coordinates[o++] = u, this.coordinates[o++] = f), this.coordinates[o++] = p[0], this.coordinates[o++] = p[1], d = !1) : c === xt ? (this.coordinates[o++] = p[0], this.coordinates[o++] = p[1], d = !1) : d = !0, u = p[0], f = p[1], h = c; return (r && d || l === e + i) && (this.coordinates[o++] = u, this.coordinates[o++] = f), o }, e.prototype.drawCustomCoordinates_ = function (t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s) { var a = n[s], l = this.appendFlatCoordinates(t, e, a, i, !1, !1); r.push(l), e = a } return e }, e.prototype.drawCustom = function (t, e, n) { this.beginGeometry(t, e); var i, r, s, o, a, l = t.getType(), h = t.getStride(), c = this.coordinates.length; if (l == Pe) { i = t.getOrientedFlatCoordinates(), o = []; var u = t.getEndss(); a = 0; for (var f = 0, p = u.length; f < p; ++f) { var d = []; a = this.drawCustomCoordinates_(i, a, u[f], h, d), o.push(d) } this.instructions.push([hs.CUSTOM, c, o, t, n, hr]) } else l == Re || l == Le ? (s = [], i = l == Re ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(), a = this.drawCustomCoordinates_(i, 0, t.getEnds(), h, s), this.instructions.push([hs.CUSTOM, c, s, t, n, lr])) : l == Oe || l == Ne ? (i = t.getFlatCoordinates(), r = this.appendFlatCoordinates(i, 0, i.length, h, !1, !1), this.instructions.push([hs.CUSTOM, c, r, t, n, ar])) : l == be && (i = t.getFlatCoordinates(), this.coordinates.push(i[0], i[1]), r = this.coordinates.length, this.instructions.push([hs.CUSTOM, c, r, t, n])); this.endGeometry(e) }, e.prototype.beginGeometry = function (t, e) { var n = t.getExtent(); this.beginGeometryInstruction1_ = [hs.BEGIN_GEOMETRY, e, 0, n], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [hs.BEGIN_GEOMETRY, e, 0, n], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_) }, e.prototype.finish = function () { return { instructions: this.instructions, hitDetectionInstructions: this.hitDetectionInstructions, coordinates: this.coordinates } }, e.prototype.reverseHitDetectionInstructions = function () { var t, e = this.hitDetectionInstructions; e.reverse(); var n, i, r = e.length, s = -1; for (t = 0; t < r; ++t)(i = (n = e[t])[0]) == hs.END_GEOMETRY ? s = t : i == hs.BEGIN_GEOMETRY && (n[2] = t, y(this.hitDetectionInstructions, s, t), s = -1) }, e.prototype.setFillStrokeStyle = function (t, e) { var n = this.state; if (t) { var i = t.getColor(); n.fillStyle = Zn(i || "#000") } else n.fillStyle = void 0; if (e) { var r = e.getColor(); n.strokeStyle = Zn(r || "#000"); var s = e.getLineCap(); n.lineCap = void 0 !== s ? s : "round"; var o = e.getLineDash(); n.lineDash = o ? o.slice() : si; var a = e.getLineDashOffset(); n.lineDashOffset = a || 0; var l = e.getLineJoin(); n.lineJoin = void 0 !== l ? l : "round"; var h = e.getWidth(); n.lineWidth = void 0 !== h ? h : 1; var c = e.getMiterLimit(); n.miterLimit = void 0 !== c ? c : 10, n.lineWidth > this.maxLineWidth && (this.maxLineWidth = n.lineWidth, this.bufferedMaxExtent_ = null) } else n.strokeStyle = void 0, n.lineCap = void 0, n.lineDash = null, n.lineDashOffset = void 0, n.lineJoin = void 0, n.lineWidth = void 0, n.miterLimit = void 0 }, e.prototype.createFill = function (t) { var e = t.fillStyle, n = [hs.SET_FILL_STYLE, e]; return "string" != typeof e && n.push(!0), n }, e.prototype.applyStroke = function (t) { this.instructions.push(this.createStroke(t)) }, e.prototype.createStroke = function (t) { return [hs.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio] }, e.prototype.updateFillStyle = function (t, e) { var n = t.fillStyle; "string" == typeof n && t.currentFillStyle == n || (void 0 !== n && this.instructions.push(e.call(this, t)), t.currentFillStyle = n) }, e.prototype.updateStrokeStyle = function (t, e) { var n = t.strokeStyle, i = t.lineCap, r = t.lineDash, s = t.lineDashOffset, o = t.lineJoin, a = t.lineWidth, l = t.miterLimit; (t.currentStrokeStyle != n || t.currentLineCap != i || r != t.currentLineDash && !v(t.currentLineDash, r) || t.currentLineDashOffset != s || t.currentLineJoin != o || t.currentLineWidth != a || t.currentMiterLimit != l) && (void 0 !== n && e.call(this, t), t.currentStrokeStyle = n, t.currentLineCap = i, t.currentLineDash = r, t.currentLineDashOffset = s, t.currentLineJoin = o, t.currentLineWidth = a, t.currentMiterLimit = l) }, e.prototype.endGeometry = function (t) { this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null; var e = [hs.END_GEOMETRY, t]; this.instructions.push(e), this.hitDetectionInstructions.push(e) }, e.prototype.getBufferedMaxExtent = function () { if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = (e = this.maxExtent, n ? (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n) : e.slice()), this.maxLineWidth > 0)) { var t = this.resolution * (this.maxLineWidth + 1) / 2; Ot(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_) } var e, n; return this.bufferedMaxExtent_ }, e }(cs), ps = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), ds = function (t) { function e(e, n, i, r) { var s = t.call(this, e, n, i, r) || this; return s.declutterGroups_ = null, s.hitDetectionImage_ = null, s.image_ = null, s.imagePixelRatio_ = void 0, s.anchorX_ = void 0, s.anchorY_ = void 0, s.height_ = void 0, s.opacity_ = void 0, s.originX_ = void 0, s.originY_ = void 0, s.rotateWithView_ = void 0, s.rotation_ = void 0, s.scale_ = void 0, s.width_ = void 0, s } return ps(e, t), e.prototype.drawCoordinates_ = function (t, e, n, i) { return this.appendFlatCoordinates(t, e, n, i, !1, !1) }, e.prototype.drawPoint = function (t, e) { if (this.image_) { this.beginGeometry(t, e); var n = t.getFlatCoordinates(), i = t.getStride(), r = this.coordinates.length, s = this.drawCoordinates_(n, 0, n.length, i); this.instructions.push([hs.DRAW_IMAGE, r, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, this.declutterGroups_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_)]), this.hitDetectionInstructions.push([hs.DRAW_IMAGE, r, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroups_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]), this.endGeometry(e) } }, e.prototype.drawMultiPoint = function (t, e) { if (this.image_) { this.beginGeometry(t, e); var n = t.getFlatCoordinates(), i = t.getStride(), r = this.coordinates.length, s = this.drawCoordinates_(n, 0, n.length, i); this.instructions.push([hs.DRAW_IMAGE, r, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, this.declutterGroups_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_)]), this.hitDetectionInstructions.push([hs.DRAW_IMAGE, r, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroups_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]), this.endGeometry(e) } }, e.prototype.finish = function () { return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, t.prototype.finish.call(this) }, e.prototype.setImageStyle = function (t, e) { var n = t.getAnchor(), i = t.getSize(), r = t.getHitDetectionImage(), s = t.getImage(this.pixelRatio), o = t.getOrigin(); this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.declutterGroups_ = e, this.hitDetectionImage_ = r, this.image_ = s, this.height_ = i[1], this.opacity_ = t.getOpacity(), this.originX_ = o[0], this.originY_ = o[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = i[0] }, e }(fs), gs = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), _s = function (t) { function e(e, n, i, r) { return t.call(this, e, n, i, r) || this } return gs(e, t), e.prototype.drawFlatCoordinates_ = function (t, e, n, i) { var r = this.coordinates.length, s = this.appendFlatCoordinates(t, e, n, i, !1, !1), o = [hs.MOVE_TO_LINE_TO, r, s]; return this.instructions.push(o), this.hitDetectionInstructions.push(o), n }, e.prototype.drawLineString = function (t, e) { var n = this.state, i = n.strokeStyle, r = n.lineWidth; if (void 0 !== i && void 0 !== r) { this.updateStrokeStyle(n, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([hs.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset], as); var s = t.getFlatCoordinates(), o = t.getStride(); this.drawFlatCoordinates_(s, 0, s.length, o), this.hitDetectionInstructions.push(os), this.endGeometry(e) } }, e.prototype.drawMultiLineString = function (t, e) { var n = this.state, i = n.strokeStyle, r = n.lineWidth; if (void 0 !== i && void 0 !== r) { this.updateStrokeStyle(n, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([hs.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset], as); for (var s = t.getEnds(), o = t.getFlatCoordinates(), a = t.getStride(), l = 0, h = 0, c = s.length; h < c; ++h)l = this.drawFlatCoordinates_(o, l, s[h], a); this.hitDetectionInstructions.push(os), this.endGeometry(e) } }, e.prototype.finish = function () { var e = this.state; return null != e.lastStroke && e.lastStroke != this.coordinates.length && this.instructions.push(os), this.reverseHitDetectionInstructions(), this.state = null, t.prototype.finish.call(this) }, e.prototype.applyStroke = function (e) { null != e.lastStroke && e.lastStroke != this.coordinates.length && (this.instructions.push(os), e.lastStroke = this.coordinates.length), e.lastStroke = 0, t.prototype.applyStroke.call(this, e), this.instructions.push(as) }, e }(fs), ys = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), ms = function (t) { function e(e, n, i, r) { return t.call(this, e, n, i, r) || this } return ys(e, t), e.prototype.drawFlatCoordinatess_ = function (t, e, n, i) { var r = this.state, s = void 0 !== r.fillStyle, o = void 0 !== r.strokeStyle, a = n.length; this.instructions.push(as), this.hitDetectionInstructions.push(as); for (var l = 0; l < a; ++l) { var h = n[l], c = this.coordinates.length, u = this.appendFlatCoordinates(t, e, h, i, !0, !o), f = [hs.MOVE_TO_LINE_TO, c, u]; this.instructions.push(f), this.hitDetectionInstructions.push(f), o && (this.instructions.push(ls), this.hitDetectionInstructions.push(ls)), e = h } return s && (this.instructions.push(ss), this.hitDetectionInstructions.push(ss)), o && (this.instructions.push(os), this.hitDetectionInstructions.push(os)), e }, e.prototype.drawCircle = function (t, e) { var n = this.state, i = n.fillStyle, r = n.strokeStyle; if (void 0 !== i || void 0 !== r) { this.setFillStrokeStyles_(), this.beginGeometry(t, e), void 0 !== n.fillStyle && this.hitDetectionInstructions.push([hs.SET_FILL_STYLE, "#000"]), void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([hs.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]); var s = t.getFlatCoordinates(), o = t.getStride(), a = this.coordinates.length; this.appendFlatCoordinates(s, 0, s.length, o, !1, !1); var l = [hs.CIRCLE, a]; this.instructions.push(as, l), this.hitDetectionInstructions.push(as, l), void 0 !== n.fillStyle && (this.instructions.push(ss), this.hitDetectionInstructions.push(ss)), void 0 !== n.strokeStyle && (this.instructions.push(os), this.hitDetectionInstructions.push(os)), this.endGeometry(e) } }, e.prototype.drawPolygon = function (t, e) { var n = this.state, i = n.fillStyle, r = n.strokeStyle; if (void 0 !== i || void 0 !== r) { this.setFillStrokeStyles_(), this.beginGeometry(t, e), void 0 !== n.fillStyle && this.hitDetectionInstructions.push([hs.SET_FILL_STYLE, "#000"]), void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([hs.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]); var s = t.getEnds(), o = t.getOrientedFlatCoordinates(), a = t.getStride(); this.drawFlatCoordinatess_(o, 0, s, a), this.endGeometry(e) } }, e.prototype.drawMultiPolygon = function (t, e) { var n = this.state, i = n.fillStyle, r = n.strokeStyle; if (void 0 !== i || void 0 !== r) { this.setFillStrokeStyles_(), this.beginGeometry(t, e), void 0 !== n.fillStyle && this.hitDetectionInstructions.push([hs.SET_FILL_STYLE, "#000"]), void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([hs.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]); for (var s = t.getEndss(), o = t.getOrientedFlatCoordinates(), a = t.getStride(), l = 0, h = 0, c = s.length; h < c; ++h)l = this.drawFlatCoordinatess_(o, l, s[h], a); this.endGeometry(e) } }, e.prototype.finish = function () { this.reverseHitDetectionInstructions(), this.state = null; var e = this.tolerance; if (0 !== e) for (var n = this.coordinates, i = 0, r = n.length; i < r; ++i)n[i] = ir(n[i], e); return t.prototype.finish.call(this) }, e.prototype.setFillStrokeStyles_ = function () { var t = this.state; void 0 !== t.fillStyle && this.updateFillStyle(t, this.createFill), void 0 !== t.strokeStyle && this.updateStrokeStyle(t, this.applyStroke) }, e }(fs), vs = "line"; function xs(t, e, n, i, r) { var s, o, a, l, h, c, u, f, p, d = n, g = n, _ = 0, y = 0, m = n; for (s = n; s < i; s += r) { var v = e[s], x = e[s + 1]; void 0 !== l && (f = v - l, p = x - h, a = Math.sqrt(f * f + p * p), void 0 !== c && (y += o, Math.acos((c * f + u * p) / (o * a)) > t && (y > _ && (_ = y, d = m, g = s), y = 0, m = s - r)), o = a, c = f, u = p), l = v, h = x } return (y += a) > _ ? [m, s] : [d, g] } var Es = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Is = { left: 0, end: 0, center: .5, right: 1, start: 1, top: 0, middle: .5, hanging: .2, alphabetic: .8, ideographic: .8, bottom: 1 }, Cs = { Circle: ms, Default: fs, Image: ds, LineString: _s, Polygon: ms, Text: function (t) { function e(e, n, i, r) { var s = t.call(this, e, n, i, r) || this; return s.declutterGroups_, s.labels_ = null, s.text_ = "", s.textOffsetX_ = 0, s.textOffsetY_ = 0, s.textRotateWithView_ = void 0, s.textRotation_ = 0, s.textFillState_ = null, s.fillStates = {}, s.textStrokeState_ = null, s.strokeStates = {}, s.textState_ = {}, s.textStates = {}, s.textKey_ = "", s.fillKey_ = "", s.strokeKey_ = "", s } return Es(e, t), e.prototype.finish = function () { var e = t.prototype.finish.call(this); return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e }, e.prototype.drawText = function (t, e) { var n = this.textFillState_, i = this.textStrokeState_, r = this.textState_; if ("" !== this.text_ && r && (n || i)) { var s, o, a = this.coordinates.length, l = t.getType(), h = null, c = 2, u = t.getStride(); if (r.placement === vs) { if (!Kt(this.getBufferedMaxExtent(), t.getExtent())) return; var f = void 0; if (h = t.getFlatCoordinates(), l == Oe) f = [h.length]; else if (l == Le) f = t.getEnds(); else if (l == Re) f = t.getEnds().slice(0, 1); else if (l == Pe) { var p = t.getEndss(); for (f = [], s = 0, o = p.length; s < o; ++s)f.push(p[s][0]) } this.beginGeometry(t, e); for (var d = r.textAlign, g = 0, _ = void 0, y = 0, m = f.length; y < m; ++y) { if (null == d) { var v = xs(r.maxAngle, h, g, f[y], u); g = v[0], _ = v[1] } else _ = f[y]; for (s = g; s < _; s += u)this.coordinates.push(h[s], h[s + 1]); c = this.coordinates.length, g = f[y]; var x = this.declutterGroups_ ? 0 === y ? this.declutterGroups_[0] : [].concat(this.declutterGroups_[0]) : null; this.drawChars_(a, c, x), a = c } this.endGeometry(e) } else { var E = null; switch (r.overflow || (E = []), l) { case be: case Ne: c = (h = t.getFlatCoordinates()).length; break; case Oe: h = t.getFlatMidpoint(); break; case De: h = t.getCenter(); break; case Le: u = 2, c = (h = t.getFlatMidpoints()).length; break; case Re: h = t.getFlatInteriorPoint(), r.overflow || E.push(h[2] / this.resolution), u = 3; break; case Pe: var I = t.getFlatInteriorPoints(); for (h = [], s = 0, o = I.length; s < o; s += 3)r.overflow || E.push(I[s + 2] / this.resolution), h.push(I[s], I[s + 1]); if (u = 2, 0 == (c = h.length)) return }c = this.appendFlatCoordinates(h, 0, c, u, !1, !1), this.saveTextStates_(), (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(r.backgroundFill, r.backgroundStroke), r.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), r.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e); var C = r.padding; if (C != oi && (r.scale[0] < 0 || r.scale[1] < 0)) { var w = r.padding[0], S = r.padding[1], b = r.padding[2], O = r.padding[3]; r.scale[0] < 0 && (S = -S, O = -O), r.scale[1] < 0 && (w = -w, b = -b), C = [w, S, b, O] } var T = this.pixelRatio; this.instructions.push([hs.DRAW_IMAGE, a, c, null, NaN, NaN, this.declutterGroups_, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, C == oi ? oi : C.map((function (t) { return t * T })), !!r.backgroundFill, !!r.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, E]); var R = 1 / T; this.hitDetectionInstructions.push([hs.DRAW_IMAGE, a, c, null, NaN, NaN, this.declutterGroups_, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [R, R], NaN, C, !!r.backgroundFill, !!r.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, E]), this.endGeometry(e) } } }, e.prototype.saveTextStates_ = function () { var t = this.textStrokeState_, e = this.textState_, n = this.textFillState_, i = this.strokeKey_; t && (i in this.strokeStates || (this.strokeStates[i] = { strokeStyle: t.strokeStyle, lineCap: t.lineCap, lineDashOffset: t.lineDashOffset, lineWidth: t.lineWidth, lineJoin: t.lineJoin, miterLimit: t.miterLimit, lineDash: t.lineDash })); var r = this.textKey_; r in this.textStates || (this.textStates[r] = { font: e.font, textAlign: e.textAlign || "center", textBaseline: e.textBaseline || "middle", scale: e.scale }); var s = this.fillKey_; n && (s in this.fillStates || (this.fillStates[s] = { fillStyle: n.fillStyle })) }, e.prototype.drawChars_ = function (t, e, n) { var i = this.textStrokeState_, r = this.textState_, s = this.strokeKey_, o = this.textKey_, a = this.fillKey_; this.saveTextStates_(); var l = this.pixelRatio, h = Is[r.textBaseline], c = this.textOffsetY_ * l, u = this.text_, f = i ? i.lineWidth * Math.abs(r.scale[0]) / 2 : 0; this.instructions.push([hs.DRAW_CHARS, t, e, h, n, r.overflow, a, r.maxAngle, l, c, s, f * l, u, o, 1]), this.hitDetectionInstructions.push([hs.DRAW_CHARS, t, e, h, n, r.overflow, a, r.maxAngle, 1, c, s, f, u, o, 1 / l]) }, e.prototype.setTextStyle = function (t, e) { var n, i, r; if (t) { this.declutterGroups_ = e; var s = t.getFill(); s ? ((i = this.textFillState_) || (i = {}, this.textFillState_ = i), i.fillStyle = Zn(s.getColor() || "#000")) : (i = null, this.textFillState_ = i); var o = t.getStroke(); if (o) { (r = this.textStrokeState_) || (r = {}, this.textStrokeState_ = r); var a = o.getLineDash(), h = o.getLineDashOffset(), c = o.getWidth(), u = o.getMiterLimit(); r.lineCap = o.getLineCap() || "round", r.lineDash = a ? a.slice() : si, r.lineDashOffset = void 0 === h ? 0 : h, r.lineJoin = o.getLineJoin() || "round", r.lineWidth = void 0 === c ? 1 : c, r.miterLimit = void 0 === u ? 10 : u, r.strokeStyle = Zn(o.getColor() || "#000") } else r = null, this.textStrokeState_ = r; n = this.textState_; var f = t.getFont() || "10px sans-serif"; pi(f); var p = t.getScaleArray(); n.overflow = t.getOverflow(), n.font = f, n.maxAngle = t.getMaxAngle(), n.placement = t.getPlacement(), n.textAlign = t.getTextAlign(), n.textBaseline = t.getTextBaseline() || "middle", n.backgroundFill = t.getBackgroundFill(), n.backgroundStroke = t.getBackgroundStroke(), n.padding = t.getPadding() || oi, n.scale = void 0 === p ? [1, 1] : p; var d = t.getOffsetX(), g = t.getOffsetY(), _ = t.getRotateWithView(), y = t.getRotation(); this.text_ = t.getText() || "", this.textOffsetX_ = void 0 === d ? 0 : d, this.textOffsetY_ = void 0 === g ? 0 : g, this.textRotateWithView_ = void 0 !== _ && _, this.textRotation_ = void 0 === y ? 0 : y, this.strokeKey_ = r ? ("string" == typeof r.strokeStyle ? r.strokeStyle : l(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.textBaseline || "?"), this.fillKey_ = i ? "string" == typeof i.fillStyle ? i.fillStyle : "|" + l(i.fillStyle) : "" } else this.text_ = "" }, e }(fs) }, ws = function () { function t(t, e, n, i, r) { this.declutter_ = r, this.declutterGroups_ = null, this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = i, this.resolution_ = n, this.buildersByZIndex_ = {} } return t.prototype.addDeclutter = function (t) { var e = null; return this.declutter_ && (t ? (e = this.declutterGroups_)[0][0]++ : (e = [[1]], this.declutterGroups_ = e)), e }, t.prototype.finish = function () { var t = {}; for (var e in this.buildersByZIndex_) { t[e] = t[e] || {}; var n = this.buildersByZIndex_[e]; for (var i in n) { var r = n[i].finish(); t[e][i] = r } } return t }, t.prototype.getBuilder = function (t, e) { var n = void 0 !== t ? t.toString() : "0", i = this.buildersByZIndex_[n]; void 0 === i && (i = {}, this.buildersByZIndex_[n] = i); var r = i[e]; void 0 === r && (r = new (0, Cs[e])(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_), i[e] = r); return r }, t }(), Ss = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), bs = function (t) { function e(e) { var n = t.call(this) || this; return n.boundHandleImageChange_ = n.handleImageChange_.bind(n), n.layer_ = e, n } return Ss(e, t), e.prototype.getFeatures = function (t) { return o() }, e.prototype.prepareFrame = function (t) { return o() }, e.prototype.renderFrame = function (t, e) { return o() }, e.prototype.loadedTileCallback = function (t, e, n) { t[e] || (t[e] = {}), t[e][n.tileCoord.toString()] = n }, e.prototype.createLoadedTileFinder = function (t, e, n) { return function (i, r) { var s = this.loadedTileCallback.bind(this, n, i); return t.forEachLoadedTile(e, i, r, s) }.bind(this) }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r) { }, e.prototype.getDataAtPixel = function (t, e, n) { return o() }, e.prototype.getLayer = function () { return this.layer_ }, e.prototype.handleFontsChanged = function () { }, e.prototype.handleImageChange_ = function (t) { t.target.getState() === kn && this.renderIfReadyAndVisible() }, e.prototype.loadImage = function (t) { var e = t.getState(); return e != kn && e != Gn && t.addEventListener(R, this.boundHandleImageChange_), e == An && (t.load(), e = t.getState()), e == kn }, e.prototype.renderIfReadyAndVisible = function () { var t = this.getLayer(); t.getVisible() && t.getSourceState() == $t && t.changed() }, e }(B), Os = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Ts = function (t) { function e(e, n, i, r) { var s = t.call(this, e) || this; return s.inversePixelTransform = n, s.frameState = i, s.context = r, s } return Os(e, t), e }(f), Rs = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Ns = function (t) { function e(e) { var n = t.call(this, e) || this; return n.container = null, n.renderedResolution, n.tempTransform = [1, 0, 0, 1, 0, 0], n.pixelTransform = [1, 0, 0, 1, 0, 0], n.inversePixelTransform = [1, 0, 0, 1, 0, 0], n.context = null, n.containerReused = !1, n } return Rs(e, t), e.prototype.useContainer = function (t, e, n) { var i, r, s = this.getLayer().getClassName(); t && "" === t.style.opacity && t.className === s && ((a = t.firstElementChild) instanceof HTMLCanvasElement && (r = a.getContext("2d"))); if (!r || 0 !== r.canvas.width && r.canvas.style.transform !== e ? this.containerReused && (this.container = null, this.context = null, this.containerReused = !1) : (this.container = t, this.context = r, this.containerReused = !0), !this.container) { (i = document.createElement("div")).className = s; var o = i.style; o.position = "absolute", o.width = "100%", o.height = "100%"; var a = (r = it()).canvas; i.appendChild(a), (o = a.style).position = "absolute", o.left = "0", o.transformOrigin = "top left", this.container = i, this.context = r } }, e.prototype.clip = function (t, e, n) { var i = e.pixelRatio, r = e.size[0] * i / 2, s = e.size[1] * i / 2, o = e.viewState.rotation, a = Vt(n), l = Wt(n), h = Xt(n), c = qt(n); ei(e.coordinateToPixelTransform, a), ei(e.coordinateToPixelTransform, l), ei(e.coordinateToPixelTransform, h), ei(e.coordinateToPixelTransform, c), t.save(), mi(t, -o, r, s), t.beginPath(), t.moveTo(a[0] * i, a[1] * i), t.lineTo(l[0] * i, l[1] * i), t.lineTo(h[0] * i, h[1] * i), t.lineTo(c[0] * i, c[1] * i), t.clip(), mi(t, o, r, s) }, e.prototype.clipUnrotated = function (t, e, n) { var i = Vt(n), r = Wt(n), s = Xt(n), o = qt(n); ei(e.coordinateToPixelTransform, i), ei(e.coordinateToPixelTransform, r), ei(e.coordinateToPixelTransform, s), ei(e.coordinateToPixelTransform, o); var a = this.inversePixelTransform; ei(a, i), ei(a, r), ei(a, s), ei(a, o), t.save(), t.beginPath(), t.moveTo(Math.round(i[0]), Math.round(i[1])), t.lineTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.clip() }, e.prototype.dispatchRenderEvent_ = function (t, e, n) { var i = this.getLayer(); if (i.hasListener(t)) { var r = new Ts(t, this.inversePixelTransform, n, e); i.dispatchEvent(r) } }, e.prototype.preRender = function (t, e) { this.dispatchRenderEvent_(Zr, t, e) }, e.prototype.postRender = function (t, e) { this.dispatchRenderEvent_(Jr, t, e) }, e.prototype.getRenderTransform = function (t, e, n, i, r, s, o) { var a = r / 2, l = s / 2, h = i / e, c = -h, u = -t[0] + o, f = -t[1]; return ni(this.tempTransform, a, l, h, c, -n, u, f) }, e.prototype.getDataAtPixel = function (t, e, n) { var i, r = ei(this.inversePixelTransform, t.slice()), s = this.context; try { var o = Math.round(r[0]), a = Math.round(r[1]), l = document.createElement("canvas"), h = l.getContext("2d"); l.width = 1, l.height = 1, h.clearRect(0, 0, 1, 1), h.drawImage(s.canvas, o, a, 1, 1, 0, 0, 1, 1), i = h.getImageData(0, 0, 1, 1).data } catch (t) { return "SecurityError" === t.name ? new Uint8Array : i } return 0 === i[3] ? null : i }, e }(bs), Ls = "Circle", Ps = "Default", Ms = "Image", Ds = "LineString", As = "Polygon", Fs = "Text"; function ks(t, e, n, i, r, s, o, a, l, h, c, u) { var f, p = []; if (u) { var d = Mi(t, e, n, i, u, [t[e], t[e + 1]]); f = d[0] > d[d.length - i] } else f = t[e] > t[n - i]; for (var g, _, y = r.length, m = t[e], v = t[e + 1], x = t[e += i], E = t[e + 1], I = 0, C = Math.sqrt(Math.pow(x - m, 2) + Math.pow(E - v, 2)), w = !1, S = 0; S < y; ++S) { for (var b = r[g = f ? y - S - 1 : S], O = a * l(h, b, c), T = s + O / 2; e < n - i && I + C < T;)m = x, v = E, x = t[e += i], E = t[e + 1], I += C, C = Math.sqrt(Math.pow(x - m, 2) + Math.pow(E - v, 2)); var R = T - I, N = Math.atan2(E - v, x - m); if (f && (N += N > 0 ? -Math.PI : Math.PI), void 0 !== _) { var L = N - _; if (w = w || 0 !== L, L += L > Math.PI ? -2 * Math.PI : L < -Math.PI ? 2 * Math.PI : 0, Math.abs(L) > o) return null } _ = N; var P = R / C, M = he(m, x, P), D = he(v, E, P); p[g] = [M, D, O / 2, N, b], s += O } return w ? p : [[p[0][0], p[0][1], p[0][2], p[0][3], r]] } var Gs = [1 / 0, 1 / 0, -1 / 0, -1 / 0], js = [1, 0, 0, 1, 0, 0], Bs = [], Ys = [], qs = [], Xs = [], zs = function () { function t(t, e, n, i, r) { this.overlaps = n, this.pixelRatio = e, this.resolution = t, this.alignFill_, this.declutterItems = [], this.instructions = i.instructions, this.coordinates = i.coordinates, this.coordinateCache_ = {}, this.renderBuffer_ = r, this.renderedTransform_ = [1, 0, 0, 1, 0, 0], this.hitDetectionInstructions = i.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = i.fillStates || {}, this.strokeStates = i.strokeStates || {}, this.textStates = i.textStates || {}, this.widths_ = {}, this.labels_ = {} } return t.prototype.createLabel = function (t, e, n, i) { var r = t + e + n + i; if (this.labels_[r]) return this.labels_[r]; var s = i ? this.strokeStates[i] : null, o = n ? this.fillStates[n] : null, a = this.textStates[e], l = this.pixelRatio, h = [a.scale[0] * l, a.scale[1] * l], c = Is[a.textAlign || "center"], u = i && s.lineWidth ? s.lineWidth : 0, f = t.split("\n"), p = f.length, d = [], g = function (t, e, n) { for (var i = e.length, r = 0, s = 0; s < i; ++s) { var o = _i(t, e[s]); r = Math.max(r, o), n.push(o) } return r }(a.font, f, d), _ = di(a.font), y = g + u, m = [], v = (y + 2) * h[0], x = (_ * p + u) * h[1], E = { width: v < 0 ? Math.floor(v) : Math.ceil(v), height: x < 0 ? Math.floor(x) : Math.ceil(x), contextInstructions: m }; (1 == h[0] && 1 == h[1] || m.push("scale", h), m.push("font", a.font), i) && (m.push("strokeStyle", s.strokeStyle), m.push("lineWidth", u), m.push("lineCap", s.lineCap), m.push("lineJoin", s.lineJoin), m.push("miterLimit", s.miterLimit), (et ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D).prototype.setLineDash && (m.push("setLineDash", [s.lineDash]), m.push("lineDashOffset", s.lineDashOffset))); n && m.push("fillStyle", o.fillStyle), m.push("textBaseline", "middle"), m.push("textAlign", "center"); var I, C = .5 - c, w = c * y + C * u; if (i) for (I = 0; I < p; ++I)m.push("strokeText", [f[I], w + C * d[I], .5 * (u + _) + I * _]); if (n) for (I = 0; I < p; ++I)m.push("fillText", [f[I], w + C * d[I], .5 * (u + _) + I * _]); return this.labels_[r] = E, E }, t.prototype.replayTextBackground_ = function (t, e, n, i, r, s, o, a) { t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, n), t.lineTo.apply(t, i), t.lineTo.apply(t, r), t.lineTo.apply(t, e), s && (this.alignFill_ = s[2], a && (t.fillStyle = s[1]), this.fill_(t)), o && (this.setStrokeStyle_(t, o), t.stroke()) }, t.prototype.replayImageOrLabel_ = function (t, e, n, i, r, s, o, a, l, h, c, u, f, p, d, g, _, y, m) { var v = y || m; n -= s *= p[0], i -= o *= p[1]; var x = g + c > r.width ? r.width - c : g, E = l + u > r.height ? r.height - u : l, I = _[3] + x * p[0] + _[1], C = _[0] + E * p[1] + _[2], w = n - _[3], S = i - _[0]; (v || 0 !== f) && (Bs[0] = w, Xs[0] = w, Bs[1] = S, Ys[1] = S, Ys[0] = w + I, qs[0] = Ys[0], qs[1] = S + C, Xs[1] = qs[1]); var b = null; if (0 !== f) { var O = n + s, T = i + o; b = ni(js, O, T, 1, 1, f, -O, -T), ei(js, Bs), ei(js, Ys), ei(js, qs), ei(js, Xs), Mt(Math.min(Bs[0], Ys[0], qs[0], Xs[0]), Math.min(Bs[1], Ys[1], qs[1], Xs[1]), Math.max(Bs[0], Ys[0], qs[0], Xs[0]), Math.max(Bs[1], Ys[1], qs[1], Xs[1]), Gs) } else Mt(w, S, w + I, S + C, Gs); var R = 0, N = 0; if (a) { var L = this.renderBuffer_; L[0] = Math.max(L[0], Ht(Gs)), R = L[0], L[1] = Math.max(L[1], Ut(Gs)), N = L[1] } var P = t.canvas, M = m ? m[2] * p[0] / 2 : 0, D = Gs[0] - M <= (P.width + R) / e && Gs[2] + M >= -R / e && Gs[1] - M <= (P.height + N) / e && Gs[3] + M >= -N / e; if (d && (n = Math.round(n), i = Math.round(i)), a) { if (!D && 1 == a[0]) return !1; var A = D ? [t, b ? b.slice(0) : null, h, r, c, u, x, E, n, i, p, Gs.slice()] : null; A && (v && A.push(y, m, Bs.slice(0), Ys.slice(0), qs.slice(0), Xs.slice(0)), a.push(A)) } else D && (v && this.replayTextBackground_(t, Bs, Ys, qs, Xs, y, m, !1), vi(t, b, h, r, c, u, x, E, n, i, p)); return !0 }, t.prototype.fill_ = function (t) { if (this.alignFill_) { var e = ei(this.renderedTransform_, [0, 0]), n = 512 * this.pixelRatio; t.save(), t.translate(e[0] % n, e[1] % n), t.rotate(this.viewRotation_) } t.fill(), this.alignFill_ && t.restore() }, t.prototype.setStrokeStyle_ = function (t, e) { t.strokeStyle = e[1], t.lineWidth = e[2], t.lineCap = e[3], t.lineJoin = e[4], t.miterLimit = e[5], t.setLineDash && (t.lineDashOffset = e[7], t.setLineDash(e[6])) }, t.prototype.renderDeclutter = function (t, e, n, i) { for (var r = [], s = 1, o = t.length; s < o; ++s) { var a = (u = t[s])[11]; r.push({ minX: a[0], minY: a[1], maxX: a[2], maxY: a[3], value: e }) } i || (i = new mt.a(9)); var l = !1; for (s = 0, o = r.length; s < o; ++s)if (i.collides(r[s])) { l = !0; break } if (!l) { i.load(r); for (var h = 1, c = t.length; h < c; ++h) { var u, f = (u = t[h])[0], p = f.globalAlpha; p !== n && (f.globalAlpha = n), u.length > 12 && this.replayTextBackground_(u[0], u[14], u[15], u[16], u[17], u[12], u[13], !0), vi.apply(void 0, u), p !== n && (f.globalAlpha = p) } } return t.length = 1, i }, t.prototype.drawLabelWithPointPlacement_ = function (t, e, n, i) { var r = this.textStates[e], s = this.createLabel(t, e, i, n), o = this.strokeStates[n], a = this.pixelRatio, l = Is[r.textAlign || "center"], h = Is[r.textBaseline || "middle"], c = o && o.lineWidth ? o.lineWidth : 0; return { label: s, anchorX: l * (s.width / a - 2 * r.scale[0]) + 2 * (.5 - l) * c, anchorY: h * s.height / a + 2 * (.5 - h) * c } }, t.prototype.execute_ = function (t, e, n, i, r, s, o) { var a, l, h; this.declutterItems.length = 0, this.pixelCoordinates_ && v(n, this.renderedTransform_) ? a = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), a = Pi(this.coordinates, 0, this.coordinates.length, 2, n, this.pixelCoordinates_), l = this.renderedTransform_, h = n, l[0] = h[0], l[1] = h[1], l[2] = h[2], l[3] = h[3], l[4] = h[4], l[5] = h[5]); for (var c, u, f, p, d, g, _, y, m, x, E, I, C, w, S, b, O, T = 0, R = i.length, N = 0, L = 0, P = 0, M = null, D = null, A = this.coordinateCache_, F = this.viewRotation_, k = Math.round(1e12 * Math.atan2(-n[1], n[0])) / 1e12, G = { context: t, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: F }, j = this.instructions != i || this.overlaps ? 0 : 200; T < R;) { var B = i[T]; switch (B[0]) { case hs.BEGIN_GEOMETRY: (S = B[1]).getGeometry() ? void 0 === o || Kt(o, B[3]) ? ++T : T = B[2] + 1 : T = B[2]; break; case hs.BEGIN_PATH: L > j && (this.fill_(t), L = 0), P > j && (t.stroke(), P = 0), L || P || (t.beginPath(), p = NaN, d = NaN), ++T; break; case hs.CIRCLE: var Y = a[N = B[1]], q = a[N + 1], X = a[N + 2] - Y, z = a[N + 3] - q, U = Math.sqrt(X * X + z * z); t.moveTo(Y + U, q), t.arc(Y, q, U, 0, 2 * Math.PI, !0), ++T; break; case hs.CLOSE_PATH: t.closePath(), ++T; break; case hs.CUSTOM: N = B[1], c = B[2]; var V = B[3], W = B[4], H = 6 == B.length ? B[5] : void 0; G.geometry = V, G.feature = S, T in A || (A[T] = []); var K = A[T]; H ? H(a, N, c, 2, K) : (K[0] = a[N], K[1] = a[N + 1], K.length = 2), W(K, G), ++T; break; case hs.DRAW_IMAGE: N = B[1], c = B[2], x = B[3], u = B[4], f = B[5], m = s ? null : B[6]; var Z = B[7], J = B[8], Q = B[9], $ = B[10], tt = B[11], et = B[12], nt = B[13], it = B[14]; if (!x && B.length >= 19) { E = B[18], I = B[19], C = B[20], w = B[21]; var rt = this.drawLabelWithPointPlacement_(E, I, C, w); x = rt.label, B[3] = x; var st = B[22]; u = (rt.anchorX - st) * this.pixelRatio, B[4] = u; var ot = B[23]; f = (rt.anchorY - ot) * this.pixelRatio, B[5] = f, Z = x.height, B[7] = Z, it = x.width, B[14] = it } var at = void 0; B.length > 24 && (at = B[24]); var lt = void 0, ht = void 0, ct = void 0; B.length > 16 ? (lt = B[15], ht = B[16], ct = B[17]) : (lt = oi, ht = !1, ct = !1), tt && k ? et += F : tt || k || (et -= F); for (var ut = 0, ft = 0; N < c; N += 2)if (!(at && at[ut++] < it / this.pixelRatio)) { if (m) { var pt = Math.floor(ft); y = m.length < pt + 1 ? [m[0][0]] : m[pt] } (Lt = this.replayImageOrLabel_(t, e, a[N], a[N + 1], x, u, f, y, Z, J, Q, $, et, nt, r, it, lt, ht ? M : null, ct ? D : null)) && y && m[m.length - 1] !== y && m.push(y), y && (y.length - 1 === y[0] && this.declutterItems.push(this, y, S), ft += 1 / y[0]) } ++T; break; case hs.DRAW_CHARS: var dt = B[1], gt = B[2], _t = B[3]; y = s ? null : B[4]; var yt = B[5]; w = B[6]; var mt = B[7], vt = B[8], xt = B[9]; C = B[10]; var Et = B[11]; E = B[12], I = B[13]; var It = [B[14], B[14]], Ct = this.textStates[I], wt = Ct.font, St = [Ct.scale[0] * vt, Ct.scale[1] * vt], bt = void 0; wt in this.widths_ ? bt = this.widths_[wt] : (bt = {}, this.widths_[wt] = bt); var Ot = yr(a, dt, gt, 2), Tt = Math.abs(St[0]) * yi(wt, E, bt); if (yt || Tt <= Ot) { var Rt = this.textStates[I].textAlign, Nt = ks(a, dt, gt, 2, E, (Ot - Tt) * Is[Rt], mt, Math.abs(St[0]), yi, wt, bt, k ? 0 : this.viewRotation_); if (Nt) { var Lt = !1, Pt = void 0, Mt = void 0, Dt = void 0, At = void 0, Ft = void 0; if (C) for (Pt = 0, Mt = Nt.length; Pt < Mt; ++Pt)Dt = (Ft = Nt[Pt])[4], At = this.createLabel(Dt, I, "", C), u = Ft[2] + Et, f = _t * At.height + 2 * (.5 - _t) * Et * St[1] / St[0] - xt, Lt = this.replayImageOrLabel_(t, e, Ft[0], Ft[1], At, u, f, y, At.height, 1, 0, 0, Ft[3], It, !1, At.width, oi, null, null) || Lt; if (w) for (Pt = 0, Mt = Nt.length; Pt < Mt; ++Pt)Dt = (Ft = Nt[Pt])[4], At = this.createLabel(Dt, I, w, ""), u = Ft[2], f = _t * At.height - xt, Lt = this.replayImageOrLabel_(t, e, Ft[0], Ft[1], At, u, f, y, At.height, 1, 0, 0, Ft[3], It, !1, At.width, oi, null, null) || Lt; Lt && this.declutterItems.push(this, y, S) } } ++T; break; case hs.END_GEOMETRY: if (void 0 !== s) { var kt = s(S = B[1]); if (kt) return kt } ++T; break; case hs.FILL: j ? L++ : this.fill_(t), ++T; break; case hs.MOVE_TO_LINE_TO: for (N = B[1], c = B[2], b = a[N], _ = (O = a[N + 1]) + .5 | 0, (g = b + .5 | 0) === p && _ === d || (t.moveTo(b, O), p = g, d = _), N += 2; N < c; N += 2)g = (b = a[N]) + .5 | 0, _ = (O = a[N + 1]) + .5 | 0, N != c - 2 && g === p && _ === d || (t.lineTo(b, O), p = g, d = _); ++T; break; case hs.SET_FILL_STYLE: M = B, this.alignFill_ = B[2], L && (this.fill_(t), L = 0, P && (t.stroke(), P = 0)), t.fillStyle = B[1], ++T; break; case hs.SET_STROKE_STYLE: D = B, P && (t.stroke(), P = 0), this.setStrokeStyle_(t, B), ++T; break; case hs.STROKE: j ? P++ : t.stroke(), ++T; break; default: ++T } } L && this.fill_(t), P && t.stroke() }, t.prototype.execute = function (t, e, n, i, r) { this.viewRotation_ = i, this.execute_(t, e, n, this.instructions, r, void 0, void 0) }, t.prototype.executeHitDetection = function (t, e, n, i, r) { return this.viewRotation_ = n, this.execute_(t, 1, e, this.hitDetectionInstructions, !0, i, r) }, t }(), Us = [As, Ls, Ds, Ms, Fs, Ps], Vs = function () { function t(t, e, n, i, r, s) { this.maxExtent_ = t, this.overlaps_ = i, this.pixelRatio_ = n, this.resolution_ = e, this.renderBuffer_ = s, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = [1, 0, 0, 1, 0, 0], this.createExecutors_(r) } return t.prototype.clip = function (t, e) { var n = this.getClipCoords(e); t.beginPath(), t.moveTo(n[0], n[1]), t.lineTo(n[2], n[3]), t.lineTo(n[4], n[5]), t.lineTo(n[6], n[7]), t.clip() }, t.prototype.createExecutors_ = function (t) { for (var e in t) { var n = this.executorsByZIndex_[e]; void 0 === n && (n = {}, this.executorsByZIndex_[e] = n); var i = t[e], r = [this.renderBuffer_ || 0, this.renderBuffer_ || 0]; for (var s in i) { var o = i[s]; n[s] = new zs(this.resolution_, this.pixelRatio_, this.overlaps_, o, r) } } }, t.prototype.hasExecutors = function (t) { for (var e in this.executorsByZIndex_) for (var n = this.executorsByZIndex_[e], i = 0, r = t.length; i < r; ++i)if (t[i] in n) return !0; return !1 }, t.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r, s) { var o = 2 * (i = Math.round(i)) + 1, a = ni(this.hitDetectionTransform_, i + .5, i + .5, 1 / e, -1 / e, -n, -t[0], -t[1]); this.hitDetectionContext_ || (this.hitDetectionContext_ = it(o, o)); var l, h = this.hitDetectionContext_; h.canvas.width !== o || h.canvas.height !== o ? (h.canvas.width = o, h.canvas.height = o) : h.clearRect(0, 0, o, o), void 0 !== this.renderBuffer_ && (Gt(l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], t), Ot(l, e * (this.renderBuffer_ + i), l)); var c, u = function (t) { if (void 0 !== Ws[t]) return Ws[t]; for (var e = 2 * t + 1, n = new Array(e), i = 0; i < e; i++)n[i] = new Array(e); var r = t, s = 0, o = 0; for (; r >= s;)Hs(n, t + r, t + s), Hs(n, t + s, t + r), Hs(n, t - s, t + r), Hs(n, t - r, t + s), Hs(n, t - r, t - s), Hs(n, t - s, t - r), Hs(n, t + s, t - r), Hs(n, t + r, t - s), s++, 2 * ((o += 1 + 2 * s) - r) + 1 > 0 && (o += 1 - 2 * (r -= 1)); return Ws[t] = n, n }(i); function f(t) { for (var e = h.getImageData(0, 0, o, o).data, n = 0; n < o; n++)for (var i = 0; i < o; i++)if (u[n][i] && e[4 * (i * o + n) + 3] > 0) { var a = void 0; return (!s || c != Ms && c != Fs || -1 !== s.indexOf(t)) && (a = r(t)), a || void h.clearRect(0, 0, o, o) } } var p, d, _, y, m, v = Object.keys(this.executorsByZIndex_).map(Number); for (v.sort(g), p = v.length - 1; p >= 0; --p) { var x = v[p].toString(); for (_ = this.executorsByZIndex_[x], d = Us.length - 1; d >= 0; --d)if (void 0 !== (y = _[c = Us[d]]) && (m = y.executeHitDetection(h, a, n, f, l))) return m } }, t.prototype.getClipCoords = function (t) { var e = this.maxExtent_; if (!e) return null; var n = e[0], i = e[1], r = e[2], s = e[3], o = [n, i, n, s, r, s, r, i]; return Pi(o, 0, 8, 2, t, o), o }, t.prototype.isEmpty = function () { return b(this.executorsByZIndex_) }, t.prototype.execute = function (t, e, n, i, r, s, o) { var a = Object.keys(this.executorsByZIndex_).map(Number); a.sort(g), this.maxExtent_ && (t.save(), this.clip(t, n)); var l, h, c, u, f, p, d = s || Us; for (l = 0, h = a.length; l < h; ++l) { var _ = a[l].toString(); for (f = this.executorsByZIndex_[_], c = 0, u = d.length; c < u; ++c) { var y = d[c]; if (void 0 !== (p = f[y])) if (!o || y != Ms && y != Fs) p.execute(t, e, n, i, r); else { var m = o[_]; m ? m.push(p, n.slice(0)) : o[_] = [p, n.slice(0)] } } } this.maxExtent_ && t.restore() }, t }(), Ws = { 0: [[!0]] }; function Hs(t, e, n) { var i, r = Math.floor(t.length / 2); if (e >= r) for (i = r; i < e; i++)t[i][n] = !0; else if (e < r) for (i = e + 1; i < r; i++)t[i][n] = !0 } var Ks = Vs, Zs = 0, Js = 1, Qs = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), $s = function (t) { function e(e, n, i, r, s, o, a) { var l = t.call(this) || this; return l.context_ = e, l.pixelRatio_ = n, l.extent_ = i, l.transform_ = r, l.viewRotation_ = s, l.squaredTolerance_ = o, l.userTransform_ = a, l.contextFillState_ = null, l.contextStrokeState_ = null, l.contextTextState_ = null, l.fillState_ = null, l.strokeState_ = null, l.image_ = null, l.imageAnchorX_ = 0, l.imageAnchorY_ = 0, l.imageHeight_ = 0, l.imageOpacity_ = 0, l.imageOriginX_ = 0, l.imageOriginY_ = 0, l.imageRotateWithView_ = !1, l.imageRotation_ = 0, l.imageScale_ = [0, 0], l.imageWidth_ = 0, l.text_ = "", l.textOffsetX_ = 0, l.textOffsetY_ = 0, l.textRotateWithView_ = !1, l.textRotation_ = 0, l.textScale_ = [0, 0], l.textFillState_ = null, l.textStrokeState_ = null, l.textState_ = null, l.pixelCoordinates_ = [], l.tmpLocalTransform_ = [1, 0, 0, 1, 0, 0], l } return Qs(e, t), e.prototype.drawImages_ = function (t, e, n, i) { if (this.image_) { var r = Pi(t, e, n, 2, this.transform_, this.pixelCoordinates_), s = this.context_, o = this.tmpLocalTransform_, a = s.globalAlpha; 1 != this.imageOpacity_ && (s.globalAlpha = a * this.imageOpacity_); var l = this.imageRotation_; this.imageRotateWithView_ && (l += this.viewRotation_); for (var h = 0, c = r.length; h < c; h += 2) { var u = r[h] - this.imageAnchorX_, f = r[h + 1] - this.imageAnchorY_; if (0 !== l || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) { var p = u + this.imageAnchorX_, d = f + this.imageAnchorY_; ni(o, p, d, 1, 1, l, -p, -d), s.setTransform.apply(s, o), s.translate(p, d), s.scale(this.imageScale_[0], this.imageScale_[1]), s.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_), s.setTransform(1, 0, 0, 1, 0, 0) } else s.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, u, f, this.imageWidth_, this.imageHeight_) } 1 != this.imageOpacity_ && (s.globalAlpha = a) } }, e.prototype.drawText_ = function (t, e, n, i) { if (this.textState_ && "" !== this.text_) { this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_); var r = Pi(t, e, n, i, this.transform_, this.pixelCoordinates_), s = this.context_, o = this.textRotation_; for (this.textRotateWithView_ && (o += this.viewRotation_); e < n; e += i) { var a = r[e] + this.textOffsetX_, l = r[e + 1] + this.textOffsetY_; if (0 !== o || 1 != this.textScale_[0] || 1 != this.textScale_[1]) { var h = ni(this.tmpLocalTransform_, a, l, 1, 1, o, -a, -l); s.setTransform.apply(s, h), s.translate(a, l), s.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && s.strokeText(this.text_, 0, 0), this.textFillState_ && s.fillText(this.text_, 0, 0), s.setTransform(1, 0, 0, 1, 0, 0) } else this.textStrokeState_ && s.strokeText(this.text_, a, l), this.textFillState_ && s.fillText(this.text_, a, l) } } }, e.prototype.moveToLineTo_ = function (t, e, n, i, r) { var s = this.context_, o = Pi(t, e, n, i, this.transform_, this.pixelCoordinates_); s.moveTo(o[0], o[1]); var a = o.length; r && (a -= 2); for (var l = 2; l < a; l += 2)s.lineTo(o[l], o[l + 1]); return r && s.closePath(), n }, e.prototype.drawRings_ = function (t, e, n, i) { for (var r = 0, s = n.length; r < s; ++r)e = this.moveToLineTo_(t, e, n[r], i, !0); return e }, e.prototype.drawCircle = function (t) { if (Kt(this.extent_, t.getExtent())) { if (this.fillState_ || this.strokeState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); var e = function (t, e, n) { var i = t.getFlatCoordinates(); if (i) { var r = t.getStride(); return Pi(i, 0, i.length, r, e, n) } return null }(t, this.transform_, this.pixelCoordinates_), n = e[2] - e[0], i = e[3] - e[1], r = Math.sqrt(n * n + i * i), s = this.context_; s.beginPath(), s.arc(e[0], e[1], r, 0, 2 * Math.PI), this.fillState_ && s.fill(), this.strokeState_ && s.stroke() } "" !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2) } }, e.prototype.setStyle = function (t) { this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText()) }, e.prototype.setTransform = function (t) { this.transform_ = t }, e.prototype.drawGeometry = function (t) { switch (t.getType()) { case be: this.drawPoint(t); break; case Oe: this.drawLineString(t); break; case Re: this.drawPolygon(t); break; case Ne: this.drawMultiPoint(t); break; case Le: this.drawMultiLineString(t); break; case Pe: this.drawMultiPolygon(t); break; case Me: this.drawGeometryCollection(t); break; case De: this.drawCircle(t) } }, e.prototype.drawFeature = function (t, e) { var n = e.getGeometryFunction()(t); n && Kt(this.extent_, n.getExtent()) && (this.setStyle(e), this.drawGeometry(n)) }, e.prototype.drawGeometryCollection = function (t) { for (var e = t.getGeometriesArray(), n = 0, i = e.length; n < i; ++n)this.drawGeometry(e[n]) }, e.prototype.drawPoint = function (t) { this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)); var e = t.getFlatCoordinates(), n = t.getStride(); this.image_ && this.drawImages_(e, 0, e.length, n), "" !== this.text_ && this.drawText_(e, 0, e.length, n) }, e.prototype.drawMultiPoint = function (t) { this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)); var e = t.getFlatCoordinates(), n = t.getStride(); this.image_ && this.drawImages_(e, 0, e.length, n), "" !== this.text_ && this.drawText_(e, 0, e.length, n) }, e.prototype.drawLineString = function (t) { if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), Kt(this.extent_, t.getExtent())) { if (this.strokeState_) { this.setContextStrokeState_(this.strokeState_); var e = this.context_, n = t.getFlatCoordinates(); e.beginPath(), this.moveToLineTo_(n, 0, n.length, t.getStride(), !1), e.stroke() } if ("" !== this.text_) { var i = t.getFlatMidpoint(); this.drawText_(i, 0, 2, 2) } } }, e.prototype.drawMultiLineString = function (t) { this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)); var e = t.getExtent(); if (Kt(this.extent_, e)) { if (this.strokeState_) { this.setContextStrokeState_(this.strokeState_); var n = this.context_, i = t.getFlatCoordinates(), r = 0, s = t.getEnds(), o = t.getStride(); n.beginPath(); for (var a = 0, l = s.length; a < l; ++a)r = this.moveToLineTo_(i, r, s[a], o, !1); n.stroke() } if ("" !== this.text_) { var h = t.getFlatMidpoints(); this.drawText_(h, 0, h.length, 2) } } }, e.prototype.drawPolygon = function (t) { if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), Kt(this.extent_, t.getExtent())) { if (this.strokeState_ || this.fillState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); var e = this.context_; e.beginPath(), this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()), this.fillState_ && e.fill(), this.strokeState_ && e.stroke() } if ("" !== this.text_) { var n = t.getFlatInteriorPoint(); this.drawText_(n, 0, 2, 2) } } }, e.prototype.drawMultiPolygon = function (t) { if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), Kt(this.extent_, t.getExtent())) { if (this.strokeState_ || this.fillState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); var e = this.context_, n = t.getOrientedFlatCoordinates(), i = 0, r = t.getEndss(), s = t.getStride(); e.beginPath(); for (var o = 0, a = r.length; o < a; ++o) { var l = r[o]; i = this.drawRings_(n, i, l, s) } this.fillState_ && e.fill(), this.strokeState_ && e.stroke() } if ("" !== this.text_) { var h = t.getFlatInteriorPoints(); this.drawText_(h, 0, h.length, 2) } } }, e.prototype.setContextFillState_ = function (t) { var e = this.context_, n = this.contextFillState_; n ? n.fillStyle != t.fillStyle && (n.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = { fillStyle: t.fillStyle }) }, e.prototype.setContextStrokeState_ = function (t) { var e = this.context_, n = this.contextStrokeState_; n ? (n.lineCap != t.lineCap && (n.lineCap = t.lineCap, e.lineCap = t.lineCap), e.setLineDash && (v(n.lineDash, t.lineDash) || e.setLineDash(n.lineDash = t.lineDash), n.lineDashOffset != t.lineDashOffset && (n.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset)), n.lineJoin != t.lineJoin && (n.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), n.lineWidth != t.lineWidth && (n.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), n.miterLimit != t.miterLimit && (n.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), n.strokeStyle != t.strokeStyle && (n.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = { lineCap: t.lineCap, lineDash: t.lineDash, lineDashOffset: t.lineDashOffset, lineJoin: t.lineJoin, lineWidth: t.lineWidth, miterLimit: t.miterLimit, strokeStyle: t.strokeStyle }) }, e.prototype.setContextTextState_ = function (t) { var e = this.context_, n = this.contextTextState_, i = t.textAlign ? t.textAlign : "center"; n ? (n.font != t.font && (n.font = t.font, e.font = t.font), n.textAlign != i && (n.textAlign = i, e.textAlign = i), n.textBaseline != t.textBaseline && (n.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = i, e.textBaseline = t.textBaseline, this.contextTextState_ = { font: t.font, textAlign: i, textBaseline: t.textBaseline }) }, e.prototype.setFillStrokeStyle = function (t, e) { if (t) { var n = t.getColor(); this.fillState_ = { fillStyle: Zn(n || "#000") } } else this.fillState_ = null; if (e) { var i = e.getColor(), r = e.getLineCap(), s = e.getLineDash(), o = e.getLineDashOffset(), a = e.getLineJoin(), l = e.getWidth(), h = e.getMiterLimit(); this.strokeState_ = { lineCap: void 0 !== r ? r : "round", lineDash: s || si, lineDashOffset: o || 0, lineJoin: void 0 !== a ? a : "round", lineWidth: this.pixelRatio_ * (void 0 !== l ? l : 1), miterLimit: void 0 !== h ? h : 10, strokeStyle: Zn(i || "#000") } } else this.strokeState_ = null }, e.prototype.setImageStyle = function (t) { if (t) { var e = t.getSize(); if (e) { var n = t.getAnchor(), i = t.getImage(1), r = t.getOrigin(), s = t.getScaleArray(); this.imageAnchorX_ = n[0], this.imageAnchorY_ = n[1], this.imageHeight_ = e[1], this.image_ = i, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = r[0], this.imageOriginY_ = r[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation(), this.imageScale_ = [this.pixelRatio_ * s[0], this.pixelRatio_ * s[1]], this.imageWidth_ = e[0] } else this.image_ = null } else this.image_ = null }, e.prototype.setTextStyle = function (t) { if (t) { var e = t.getFill(); if (e) { var n = e.getColor(); this.textFillState_ = { fillStyle: Zn(n || "#000") } } else this.textFillState_ = null; var i = t.getStroke(); if (i) { var r = i.getColor(), s = i.getLineCap(), o = i.getLineDash(), a = i.getLineDashOffset(), l = i.getLineJoin(), h = i.getWidth(), c = i.getMiterLimit(); this.textStrokeState_ = { lineCap: void 0 !== s ? s : "round", lineDash: o || si, lineDashOffset: a || 0, lineJoin: void 0 !== l ? l : "round", lineWidth: void 0 !== h ? h : 1, miterLimit: void 0 !== c ? c : 10, strokeStyle: Zn(r || "#000") } } else this.textStrokeState_ = null; var u = t.getFont(), f = t.getOffsetX(), p = t.getOffsetY(), d = t.getRotateWithView(), g = t.getRotation(), _ = t.getScaleArray(), y = t.getText(), m = t.getTextAlign(), v = t.getTextBaseline(); this.textState_ = { font: void 0 !== u ? u : "10px sans-serif", textAlign: void 0 !== m ? m : "center", textBaseline: void 0 !== v ? v : "middle" }, this.text_ = void 0 !== y ? y : "", this.textOffsetX_ = void 0 !== f ? this.pixelRatio_ * f : 0, this.textOffsetY_ = void 0 !== p ? this.pixelRatio_ * p : 0, this.textRotateWithView_ = void 0 !== d && d, this.textRotation_ = void 0 !== g ? g : 0, this.textScale_ = [this.pixelRatio_ * _[0], this.pixelRatio_ * _[1]] } else this.text_ = "" }, e }(cs), to = "fraction", eo = "pixels", no = "bottom-left", io = "bottom-right", ro = "top-left", so = "top-right", oo = function () { function t() { this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32 } return t.prototype.clear = function () { this.cache_ = {}, this.cacheSize_ = 0 }, t.prototype.canExpireCache = function () { return this.cacheSize_ > this.maxCacheSize_ }, t.prototype.expire = function () { if (this.canExpireCache()) { var t = 0; for (var e in this.cache_) { var n = this.cache_[e]; 0 != (3 & t++) || n.hasListener() || (delete this.cache_[e], --this.cacheSize_) } } }, t.prototype.get = function (t, e, n) { var i = ao(t, e, n); return i in this.cache_ ? this.cache_[i] : null }, t.prototype.set = function (t, e, n, i) { var r = ao(t, e, n); this.cache_[r] = i, ++this.cacheSize_ }, t.prototype.setSize = function (t) { this.maxCacheSize_ = t, this.expire() }, t }(); function ao(t, e, n) { return e + ":" + t + ":" + (n ? function (t) { return "string" == typeof t ? t : Kn(t) }(n) : "null") } var lo = new oo, ho = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), co = function (t) { function e(e, n, i, r) { var s = t.call(this) || this; return s.extent = e, s.pixelRatio_ = i, s.resolution = n, s.state = r, s } return ho(e, t), e.prototype.changed = function () { this.dispatchEvent(R) }, e.prototype.getExtent = function () { return this.extent }, e.prototype.getImage = function () { return o() }, e.prototype.getPixelRatio = function () { return this.pixelRatio_ }, e.prototype.getResolution = function () { return this.resolution }, e.prototype.getState = function () { return this.state }, e.prototype.load = function () { o() }, e }(T), uo = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); function fo(t, e, n) { var i = t; if (i.src && nt) { var r = i.decode(), s = !0; return r.then((function () { s && e() })).catch((function (t) { s && ("EncodingError" === t.name && "Invalid image type." === t.message ? e() : n()) })), function () { s = !1 } } var o = [F(i, D, e), F(i, N, n)]; return function () { o.forEach(k) } } !function (t) { function e(e, n, i, r, s, o) { var a = t.call(this, e, n, i, An) || this; return a.src_ = r, a.image_ = new Image, null !== s && (a.image_.crossOrigin = s), a.unlisten_ = null, a.state = An, a.imageLoadFunction_ = o, a } uo(e, t), e.prototype.getImage = function () { return this.image_ }, e.prototype.handleImageError_ = function () { this.state = Gn, this.unlistenImage_(), this.changed() }, e.prototype.handleImageLoad_ = function () { void 0 === this.resolution && (this.resolution = Ut(this.extent) / this.image_.height), this.state = kn, this.unlistenImage_(), this.changed() }, e.prototype.load = function () { this.state != An && this.state != Gn || (this.state = Fn, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = fo(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this))) }, e.prototype.setImage = function (t) { this.image_ = t }, e.prototype.unlistenImage_ = function () { this.unlisten_ && (this.unlisten_(), this.unlisten_ = null) } }(co); var po = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), go = null, _o = function (t) { function e(e, n, i, r, s, o) { var a = t.call(this) || this; return a.hitDetectionImage_ = null, a.image_ = e || new Image, null !== r && (a.image_.crossOrigin = r), a.canvas_ = {}, a.color_ = o, a.unlisten_ = null, a.imageState_ = s, a.size_ = i, a.src_ = n, a.tainted_, a } return po(e, t), e.prototype.isTainted_ = function () { if (void 0 === this.tainted_ && this.imageState_ === kn) { go || (go = it(1, 1)), go.drawImage(this.image_, 0, 0); try { go.getImageData(0, 0, 1, 1), this.tainted_ = !1 } catch (t) { go = null, this.tainted_ = !0 } } return !0 === this.tainted_ }, e.prototype.dispatchChangeEvent_ = function () { this.dispatchEvent(R) }, e.prototype.handleImageError_ = function () { this.imageState_ = Gn, this.unlistenImage_(), this.dispatchChangeEvent_() }, e.prototype.handleImageLoad_ = function () { this.imageState_ = kn, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_() }, e.prototype.getImage = function (t) { return this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_ }, e.prototype.getPixelRatio = function (t) { return this.replaceColor_(t), this.canvas_[t] ? t : 1 }, e.prototype.getImageState = function () { return this.imageState_ }, e.prototype.getHitDetectionImage = function () { if (!this.hitDetectionImage_) if (this.isTainted_()) { var t = this.size_[0], e = this.size_[1], n = it(t, e); n.fillRect(0, 0, t, e), this.hitDetectionImage_ = n.canvas } else this.hitDetectionImage_ = this.image_; return this.hitDetectionImage_ }, e.prototype.getSize = function () { return this.size_ }, e.prototype.getSrc = function () { return this.src_ }, e.prototype.load = function () { if (this.imageState_ == An) { this.imageState_ = Fn; try { this.image_.src = this.src_ } catch (t) { this.handleImageError_() } this.unlisten_ = fo(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)) } }, e.prototype.replaceColor_ = function (t) { if (this.color_ && !this.canvas_[t]) { var e = document.createElement("canvas"); this.canvas_[t] = e, e.width = Math.ceil(this.image_.width * t), e.height = Math.ceil(this.image_.height * t); var n = e.getContext("2d"); if (n.scale(t, t), n.drawImage(this.image_, 0, 0), this.isTainted_()) { var i = this.color_; return n.globalCompositeOperation = "multiply", n.fillStyle = "rgb(" + i[0] + "," + i[1] + "," + i[2] + ")", n.fillRect(0, 0, e.width, e.height), n.globalCompositeOperation = "destination-in", void n.drawImage(this.image_, 0, 0) } for (var r = n.getImageData(0, 0, e.width, e.height), s = r.data, o = this.color_[0] / 255, a = this.color_[1] / 255, l = this.color_[2] / 255, h = 0, c = s.length; h < c; h += 4)s[h] *= o, s[h + 1] *= a, s[h + 2] *= l; n.putImageData(r, 0, 0) } }, e.prototype.unlistenImage_ = function () { this.unlisten_ && (this.unlisten_(), this.unlisten_ = null) }, e }(T); var yo = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), mo = function (t) { function e(e) { var n = this, i = e || {}, r = void 0 !== i.opacity ? i.opacity : 1, s = void 0 !== i.rotation ? i.rotation : 0, o = void 0 !== i.scale ? i.scale : 1, a = void 0 !== i.rotateWithView && i.rotateWithView; (n = t.call(this, { opacity: r, rotation: s, scale: o, displacement: void 0 !== i.displacement ? i.displacement : [0, 0], rotateWithView: a }) || this).anchor_ = void 0 !== i.anchor ? i.anchor : [.5, .5], n.normalizedAnchor_ = null, n.anchorOrigin_ = void 0 !== i.anchorOrigin ? i.anchorOrigin : ro, n.anchorXUnits_ = void 0 !== i.anchorXUnits ? i.anchorXUnits : to, n.anchorYUnits_ = void 0 !== i.anchorYUnits ? i.anchorYUnits : to, n.crossOrigin_ = void 0 !== i.crossOrigin ? i.crossOrigin : null; var h = void 0 !== i.img ? i.img : null, c = void 0 !== i.imgSize ? i.imgSize : null, u = i.src; St(!(void 0 !== u && h), 4), St(!h || h && c, 5), void 0 !== u && 0 !== u.length || !h || (u = h.src || l(h)), St(void 0 !== u && u.length > 0, 6); var f = void 0 !== i.src ? An : kn; return n.color_ = void 0 !== i.color ? Wn(i.color) : null, n.iconImage_ = function (t, e, n, i, r, s) { var o = lo.get(e, i, s); return o || (o = new _o(t, e, n, i, r, s), lo.set(e, i, s, o)), o }(h, u, c, n.crossOrigin_, f, n.color_), n.offset_ = void 0 !== i.offset ? i.offset : [0, 0], n.offsetOrigin_ = void 0 !== i.offsetOrigin ? i.offsetOrigin : ro, n.origin_ = null, n.size_ = void 0 !== i.size ? i.size : null, n } return yo(e, t), e.prototype.clone = function () { var t = this.getScale(); return new e({ anchor: this.anchor_.slice(), anchorOrigin: this.anchorOrigin_, anchorXUnits: this.anchorXUnits_, anchorYUnits: this.anchorYUnits_, crossOrigin: this.crossOrigin_, color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0, src: this.getSrc(), offset: this.offset_.slice(), offsetOrigin: this.offsetOrigin_, size: null !== this.size_ ? this.size_.slice() : void 0, opacity: this.getOpacity(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView() }) }, e.prototype.getAnchor = function () { if (this.normalizedAnchor_) return this.normalizedAnchor_; var t = this.anchor_, e = this.getSize(); if (this.anchorXUnits_ == to || this.anchorYUnits_ == to) { if (!e) return null; t = this.anchor_.slice(), this.anchorXUnits_ == to && (t[0] *= e[0]), this.anchorYUnits_ == to && (t[1] *= e[1]) } if (this.anchorOrigin_ != ro) { if (!e) return null; t === this.anchor_ && (t = this.anchor_.slice()), this.anchorOrigin_ != so && this.anchorOrigin_ != io || (t[0] = -t[0] + e[0]), this.anchorOrigin_ != no && this.anchorOrigin_ != io || (t[1] = -t[1] + e[1]) } return this.normalizedAnchor_ = t, this.normalizedAnchor_ }, e.prototype.setAnchor = function (t) { this.anchor_ = t, this.normalizedAnchor_ = null }, e.prototype.getColor = function () { return this.color_ }, e.prototype.getImage = function (t) { return this.iconImage_.getImage(t) }, e.prototype.getPixelRatio = function (t) { return this.iconImage_.getPixelRatio(t) }, e.prototype.getImageSize = function () { return this.iconImage_.getSize() }, e.prototype.getHitDetectionImageSize = function () { return this.getImageSize() }, e.prototype.getImageState = function () { return this.iconImage_.getImageState() }, e.prototype.getHitDetectionImage = function () { return this.iconImage_.getHitDetectionImage() }, e.prototype.getOrigin = function () { if (this.origin_) return this.origin_; var t = this.offset_, e = this.getDisplacement(); if (this.offsetOrigin_ != ro) { var n = this.getSize(), i = this.iconImage_.getSize(); if (!n || !i) return null; t = t.slice(), this.offsetOrigin_ != so && this.offsetOrigin_ != io || (t[0] = i[0] - n[0] - t[0]), this.offsetOrigin_ != no && this.offsetOrigin_ != io || (t[1] = i[1] - n[1] - t[1]) } return t[0] += e[0], t[1] += e[1], this.origin_ = t, this.origin_ }, e.prototype.getSrc = function () { return this.iconImage_.getSrc() }, e.prototype.getSize = function () { return this.size_ ? this.size_ : this.iconImage_.getSize() }, e.prototype.listenImageChange = function (t) { this.iconImage_.addEventListener(R, t) }, e.prototype.load = function () { this.iconImage_.load() }, e.prototype.unlistenImageChange = function (t) { this.iconImage_.removeEventListener(R, t) }, e }(Bn); var vo = { Point: function (t, e, n, i) { var r = n.getImage(); if (r) { if (r.getImageState() != kn) return; var s = t.getBuilder(n.getZIndex(), Ms); s.setImageStyle(r, t.addDeclutter(!1)), s.drawPoint(e, i) } var o = n.getText(); if (o) { var a = t.getBuilder(n.getZIndex(), Fs); a.setTextStyle(o, t.addDeclutter(!!r)), a.drawText(e, i) } }, LineString: function (t, e, n, i) { var r = n.getStroke(); if (r) { var s = t.getBuilder(n.getZIndex(), Ds); s.setFillStrokeStyle(null, r), s.drawLineString(e, i) } var o = n.getText(); if (o) { var a = t.getBuilder(n.getZIndex(), Fs); a.setTextStyle(o, t.addDeclutter(!1)), a.drawText(e, i) } }, Polygon: function (t, e, n, i) { var r = n.getFill(), s = n.getStroke(); if (r || s) { var o = t.getBuilder(n.getZIndex(), As); o.setFillStrokeStyle(r, s), o.drawPolygon(e, i) } var a = n.getText(); if (a) { var l = t.getBuilder(n.getZIndex(), Fs); l.setTextStyle(a, t.addDeclutter(!1)), l.drawText(e, i) } }, MultiPoint: function (t, e, n, i) { var r = n.getImage(); if (r) { if (r.getImageState() != kn) return; var s = t.getBuilder(n.getZIndex(), Ms); s.setImageStyle(r, t.addDeclutter(!1)), s.drawMultiPoint(e, i) } var o = n.getText(); if (o) { var a = t.getBuilder(n.getZIndex(), Fs); a.setTextStyle(o, t.addDeclutter(!!r)), a.drawText(e, i) } }, MultiLineString: function (t, e, n, i) { var r = n.getStroke(); if (r) { var s = t.getBuilder(n.getZIndex(), Ds); s.setFillStrokeStyle(null, r), s.drawMultiLineString(e, i) } var o = n.getText(); if (o) { var a = t.getBuilder(n.getZIndex(), Fs); a.setTextStyle(o, t.addDeclutter(!1)), a.drawText(e, i) } }, MultiPolygon: function (t, e, n, i) { var r = n.getFill(), s = n.getStroke(); if (s || r) { var o = t.getBuilder(n.getZIndex(), As); o.setFillStrokeStyle(r, s), o.drawMultiPolygon(e, i) } var a = n.getText(); if (a) { var l = t.getBuilder(n.getZIndex(), Fs); l.setTextStyle(a, t.addDeclutter(!1)), l.drawText(e, i) } }, GeometryCollection: function (t, e, n, i) { var r, s, o = e.getGeometriesArray(); for (r = 0, s = o.length; r < s; ++r) { (0, vo[o[r].getType()])(t, o[r], n, i) } }, Circle: function (t, e, n, i) { var r = n.getFill(), s = n.getStroke(); if (r || s) { var o = t.getBuilder(n.getZIndex(), Ls); o.setFillStrokeStyle(r, s), o.drawCircle(e, i) } var a = n.getText(); if (a) { var l = t.getBuilder(n.getZIndex(), Fs); l.setTextStyle(a, t.addDeclutter(!1)), l.drawText(e, i) } } }; function xo(t, e) { return parseInt(l(t), 10) - parseInt(l(e), 10) } function Eo(t, e) { return .5 * t / e } function Io(t, e, n, i, r, s) { var o = !1, a = n.getImage(); if (a) { var l = a.getImageState(); l == kn || l == Gn ? a.unlistenImageChange(r) : (l == An && a.load(), l = a.getImageState(), a.listenImageChange(r), o = !0) } return function (t, e, n, i, r) { var s = n.getGeometryFunction()(e); if (!s) return; var o = s.simplifyTransformed(i, r); if (n.getRenderer()) !function t(e, n, i, r) { if (n.getType() == Me) { for (var s = n.getGeometries(), o = 0, a = s.length; o < a; ++o)t(e, s[o], i, r); return } e.getBuilder(i.getZIndex(), Ps).drawCustom(n, r, i.getRenderer()) }(t, o, n, e); else { (0, vo[o.getType()])(t, o, n, e) } }(t, e, n, i, s), o } var Co = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), wo = function (t) { function e(e) { var n = t.call(this, e) || this; return n.boundHandleStyleImageChange_ = n.handleStyleImageChange_.bind(n), n.animatingOrInteracting_, n.dirty_ = !1, n.hitDetectionImageData_ = null, n.renderedFeatures_ = null, n.renderedRevision_ = -1, n.renderedResolution_ = NaN, n.renderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n.renderedRotation_, n.renderedCenter_ = null, n.renderedProjection_ = null, n.renderedRenderOrder_ = null, n.replayGroup_ = null, n.replayGroupChanged = !0, n.clipping = !0, n } return Co(e, t), e.prototype.useContainer = function (e, n, i) { i < 1 && (e = null), t.prototype.useContainer.call(this, e, n, i) }, e.prototype.renderFrame = function (t, e) { var n = t.pixelRatio, i = t.layerStatesArray[t.layerIndex]; !function (t, e, n) { ti(t, e, 0, 0, n, 0, 0) }(this.pixelTransform, 1 / n, 1 / n), ii(this.inversePixelTransform, this.pixelTransform); var r = ri(this.pixelTransform); this.useContainer(e, r, i.opacity); var s = this.context, o = s.canvas, a = this.replayGroup_; if (!a || a.isEmpty()) return !this.containerReused && o.width > 0 && (o.width = 0), this.container; var l = Math.round(t.size[0] * n), h = Math.round(t.size[1] * n); o.width != l || o.height != h ? (o.width = l, o.height = h, o.style.transform !== r && (o.style.transform = r)) : this.containerReused || s.clearRect(0, 0, l, h), this.preRender(s, t); var c = t.extent, u = t.viewState, f = u.center, p = u.resolution, d = u.projection, _ = u.rotation, y = d.getExtent(), m = this.getLayer().getSource(), v = !1; if (i.extent && this.clipping) { var x = sn(i.extent, d); (v = !Rt(x, t.extent) && Kt(x, t.extent)) && this.clipUnrotated(s, t, x) } var E = t.viewHints, I = !(E[Zs] || E[Js]), C = this.getRenderTransform(f, p, _, n, l, h, 0), w = this.getLayer().getDeclutter() ? {} : null; if (a.execute(s, 1, C, _, I, void 0, w), m.getWrapX() && d.canWrapX() && !Rt(y, c)) { for (var S = c[0], b = Ht(y), O = 0, T = void 0; S < y[0];) { T = b * --O; var R = this.getRenderTransform(f, p, _, n, l, h, T); a.execute(s, 1, R, _, I, void 0, w), S += b } for (O = 0, S = c[2]; S > y[2];) { T = b * ++O; var N = this.getRenderTransform(f, p, _, n, l, h, T); a.execute(s, 1, N, _, I, void 0, w), S -= b } } if (w) { var L = t.viewHints; !function (t, e, n, i, r, s) { for (var o = Object.keys(t).map(Number).sort(g), a = 0, l = o.length; a < l; ++a)for (var h = t[o[a].toString()], c = void 0, u = 0, f = h.length; u < f;) { var p = h[u++], d = h[u++]; p.execute(e, 1, d, n, r), p !== c && p.declutterItems.length > 0 && (c = p, s.push({ items: p.declutterItems, opacity: i })) } }(w, s, _, 1, !(L[Zs] || L[Js]), t.declutterItems) } v && s.restore(), this.postRender(s, t); var P = i.opacity, M = this.container; return P !== parseFloat(M.style.opacity) && (M.style.opacity = 1 === P ? "" : String(P)), this.renderedRotation_ !== u.rotation && (this.renderedRotation_ = u.rotation, this.hitDetectionImageData_ = null), this.container }, e.prototype.getFeatures = function (t) { return new Promise(function (e, n) { if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) { var i = [this.context.canvas.width, this.context.canvas.height]; ei(this.pixelTransform, i); var r = this.renderedCenter_, s = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, l = this.renderedExtent_, h = this.getLayer(), c = [], u = i[0] / 2, f = i[1] / 2; c.push(this.getRenderTransform(r, s, o, .5, u, f, 0).slice()); var p = h.getSource(), d = a.getExtent(); if (p.getWrapX() && a.canWrapX() && !Rt(d, l)) { for (var _ = l[0], y = Ht(d), m = 0, v = void 0; _ < d[0];)v = y * --m, c.push(this.getRenderTransform(r, s, o, .5, u, f, v).slice()), _ += y; for (m = 0, _ = l[2]; _ > d[2];)v = y * ++m, c.push(this.getRenderTransform(r, s, o, .5, u, f, v).slice()), _ -= y } this.hitDetectionImageData_ = function (t, e, n, i, r, s, o) { var a = it(t[0] / 2, t[1] / 2); a.imageSmoothingEnabled = !1; for (var l = a.canvas, h = new $s(a, .5, r, null, o), c = n.length, u = Math.floor(16777215 / c), f = {}, p = 1; p <= c; ++p) { var d = n[p - 1], _ = d.getStyleFunction() || i; if (i) { var y = _(d, s); if (y) { Array.isArray(y) || (y = [y]); for (var m = "#" + ("000000" + (p * u).toString(16)).slice(-6), v = 0, x = y.length; v < x; ++v) { var E = y[v], I = E.clone(), C = I.getFill(); C && C.setColor(m); var w = I.getStroke(); w && w.setColor(m), I.setText(void 0); var S = E.getImage(); if (S) { var b = S.getImageSize(); if (!b) continue; var O = document.createElement("canvas"); O.width = b[0], O.height = b[1]; var T = O.getContext("2d", { alpha: !1 }); T.fillStyle = m; var R = T.canvas; T.fillRect(0, 0, R.width, R.height), it(b ? b[0] : R.width, b ? b[1] : R.height).drawImage(R, 0, 0), I.setImage(new mo({ img: R, imgSize: b, anchor: S.getAnchor(), anchorXUnits: eo, anchorYUnits: eo, offset: S.getOrigin(), size: S.getSize(), opacity: S.getOpacity(), scale: S.getScale(), rotation: S.getRotation(), rotateWithView: S.getRotateWithView() })) } var N = Number(I.getZIndex()); (D = f[N]) || (D = {}, f[N] = D, D[Re] = [], D[De] = [], D[Oe] = [], D[be] = []); var L = I.getGeometryFunction()(d); L && Kt(r, L.getExtent()) && D[L.getType().replace("Multi", "")].push(L, I) } } } } for (var P = Object.keys(f).map(Number).sort(g), M = (p = 0, P.length); p < M; ++p) { var D = f[P[p]]; for (var A in D) { var F = D[A]; for (v = 0, x = F.length; v < x; v += 2) { h.setStyle(F[v + 1]); for (var k = 0, G = e.length; k < G; ++k)h.setTransform(e[k]), h.drawGeometry(F[v]) } } } return a.getImageData(0, 0, l.width, l.height) }(i, c, this.renderedFeatures_, h.getStyleFunction(), l, s, o) } e(function (t, e, n) { var i = []; if (n) { var r = 4 * (Math.round(t[0] / 2) + Math.round(t[1] / 2) * n.width), s = n.data[r], o = n.data[r + 1], a = n.data[r + 2] + 256 * (o + 256 * s), l = Math.floor(16777215 / e.length); a && a % l == 0 && i.push(e[a / l - 1]) } return i }(t, this.renderedFeatures_, this.hitDetectionImageData_)) }.bind(this)) }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r) { if (this.replayGroup_) { var s = e.viewState.resolution, o = e.viewState.rotation, a = this.getLayer(), h = {}; return this.replayGroup_.forEachFeatureAtCoordinate(t, s, o, n, (function (t) { var e = l(t); if (!(e in h)) return h[e] = !0, i(t, a) }), a.getDeclutter() ? r : null) } }, e.prototype.handleFontsChanged = function () { var t = this.getLayer(); t.getVisible() && this.replayGroup_ && t.changed() }, e.prototype.handleStyleImageChange_ = function (t) { this.renderIfReadyAndVisible() }, e.prototype.prepareFrame = function (t) { var e = this.getLayer(), n = e.getSource(); if (!n) return !1; var i = t.viewHints[Zs], r = t.viewHints[Js], s = e.getUpdateWhileAnimating(), o = e.getUpdateWhileInteracting(); if (!this.dirty_ && !s && i || !o && r) return this.animatingOrInteracting_ = !0, !0; this.animatingOrInteracting_ = !1; var a = t.extent, l = t.viewState, h = l.projection, c = l.resolution, u = t.pixelRatio, f = e.getRevision(), p = e.getRenderBuffer(), d = e.getRenderOrder(); void 0 === d && (d = xo); var g = l.center.slice(), _ = Ot(a, p * c), y = [_.slice()], m = h.getExtent(); if (n.getWrapX() && h.canWrapX() && !Rt(m, t.extent)) { var v = Ht(m), x = Math.max(Ht(_) / 2, v); _[0] = m[0] - x, _[2] = m[2] + x, function (t, e) { if (e.canWrapX()) { var n = Ht(e.getExtent()), i = Be(t, e, n); i && (t[0] -= i * n) } }(g, h); var E = function (t, e) { var n = e.getExtent(), i = zt(t); if (e.canWrapX() && (i[0] < n[0] || i[0] >= n[2])) { var r = Ht(n), s = Math.floor((i[0] - n[0]) / r) * r; t[0] -= s, t[2] -= s } return t }(y[0], h); E[0] < m[0] && E[2] < m[2] ? y.push([E[0] + v, E[1], E[2] + v, E[3]]) : E[0] > m[0] && E[2] > m[2] && y.push([E[0] - v, E[1], E[2] - v, E[3]]) } if (!this.dirty_ && this.renderedResolution_ == c && this.renderedRevision_ == f && this.renderedRenderOrder_ == d && Rt(this.renderedExtent_, _)) return this.replayGroupChanged = !1, !0; this.replayGroup_ = null, this.dirty_ = !1; var I, C = new ws(Eo(c, u), _, c, u, e.getDeclutter()), w = tn(); if (w) { for (var S = 0, b = y.length; S < b; ++S)n.loadFeatures(rn(y[S], h), c, w); I = Ve(w, h) } else for (S = 0, b = y.length; S < b; ++S)n.loadFeatures(y[S], c, h); var O = function (t, e) { var n = Eo(t, e); return n * n }(c, u), T = function (t) { var n, i = t.getStyleFunction() || e.getStyleFunction(); if (i && (n = i(t, c)), n) { var r = this.renderFeature(t, O, n, C, I); this.dirty_ = this.dirty_ || r } }.bind(this), R = rn(_, h), N = n.getFeaturesInExtent(R); d && N.sort(d); for (S = 0, b = N.length; S < b; ++S)T(N[S]); this.renderedFeatures_ = N; var L = C.finish(), P = new Ks(_, c, u, n.getOverlaps(), L, e.getRenderBuffer()); return this.renderedResolution_ = c, this.renderedRevision_ = f, this.renderedRenderOrder_ = d, this.renderedExtent_ = _, this.renderedCenter_ = g, this.renderedProjection_ = h, this.replayGroup_ = P, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0 }, e.prototype.renderFeature = function (t, e, n, i, r) { if (!n) return !1; var s = !1; if (Array.isArray(n)) for (var o = 0, a = n.length; o < a; ++o)s = Io(i, t, n[o], e, this.boundHandleStyleImageChange_, r) || s; else s = Io(i, t, n, e, this.boundHandleStyleImageChange_, r); return s }, e }(Ns), So = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), bo = function (t) { function e(e) { return t.call(this, e) || this } return So(e, t), e.prototype.createRenderer = function () { return new wo(this) }, e }(is), Oo = "active"; var To = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); var Ro = function (t) { function e(e) { var n = t.call(this) || this; return e && e.handleEvent && (n.handleEvent = e.handleEvent), n.map_ = null, n.setActive(!0), n } return To(e, t), e.prototype.getActive = function () { return this.get(Oo) }, e.prototype.getMap = function () { return this.map_ }, e.prototype.handleEvent = function (t) { return !0 }, e.prototype.setActive = function (t) { this.set(Oo, t) }, e.prototype.setMap = function (t) { this.map_ = t }, e }(V), No = "singleclick", Lo = P, Po = M, Mo = "pointerdrag", Do = "pointermove", Ao = "pointerdown", Fo = "pointerup", ko = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); var Go = function (t) { function e(e) { var n = this, i = e || {}; return n = t.call(this, i) || this, i.handleDownEvent && (n.handleDownEvent = i.handleDownEvent), i.handleDragEvent && (n.handleDragEvent = i.handleDragEvent), i.handleMoveEvent && (n.handleMoveEvent = i.handleMoveEvent), i.handleUpEvent && (n.handleUpEvent = i.handleUpEvent), i.stopDown && (n.stopDown = i.stopDown), n.handlingDownUpSequence = !1, n.trackedPointers_ = {}, n.targetPointers = [], n } return ko(e, t), e.prototype.getPointerCount = function () { return this.targetPointers.length }, e.prototype.handleDownEvent = function (t) { return !1 }, e.prototype.handleDragEvent = function (t) { }, e.prototype.handleEvent = function (t) { if (!t.originalEvent) return !0; var e = !1; if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) { if (t.type == Mo) this.handleDragEvent(t), t.preventDefault(); else if (t.type == Fo) { var n = this.handleUpEvent(t); this.handlingDownUpSequence = n && this.targetPointers.length > 0 } } else if (t.type == Ao) { var i = this.handleDownEvent(t); this.handlingDownUpSequence = i, e = this.stopDown(i) } else t.type == Do && this.handleMoveEvent(t); return !e }, e.prototype.handleMoveEvent = function (t) { }, e.prototype.handleUpEvent = function (t) { return !1 }, e.prototype.stopDown = function (t) { return t }, e.prototype.updateTrackedPointers_ = function (t) { if (function (t) { var e = t.type; return e === Ao || e === Mo || e === Fo }(t)) { var e = t.originalEvent, n = e.pointerId.toString(); t.type == Fo ? delete this.trackedPointers_[n] : (t.type == Ao || n in this.trackedPointers_) && (this.trackedPointers_[n] = e), this.targetPointers = S(this.trackedPointers_) } }, e }(Ro), jo = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); function Bo(t) { return t.feature ? t.feature : t.element ? t.element : void 0 } var Yo = [], qo = function (t) { function e(e) { var n = this, i = e || {}, r = i; return r.handleDownEvent || (r.handleDownEvent = x), r.stopDown || (r.stopDown = E), (n = t.call(this, r) || this).source_ = i.source ? i.source : null, n.vertex_ = void 0 === i.vertex || i.vertex, n.edge_ = void 0 === i.edge || i.edge, n.features_ = i.features ? i.features : null, n.featuresListenerKeys_ = [], n.featureChangeListenerKeys_ = {}, n.indexedFeaturesExtents_ = {}, n.pendingFeatures_ = {}, n.pixelTolerance_ = void 0 !== i.pixelTolerance ? i.pixelTolerance : 10, n.rBush_ = new Jt, n.SEGMENT_WRITERS_ = { Point: n.writePointGeometry_.bind(n), LineString: n.writeLineStringGeometry_.bind(n), LinearRing: n.writeLineStringGeometry_.bind(n), Polygon: n.writePolygonGeometry_.bind(n), MultiPoint: n.writeMultiPointGeometry_.bind(n), MultiLineString: n.writeMultiLineStringGeometry_.bind(n), MultiPolygon: n.writeMultiPolygonGeometry_.bind(n), GeometryCollection: n.writeGeometryCollectionGeometry_.bind(n), Circle: n.writeCircleGeometry_.bind(n) }, n } return jo(e, t), e.prototype.addFeature = function (t, e) { var n = void 0 === e || e, i = l(t), r = t.getGeometry(); if (r) { var s = this.SEGMENT_WRITERS_[r.getType()]; s && (this.indexedFeaturesExtents_[i] = r.getExtent([1 / 0, 1 / 0, -1 / 0, -1 / 0]), s(t, r)) } n && (this.featureChangeListenerKeys_[i] = A(t, R, this.handleFeatureChange_, this)) }, e.prototype.forEachFeatureAdd_ = function (t) { this.addFeature(t) }, e.prototype.forEachFeatureRemove_ = function (t) { this.removeFeature(t) }, e.prototype.getFeatures_ = function () { var t; return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t }, e.prototype.handleEvent = function (e) { var n = this.snapTo(e.pixel, e.coordinate, e.map); return n.snapped && (e.coordinate = n.vertex.slice(0, 2), e.pixel = n.vertexPixel), t.prototype.handleEvent.call(this, e) }, e.prototype.handleFeatureAdd_ = function (t) { var e = Bo(t); this.addFeature(e) }, e.prototype.handleFeatureRemove_ = function (t) { var e = Bo(t); this.removeFeature(e) }, e.prototype.handleFeatureChange_ = function (t) { var e = t.target; if (this.handlingDownUpSequence) { var n = l(e); n in this.pendingFeatures_ || (this.pendingFeatures_[n] = e) } else this.updateFeature_(e) }, e.prototype.handleUpEvent = function (t) { var e = S(this.pendingFeatures_); return e.length && (e.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1 }, e.prototype.removeFeature = function (t, e) { var n = void 0 === e || e, i = l(t), r = this.indexedFeaturesExtents_[i]; if (r) { var s = this.rBush_, o = []; s.forEachInExtent(r, (function (e) { t === e.feature && o.push(e) })); for (var a = o.length - 1; a >= 0; --a)s.remove(o[a]) } n && (k(this.featureChangeListenerKeys_[i]), delete this.featureChangeListenerKeys_[i]) }, e.prototype.setMap = function (e) { var n = this.getMap(), i = this.featuresListenerKeys_, r = this.getFeatures_(); n && (i.forEach(k), i.length = 0, r.forEach(this.forEachFeatureRemove_.bind(this))), t.prototype.setMap.call(this, e), e && (this.features_ ? i.push(A(this.features_, W, this.handleFeatureAdd_, this), A(this.features_, H, this.handleFeatureRemove_, this)) : this.source_ && i.push(A(this.source_, hn, this.handleFeatureAdd_, this), A(this.source_, fn, this.handleFeatureRemove_, this)), r.forEach(this.forEachFeatureAdd_.bind(this))) }, e.prototype.snapTo = function (t, e, n) { var i = bt([n.getCoordinateFromPixel([t[0] - this.pixelTolerance_, t[1] + this.pixelTolerance_]), n.getCoordinateFromPixel([t[0] + this.pixelTolerance_, t[1] - this.pixelTolerance_])]), r = this.rBush_.getInExtent(i); this.vertex_ && !this.edge_ && (r = r.filter((function (t) { return t.feature.getGeometry().getType() !== De }))); var s = !1, o = null, a = null; if (0 === r.length) return { snapped: s, vertex: o, vertexPixel: a }; for (var l, h = n.getView().getProjection(), c = nn(e, h), u = 1 / 0, f = 0; f < r.length; ++f) { var p = r[f]; Yo[0] = nn(p.segment[0], h), Yo[1] = nn(p.segment[1], h); var d = je(c, Yo); d < u && (l = p, u = d) } var g = l.segment; if (this.vertex_ && !this.edge_) { var _ = n.getPixelFromCoordinate(g[0]), y = n.getPixelFromCoordinate(g[1]), m = ke(t, _), v = ke(t, y); Math.sqrt(Math.min(m, v)) <= this.pixelTolerance_ && (s = !0, o = m > v ? g[1] : g[0], a = n.getPixelFromCoordinate(o)) } else if (this.edge_) { var x = l.feature.getGeometry().getType() === De; if (x) { var E = l.feature.getGeometry(), I = tn(); I && (E = E.clone().transform(I, h)), o = en(function (t, e) { var n = e.getRadius(), i = e.getCenter(), r = i[0], s = i[1], o = t[0] - r, a = t[1] - s; 0 === o && 0 === a && (o = 1); var l = Math.sqrt(o * o + a * a); return [r + n * o / l, s + n * a / l] }(c, E), h) } else Yo[0] = nn(g[0], h), Yo[1] = nn(g[1], h), o = en(Ae(c, Yo), h); if (Ge(t, a = n.getPixelFromCoordinate(o)) <= this.pixelTolerance_ && (s = !0, this.vertex_ && !x)) { _ = n.getPixelFromCoordinate(g[0]), y = n.getPixelFromCoordinate(g[1]), m = ke(a, _), v = ke(a, y); Math.sqrt(Math.min(m, v)) <= this.pixelTolerance_ && (o = m > v ? g[1] : g[0], a = n.getPixelFromCoordinate(o)) } } return s && (a = [Math.round(a[0]), Math.round(a[1])]), { snapped: s, vertex: o, vertexPixel: a } }, e.prototype.updateFeature_ = function (t) { this.removeFeature(t, !1), this.addFeature(t, !1) }, e.prototype.writeCircleGeometry_ = function (t, e) { var n = this.getMap().getView().getProjection(), i = e, r = tn(); r && (i = i.clone().transform(r, n)); var s = Mr(i); r && s.transform(n, r); for (var o = s.getCoordinates()[0], a = 0, l = o.length - 1; a < l; ++a) { var h = o.slice(a, a + 2), c = { feature: t, segment: h }; this.rBush_.insert(bt(h), c) } }, e.prototype.writeGeometryCollectionGeometry_ = function (t, e) { for (var n = e.getGeometriesArray(), i = 0; i < n.length; ++i) { var r = this.SEGMENT_WRITERS_[n[i].getType()]; r && r(t, n[i]) } }, e.prototype.writeLineStringGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length - 1; i < r; ++i) { var s = n.slice(i, i + 2), o = { feature: t, segment: s }; this.rBush_.insert(bt(s), o) } }, e.prototype.writeMultiLineStringGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i)for (var s = n[i], o = 0, a = s.length - 1; o < a; ++o) { var l = s.slice(o, o + 2), h = { feature: t, segment: l }; this.rBush_.insert(bt(l), h) } }, e.prototype.writeMultiPointGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) { var s = n[i], o = { feature: t, segment: [s, s] }; this.rBush_.insert(e.getExtent(), o) } }, e.prototype.writeMultiPolygonGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i)for (var s = n[i], o = 0, a = s.length; o < a; ++o)for (var l = s[o], h = 0, c = l.length - 1; h < c; ++h) { var u = l.slice(h, h + 2), f = { feature: t, segment: u }; this.rBush_.insert(bt(u), f) } }, e.prototype.writePointGeometry_ = function (t, e) { var n = e.getCoordinates(), i = { feature: t, segment: [n, n] }; this.rBush_.insert(e.getExtent(), i) }, e.prototype.writePolygonGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i)for (var s = n[i], o = 0, a = s.length - 1; o < a; ++o) { var l = s.slice(o, o + 2), h = { feature: t, segment: l }; this.rBush_.insert(bt(l), h) } }, e }(Go), Xo = n(5), zo = n.n(Xo); function Uo(t) { return (Uo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Vo(t, e) { return (Vo = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Wo(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Ko(t); if (e) { var r = Ko(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return Ho(this, n) } } function Ho(t, e) { return !e || "object" !== Uo(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Ko(t) { return (Ko = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Zo = "snap", Jo = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Vo(t, e) }(n, t); var e = Wo(n); function n(t, i, r) { var s; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, n), (s = e.call(this, t)).features = i, s.mapBrowserEvent = r, s } return n }(f); function Qo(t) { return (Qo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function $o(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function ta(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ea(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function na(t, e, n) { return (na = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = aa(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function ia(t, e) { return (ia = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function ra(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = aa(t); if (e) { var r = aa(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return sa(this, n) } } function sa(t, e) { return !e || "object" !== Qo(e) && "function" != typeof e ? oa(t) : e } function oa(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function aa(t) { return (aa = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var la = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && ia(t, e) }(s, t); var e, n, i, r = ra(s); function s(t) { var e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), (e = r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? $o(Object(n), !0).forEach((function (e) { ta(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $o(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "CAD control", className: "ole-control-cad", image: zo.a, showSnapPoints: !0, showSnapLines: !1, snapPointDist: 10 }, t))).pointerInteraction = new Go({ handleMoveEvent: e.onMove.bind(oa(e)) }), e.snapLayer = new bo({ source: new In, style: t.snapStyle || [new Li({ image: new Ei({ fill: new wi({ color: "#E8841F" }), stroke: new Si({ width: 1, color: "#618496" }), points: 4, radius: 5, radius2: 0, angle: Math.PI / 4 }), stroke: new Si({ width: 1, lineDash: [5, 10], color: "#618496" }) })] }), e.linesLayer = new bo({ source: new In, style: t.linesStyle || [new Li({ stroke: new Si({ width: 1, lineDash: [5, 10], color: "#FF530D" }) })] }), e.snapTolerance = void 0 === t.snapTolerance ? 10 : t.snapTolerance, e.filter = t.filter || null, e.snapInteraction = new qo({ pixelTolerance: e.snapTolerance, source: e.snapLayer.getSource() }), e.standalone = !1, e } return e = s, (n = [{ key: "getDialogTemplate", value: function () { var t = this.properties.useMapUnits ? "map units" : "px"; return '\n      <div>\n        <input\n          id="aux-cb"\n          type="radio"\n          name="radioBtn"\n          '.concat(this.properties.showSnapLines ? "checked" : "", '\n        >\n        <label>Show snap lines</label>\n      </div>\n      <div>\n        <input\n          id="dist-cb"\n          type="radio"\n          name="radioBtn"\n          ').concat(this.properties.showSnapPoints ? "checked" : "", "\n        >\n        <label>Show snap points. Distance (").concat(t, '):</label>\n        <input type="text" id="width-input"\n          value="').concat(this.properties.snapPointDist, '">\n      </div>\n    ') } }, { key: "setMap", value: function (t) { var e = this; na(aa(s.prototype), "setMap", this).call(this, t), this.map.getInteractions().on("add", function (t) { var n = t.target.getArray().indexOf(e.snapInteraction); e.snapInteraction.getActive() && n > -1 && n !== t.target.getLength() - 1 && (e.deactivate(!0), e.activate(!0)) }.bind(this)) } }, { key: "onMove", value: function (t) { var e = this.getClosestFeatures(t.coordinate, 5), n = this.editor.getEditFeature(); n && e.indexOf(n) > -1 && e.splice(e.indexOf(n), 1), this.linesLayer.getSource().clear(), this.snapLayer.getSource().clear(), this.pointerInteraction.dispatchEvent(new Jo(Zo, e.length ? e : null, t)), this.properties.showSnapLines && this.drawSnapLines(e, t.coordinate), this.properties.showSnapPoints && e.length && this.drawSnapPoints(t.coordinate, e[0]) } }, { key: "getClosestFeatures", value: function (t, e) { var n = this, i = e || 1, r = [-1 / 0, -1 / 0, 1 / 0, 1 / 0], s = {}; this.source.forEachFeatureInExtent(r, (function (e) { (!n.filter || n.filter && n.filter(e)) && function (e) { var n = e.getGeometry().getClosestPoint(t), i = n[0] - t[0], r = n[1] - t[1]; s[i * i + r * r] = e }(e) })); var o = Object.keys(s), a = [], l = Math.min(o.length, i); o.sort((function (t, e) { return t - e })); for (var h = 0; h < l; h += 1)a.push(s[o[h]]); return a } }, { key: "drawSnapLines", value: function (t, e) { for (var n, i, r, s, o, a, l = [], h = 0; h < t.length; h += 1) { var c = t[h].getGeometry(), u = c.getCoordinates(); if (c instanceof Ki) l.push(u); else { if (c instanceof vr) for (var f = 0; f < u.length; f += 1)l.push(u[f]); else if (c instanceof Pr) for (var p = 0; p < u[0].length; p += 1)l.push(u[0][p]); var d = (n = c.getExtent(), i = void 0, r = void 0, s = void 0, o = void 0, a = void 0, i = n[0], r = n[1], s = n[2], o = n[3], a = [i, r, i, o, s, o, s, r, i, r], new Lr(a, Gi, [a.length])).getCoordinates()[0]; l = l.concat(d) } } for (var g = this.map.getPixelFromCoordinate(e), _ = null, y = 0; y < l.length; y += 1) { var m = this.snapTolerance, v = this.map.getPixelFromCoordinate(l[y]), x = g[0] > v[0] - this.snapTolerance / 2 && g[0] < v[0] + this.snapTolerance / 2, E = g[1] > v[1] - this.snapTolerance / 2 && g[1] < v[1] + this.snapTolerance / 2; if (x) { var I = g[1]; I += g[1] < v[1] ? 2 * -m : 2 * m; var C = this.map.getCoordinateFromPixel([v[0], I]); _ = [[l[y][0], C[1]], l[y]] } else if (E) { var w = g[0]; w += g[0] < v[0] ? 2 * -m : 2 * m, _ = [[this.map.getCoordinateFromPixel([w, v[1]])[0], l[y][1]], l[y]] } if (_) { var S = new vr(_); this.snapLayer.getSource().addFeature(new Gr(S)) } } var b = null, O = null, T = this.snapLayer.getSource().getFeatures(); if (T.length) { T.forEach((function (t) { var e = t.getGeometry().getCoordinates(), n = e[0][0], i = e[1][0], r = e[0][1], s = e[1][1]; n === i && (b = n), r === s && (O = r) })); var R = []; if (b && O) { R.push(b), R.push(O), this.linesLayer.getSource().addFeatures(T), this.snapLayer.getSource().clear(); var N = new Ki(R); this.snapLayer.getSource().addFeature(new Gr(N)) } } } }, { key: "drawSnapPoints", value: function (t, e) { var n = e.getGeometry().getClosestPoint(t), i = this.map.getPixelFromCoordinate(n), r = []; if (this.properties.useMapUnits) r = [[n[0] - this.properties.snapPointDist, n[1]], [n[0] + this.properties.snapPointDist, n[1]], [n[0], n[1] - this.properties.snapPointDist], [n[0], n[1] + this.properties.snapPointDist]]; else for (var s = [[i[0] - this.properties.snapPointDist, i[1]], [i[0] + this.properties.snapPointDist, i[1]], [i[0], i[1] - this.properties.snapPointDist], [i[0], i[1] + this.properties.snapPointDist]], o = 0; o < s.length; o += 1)r.push(this.map.getCoordinateFromPixel(s[o])); var a = new Fr(r); this.snapLayer.getSource().addFeature(new Gr(a)) } }, { key: "activate", value: function (t) { var e = this; na(aa(s.prototype), "activate", this).call(this, t), this.snapLayer.setMap(this.map), this.linesLayer.setMap(this.map), this.map.addInteraction(this.pointerInteraction), this.map.addInteraction(this.snapInteraction), document.getElementById("aux-cb").addEventListener("change", (function (t) { e.setProperties({ showSnapLines: t.target.checked, showSnapPoints: !t.target.checked }) })), document.getElementById("dist-cb").addEventListener("change", (function (t) { e.setProperties({ showSnapPoints: t.target.checked, showSnapLines: !t.target.checked }) })), document.getElementById("width-input").addEventListener("keyup", (function (t) { var n = parseFloat(t.target.value); n && e.setProperties({ snapPointDist: n }) })) } }, { key: "deactivate", value: function (t) { na(aa(s.prototype), "deactivate", this).call(this, t), this.snapLayer.setMap(null), this.linesLayer.setMap(null), this.map.removeInteraction(this.pointerInteraction), this.map.removeInteraction(this.snapInteraction) } }]) && ea(e.prototype, n), i && ea(e, i), s }(Dn), ha = n(6), ca = n.n(ha), ua = n(7), fa = n.n(ua); function pa(t) { return (pa = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function da(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function ga(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function _a(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function ya(t, e, n) { return (ya = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Ia(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function ma(t, e) { return (ma = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function va(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Ia(t); if (e) { var r = Ia(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return xa(this, n) } } function xa(t, e) { return !e || "object" !== pa(e) && "function" != typeof e ? Ea(t) : e } function Ea(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Ia(t) { return (Ia = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Ca = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && ma(t, e) }(s, t); var e, n, i, r = va(s); function s(t) { var e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), (e = r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? da(Object(n), !0).forEach((function (e) { ga(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : da(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Rotate", className: "icon-rotate", image: ca.a }, t))).pointerInteraction = new Go({ handleDownEvent: e.onDown.bind(Ea(e)), handleDragEvent: e.onDrag.bind(Ea(e)), handleUpEvent: e.onUp.bind(Ea(e)) }), e.rotateAttribute = t.rotateAttribute || "ole_rotation", e.rotateLayer = new bo({ source: new In, style: t.style || function (t) { var n = t.get(e.rotateAttribute); return [new Li({ geometry: new Ki(e.center), image: new mo({ rotation: n, src: fa.a }) })] } }), e } return e = s, (n = [{ key: "onDown", value: function (t) { var e = this; return this.dragging = !1, this.feature = this.map.forEachFeatureAtPixel(t.pixel, (function (t) { return e.source.getFeatures().indexOf(t) > -1 ? t : null })), this.center && this.feature && (this.feature.set(this.rotateAttribute, this.feature.get(this.rotateAttribute) || 0), this.initialRotation = Math.atan2(t.coordinate[1] - this.center[1], t.coordinate[0] - this.center[0]) + this.feature.get(this.rotateAttribute)), !!this.feature } }, { key: "onDrag", value: function (t) { if (this.dragging = !0, this.feature && this.center) { var e = Math.atan2(t.coordinate[1] - this.center[1], t.coordinate[0] - this.center[0]), n = this.initialRotation - e, i = n - this.feature.get(this.rotateAttribute); this.feature.getGeometry().rotate(-i, this.center), this.rotateFeature.getGeometry().rotate(-i, this.center), this.feature.set(this.rotateAttribute, n), this.rotateFeature.set(this.rotateAttribute, n) } } }, { key: "onUp", value: function (t) { this.dragging || (this.feature ? (this.rotateFeature = this.feature, this.center = t.coordinate, this.rotateLayer.getSource().clear(), this.rotateLayer.getSource().addFeature(this.rotateFeature)) : this.rotateLayer.getSource().clear()) } }, { key: "activate", value: function () { this.map.addInteraction(this.pointerInteraction), this.rotateLayer.setMap(this.map), ya(Ia(s.prototype), "activate", this).call(this) } }, { key: "deactivate", value: function (t) { this.rotateLayer.getSource().clear(), this.rotateLayer.setMap(null), this.map.removeInteraction(this.pointerInteraction), ya(Ia(s.prototype), "deactivate", this).call(this, t) } }]) && _a(e.prototype, n), i && _a(e, i), s }(Dn), wa = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Sa = function (t) { function e(e, n, i) { var r = t.call(this) || this; if (void 0 !== i && void 0 === n) r.setFlatCoordinates(i, e); else { var s = n || 0; r.setCenterAndRadius(e, s, i) } return r } return wa(e, t), e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), void 0, this.layout) }, e.prototype.closestPointXY = function (t, e, n, i) { var r = this.flatCoordinates, s = t - r[0], o = e - r[1], a = s * s + o * o; if (a < i) { if (0 === a) for (var l = 0; l < this.stride; ++l)n[l] = r[l]; else { var h = this.getRadius() / Math.sqrt(a); n[0] = r[0] + h * s, n[1] = r[1] + h * o; for (l = 2; l < this.stride; ++l)n[l] = r[l] } return n.length = this.stride, a } return i }, e.prototype.containsXY = function (t, e) { var n = this.flatCoordinates, i = t - n[0], r = e - n[1]; return i * i + r * r <= this.getRadiusSquared_() }, e.prototype.getCenter = function () { return this.flatCoordinates.slice(0, this.stride) }, e.prototype.computeExtent = function (t) { var e = this.flatCoordinates, n = e[this.stride] - e[0]; return Mt(e[0] - n, e[1] - n, e[0] + n, e[1] + n, t) }, e.prototype.getRadius = function () { return Math.sqrt(this.getRadiusSquared_()) }, e.prototype.getRadiusSquared_ = function () { var t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1]; return t * t + e * e }, e.prototype.getType = function () { return De }, e.prototype.intersectsExtent = function (t) { if (Kt(t, this.getExtent())) { var e = this.getCenter(); return t[0] <= e[0] && t[2] >= e[0] || (t[1] <= e[1] && t[3] >= e[1] || Yt(t, this.intersectsCoordinate.bind(this))) } return !1 }, e.prototype.setCenter = function (t) { var e = this.stride, n = this.flatCoordinates[e] - this.flatCoordinates[0], i = t.slice(); i[e] = i[0] + n; for (var r = 1; r < e; ++r)i[e + r] = t[r]; this.setFlatCoordinates(this.layout, i), this.changed() }, e.prototype.setCenterAndRadius = function (t, e, n) { this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []); var i = this.flatCoordinates, r = Ui(i, 0, t, this.stride); i[r++] = i[0] + e; for (var s = 1, o = this.stride; s < o; ++s)i[r++] = i[s]; i.length = r, this.changed() }, e.prototype.getCoordinates = function () { return null }, e.prototype.setCoordinates = function (t, e) { }, e.prototype.setRadius = function (t) { this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed() }, e.prototype.rotate = function (t, e) { var n = this.getCenter(), i = this.getStride(); this.setCenter(Mi(n, 0, n.length, i, t, e, n)), this.changed() }, e.prototype.translate = function (t, e) { var n = this.getCenter(), i = this.getStride(); this.setCenter(Di(n, 0, n.length, i, t, e, n)), this.changed() }, e }(zi); Sa.prototype.transform; var ba = Sa, Oa = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Ta = function (t) { function e(e, n, i) { var r = t.call(this, e) || this; return r.map = n, r.frameState = void 0 !== i ? i : null, r } return Oa(e, t), e }(f), Ra = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Na = function (t) { function e(e, n, i, r, s) { var o = t.call(this, e, n, s) || this; return o.originalEvent = i, o.pixel_ = null, o.coordinate_ = null, o.dragging = void 0 !== r && r, o } return Ra(e, t), Object.defineProperty(e.prototype, "pixel", { get: function () { return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_ }, set: function (t) { this.pixel_ = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "coordinate", { get: function () { return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_ }, set: function (t) { this.coordinate_ = t }, enumerable: !1, configurable: !0 }), e.prototype.preventDefault = function () { t.prototype.preventDefault.call(this), this.originalEvent.preventDefault() }, e.prototype.stopPropagation = function () { t.prototype.stopPropagation.call(this), this.originalEvent.stopPropagation() }, e }(Ta), La = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Pa = function (t) { function e(e, n, i) { var r = t.call(this) || this; if (r.ends_ = [], r.maxDelta_ = -1, r.maxDeltaRevision_ = -1, Array.isArray(e[0])) r.setCoordinates(e, n); else if (void 0 !== n && i) r.setFlatCoordinates(n, e), r.ends_ = i; else { for (var s = r.getLayout(), o = e, a = [], l = [], h = 0, c = o.length; h < c; ++h) { var u = o[h]; 0 === h && (s = u.getLayout()), m(a, u.getFlatCoordinates()), l.push(a.length) } r.setFlatCoordinates(s, a), r.ends_ = l } return r } return La(e, t), e.prototype.appendLineString = function (t) { this.flatCoordinates ? m(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed() }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice()) }, e.prototype.closestPointXY = function (t, e, n, i) { return i < Tt(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Qi(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), tr(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, n, i)) }, e.prototype.getCoordinateAtM = function (t, e, n) { if (this.layout != Bi && this.layout != Yi || 0 === this.flatCoordinates.length) return null; var i = void 0 !== e && e, r = void 0 !== n && n; return function (t, e, n, i, r, s, o) { if (o) return ur(t, e, n[n.length - 1], i, r, s); var a; if (r < t[i - 1]) return s ? ((a = t.slice(0, i))[i - 1] = r, a) : null; if (t[t.length - 1] < r) return s ? ((a = t.slice(t.length - i))[i - 1] = r, a) : null; for (var l = 0, h = n.length; l < h; ++l) { var c = n[l]; if (e != c) { if (r < t[e + i - 1]) return null; if (r <= t[c - 1]) return ur(t, e, c, i, r, !1); e = c } } return null }(this.flatCoordinates, 0, this.ends_, this.stride, t, i, r) }, e.prototype.getCoordinates = function () { return lr(this.flatCoordinates, 0, this.ends_, this.stride) }, e.prototype.getEnds = function () { return this.ends_ }, e.prototype.getLineString = function (t) { return t < 0 || this.ends_.length <= t ? null : new vr(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout) }, e.prototype.getLineStrings = function () { for (var t = this.flatCoordinates, e = this.ends_, n = this.layout, i = [], r = 0, s = 0, o = e.length; s < o; ++s) { var a = e[s], l = new vr(t.slice(r, a), n); i.push(l), r = a } return i }, e.prototype.getFlatMidpoints = function () { for (var t = [], e = this.flatCoordinates, n = 0, i = this.ends_, r = this.stride, s = 0, o = i.length; s < o; ++s) { var a = i[s]; m(t, cr(e, n, a, r, .5)), n = a } return t }, e.prototype.getSimplifiedGeometryInternal = function (t) { var n = [], i = []; return n.length = nr(this.flatCoordinates, 0, this.ends_, this.stride, t, n, 0, i), new e(n, Gi, i) }, e.prototype.getType = function () { return Le }, e.prototype.intersectsExtent = function (t) { return function (t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s) { if (gr(t, e, n[s], i, r)) return !0; e = n[s] } return !1 }(this.flatCoordinates, 0, this.ends_, this.stride, t) }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []); var n = Wi(this.flatCoordinates, 0, t, this.stride, this.ends_); this.flatCoordinates.length = 0 === n.length ? 0 : n[n.length - 1], this.changed() }, e }(zi); var Ma = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Da = function (t) { function e(e, n, i) { var r = t.call(this) || this; if (r.endss_ = [], r.flatInteriorPointsRevision_ = -1, r.flatInteriorPoints_ = null, r.maxDelta_ = -1, r.maxDeltaRevision_ = -1, r.orientedRevision_ = -1, r.orientedFlatCoordinates_ = null, !i && !Array.isArray(e[0])) { for (var s = r.getLayout(), o = e, a = [], l = [], h = 0, c = o.length; h < c; ++h) { var u = o[h]; 0 === h && (s = u.getLayout()); for (var f = a.length, p = u.getEnds(), d = 0, g = p.length; d < g; ++d)p[d] += f; m(a, u.getFlatCoordinates()), l.push(p) } n = s, e = a, i = l } return void 0 !== n && i ? (r.setFlatCoordinates(n, e), r.endss_ = i) : r.setCoordinates(e, n), r } return Ma(e, t), e.prototype.appendPolygon = function (t) { var e; if (this.flatCoordinates) { var n = this.flatCoordinates.length; m(this.flatCoordinates, t.getFlatCoordinates()); for (var i = 0, r = (e = t.getEnds().slice()).length; i < r; ++i)e[i] += n } else this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push(); this.endss_.push(e), this.changed() }, e.prototype.clone = function () { for (var t = this.endss_.length, n = new Array(t), i = 0; i < t; ++i)n[i] = this.endss_[i].slice(); return new e(this.flatCoordinates.slice(), this.layout, n) }, e.prototype.closestPointXY = function (t, e, n, i) { return i < Tt(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(function (t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s) { var a = n[s]; r = Qi(t, e, a, i, r), e = a[a.length - 1] } return r }(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), function (t, e, n, i, r, s, o, a, l, h, c) { for (var u = c || [NaN, NaN], f = 0, p = n.length; f < p; ++f) { var d = n[f]; h = tr(t, e, d, i, r, s, o, a, l, h, u), e = d[d.length - 1] } return h }(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, t, e, n, i)) }, e.prototype.containsXY = function (t, e) { return function (t, e, n, i, r, s) { if (0 === n.length) return !1; for (var o = 0, a = n.length; o < a; ++o) { var l = n[o]; if (dr(t, e, l, i, r, s)) return !0; e = l[l.length - 1] } return !1 }(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e) }, e.prototype.getArea = function () { return function (t, e, n, i) { for (var r = 0, s = 0, o = n.length; s < o; ++s) { var a = n[s]; r += Er(t, e, a, i), e = a[a.length - 1] } return r }(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride) }, e.prototype.getCoordinates = function (t) { var e; return void 0 !== t ? Rr(e = this.getOrientedFlatCoordinates().slice(), 0, this.endss_, this.stride, t) : e = this.flatCoordinates, hr(e, 0, this.endss_, this.stride) }, e.prototype.getEndss = function () { return this.endss_ }, e.prototype.getFlatInteriorPoints = function () { if (this.flatInteriorPointsRevision_ != this.getRevision()) { var t = function (t, e, n, i) { for (var r = [], s = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o = 0, a = n.length; o < a; ++o) { var l = n[o]; s = Ft(t, e, l[0], i), r.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), e = l[l.length - 1] } return r }(this.flatCoordinates, 0, this.endss_, this.stride); this.flatInteriorPoints_ = function (t, e, n, i, r) { for (var s = [], o = 0, a = n.length; o < a; ++o) { var l = n[o]; s = wr(t, e, l, i, r, 2 * o, s), e = l[l.length - 1] } return s }(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t), this.flatInteriorPointsRevision_ = this.getRevision() } return this.flatInteriorPoints_ }, e.prototype.getInteriorPoints = function () { return new Fr(this.getFlatInteriorPoints().slice(), Bi) }, e.prototype.getOrientedFlatCoordinates = function () { if (this.orientedRevision_ != this.getRevision()) { var t = this.flatCoordinates; !function (t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s) { var a = n[s]; if (!Or(t, e, a, i, r)) return !1; a.length && (e = a[a.length - 1]) } return !0 }(t, 0, this.endss_, this.stride) ? (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Rr(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)) : this.orientedFlatCoordinates_ = t, this.orientedRevision_ = this.getRevision() } return this.orientedFlatCoordinates_ }, e.prototype.getSimplifiedGeometryInternal = function (t) { var n = [], i = []; return n.length = function (t, e, n, i, r, s, o, a) { for (var l = 0, h = n.length; l < h; ++l) { var c = n[l], u = []; o = sr(t, e, c, i, r, s, o, u), a.push(u), e = c[c.length - 1] } return o }(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), n, 0, i), new e(n, Gi, i) }, e.prototype.getPolygon = function (t) { if (t < 0 || this.endss_.length <= t) return null; var e; if (0 === t) e = 0; else { var n = this.endss_[t - 1]; e = n[n.length - 1] } var i = this.endss_[t].slice(), r = i[i.length - 1]; if (0 !== e) for (var s = 0, o = i.length; s < o; ++s)i[s] -= e; return new Pr(this.flatCoordinates.slice(e, r), this.layout, i) }, e.prototype.getPolygons = function () { for (var t = this.layout, e = this.flatCoordinates, n = this.endss_, i = [], r = 0, s = 0, o = n.length; s < o; ++s) { var a = n[s].slice(), l = a[a.length - 1]; if (0 !== r) for (var h = 0, c = a.length; h < c; ++h)a[h] -= r; var u = new Pr(e.slice(r, l), t, a); i.push(u), r = l } return i }, e.prototype.getType = function () { return Pe }, e.prototype.intersectsExtent = function (t) { return function (t, e, n, i, r) { for (var s = 0, o = n.length; s < o; ++s) { var a = n[s]; if (_r(t, e, a, i, r)) return !0; e = a[a.length - 1] } return !1 }(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t) }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []); var n = function (t, e, n, i, r) { for (var s = r || [], o = 0, a = 0, l = n.length; a < l; ++a) { var h = Wi(t, e, n[a], i, s[o]); s[o++] = h, e = h[h.length - 1] } return s.length = o, s }(this.flatCoordinates, 0, t, this.stride, this.endss_); if (0 === n.length) this.flatCoordinates.length = 0; else { var i = n[n.length - 1]; this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1] } this.changed() }, e }(zi); var Aa = x, Fa = function (t) { return t.type == Lo }, ka = E, Ga = function (t) { return t.type == No }, ja = function (t) { var e = t.originalEvent; return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey }, Ba = function (t) { var e = t.originalEvent; return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey }, Ya = function (t) { var e = t.originalEvent; return St(void 0 !== e, 56), e.isPrimary && 0 === e.button }, qa = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), Xa = "Point", za = "LineString", Ua = "Polygon", Va = "Circle", Wa = "drawstart", Ha = "drawend", Ka = "drawabort", Za = function (t) { function e(e, n) { var i = t.call(this, e) || this; return i.feature = n, i } return qa(e, t), e }(f); var Ja = function (t) { function e(e) { var n = this, i = e; i.stopDown || (i.stopDown = E), (n = t.call(this, i) || this).shouldHandle_ = !1, n.downPx_ = null, n.downTimeout_, n.lastDragTime_, n.freehand_ = !1, n.source_ = e.source ? e.source : null, n.features_ = e.features ? e.features : null, n.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, n.type_ = e.type, n.mode_ = function (t) { var e; t === be || t === Ne ? e = Xa : t === Oe || t === Le ? e = za : t === Re || t === Pe ? e = Ua : t === De && (e = Va); return e }(n.type_), n.stopClick_ = !!e.stopClick, n.minPoints_ = e.minPoints ? e.minPoints : n.mode_ === Ua ? 3 : 2, n.maxPoints_ = e.maxPoints ? e.maxPoints : 1 / 0, n.finishCondition_ = e.finishCondition ? e.finishCondition : x; var r, s = e.geometryFunction; if (!s) if (n.type_ === De) s = function (t, e, n) { var i = e || new ba([NaN, NaN]), r = nn(t[0], n), s = ke(r, nn(t[1], n)); i.setCenterAndRadius(r, Math.sqrt(s)); var o = tn(); return o && i.transform(n, o), i }; else { var o, a = n.mode_; a === Xa ? o = Ki : a === za ? o = vr : a === Ua && (o = Pr), s = function (t, e, n) { var i = e; return i ? a === Ua ? t[0].length ? i.setCoordinates([t[0].concat([t[0][0]])]) : i.setCoordinates([]) : i.setCoordinates(t) : i = new o(t), i } } return n.geometryFunction_ = s, n.dragVertexDelay_ = void 0 !== e.dragVertexDelay ? e.dragVertexDelay : 500, n.finishCoordinate_ = null, n.sketchFeature_ = null, n.sketchPoint_ = null, n.sketchCoords_ = null, n.sketchLine_ = null, n.sketchLineCoords_ = null, n.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, n.overlay_ = new bo({ source: new In({ useSpatialIndex: !1, wrapX: !!e.wrapX && e.wrapX }), style: e.style ? e.style : (r = Ri(), function (t, e) { return r[t.getGeometry().getType()] }), updateWhileInteracting: !0 }), n.geometryName_ = e.geometryName, n.condition_ = e.condition ? e.condition : ja, n.freehandCondition_, e.freehand ? n.freehandCondition_ = Aa : n.freehandCondition_ = e.freehandCondition ? e.freehandCondition : Ba, n.addEventListener(U(Oo), n.updateState_), n } return qa(e, t), e.prototype.setMap = function (e) { t.prototype.setMap.call(this, e), this.updateState_() }, e.prototype.getOverlay = function () { return this.overlay_ }, e.prototype.handleEvent = function (e) { e.originalEvent.type === L && e.preventDefault(), this.freehand_ = this.mode_ !== Xa && this.freehandCondition_(e); var n = e.type === Do, i = !0; !this.freehand_ && this.lastDragTime_ && e.type === Mo && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, n = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && void 0 !== this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)); return this.freehand_ && e.type === Mo && null !== this.sketchFeature_ ? (this.addToDrawing_(e.coordinate), i = !1) : this.freehand_ && e.type === Ao ? i = !1 : n ? (i = e.type === Do) && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.preventDefault()) : ("mouse" == e.originalEvent.pointerType || e.type === Mo && void 0 === this.downTimeout_) && this.handlePointerMove_(e) : e.type === Po && (i = !1), t.prototype.handleEvent.call(this, e) && i }, e.prototype.handleDownEvent = function (t) { return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t), !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(function () { this.handlePointerMove_(new Na(Do, t.map, t.originalEvent, !1, t.frameState)) }.bind(this), this.dragVertexDelay_), this.downPx_ = t.pixel, !0) : (this.lastDragTime_ = void 0, !1) }, e.prototype.handleUpEvent = function (t) { var e = !0; this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t); var n = this.mode_ === Va; return this.shouldHandle_ ? (this.finishCoordinate_ ? this.freehand_ || n ? this.finishDrawing() : this.atFinish_(t) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate) : (this.startDrawing_(t), this.mode_ === Xa && this.finishDrawing()), e = !1) : this.freehand_ && this.abortDrawing(), !e && this.stopClick_ && t.stopPropagation(), e }, e.prototype.handlePointerMove_ = function (t) { if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) { var e = this.downPx_, n = t.pixel, i = e[0] - n[0], r = e[1] - n[1], s = i * i + r * r; if (this.shouldHandle_ = this.freehand_ ? s > this.squaredClickTolerance_ : s <= this.squaredClickTolerance_, !this.shouldHandle_) return } this.finishCoordinate_ ? this.modifyDrawing_(t) : this.createOrUpdateSketchPoint_(t) }, e.prototype.atFinish_ = function (t) { var e = !1; if (this.sketchFeature_) { var n = !1, i = [this.finishCoordinate_]; if (this.mode_ === za) n = this.sketchCoords_.length > this.minPoints_; else if (this.mode_ === Ua) { var r = this.sketchCoords_; n = r[0].length > this.minPoints_, i = [r[0][0], r[0][r[0].length - 2]] } if (n) for (var s = t.map, o = 0, a = i.length; o < a; o++) { var l = i[o], h = s.getPixelFromCoordinate(l), c = t.pixel, u = c[0] - h[0], f = c[1] - h[1], p = this.freehand_ ? 1 : this.snapTolerance_; if (e = Math.sqrt(u * u + f * f) <= p) { this.finishCoordinate_ = l; break } } } return e }, e.prototype.createOrUpdateSketchPoint_ = function (t) { var e = t.coordinate.slice(); this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new Gr(new Ki(e)), this.updateSketchFeatures_()) }, e.prototype.startDrawing_ = function (t) { var e = t.coordinate, n = t.map.getView().getProjection(); this.finishCoordinate_ = e, this.mode_ === Xa ? this.sketchCoords_ = e.slice() : this.mode_ === Ua ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Gr(new vr(this.sketchLineCoords_))); var i = this.geometryFunction_(this.sketchCoords_, void 0, n); this.sketchFeature_ = new Gr, this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(i), this.updateSketchFeatures_(), this.dispatchEvent(new Za(Wa, this.sketchFeature_)) }, e.prototype.modifyDrawing_ = function (t) { var e, n, i, r = t.coordinate, s = this.sketchFeature_.getGeometry(), o = t.map.getView().getProjection(); (this.mode_ === Xa ? n = this.sketchCoords_ : this.mode_ === Ua ? (n = (e = this.sketchCoords_[0])[e.length - 1], this.atFinish_(t) && (r = this.finishCoordinate_.slice())) : n = (e = this.sketchCoords_)[e.length - 1], n[0] = r[0], n[1] = r[1], this.geometryFunction_(this.sketchCoords_, s, o), this.sketchPoint_) && this.sketchPoint_.getGeometry().setCoordinates(r); if (s.getType() == Re && this.mode_ !== Ua) { this.sketchLine_ || (this.sketchLine_ = new Gr); var a = s.getLinearRing(0); (i = this.sketchLine_.getGeometry()) ? (i.setFlatCoordinates(a.getLayout(), a.getFlatCoordinates()), i.changed()) : (i = new vr(a.getFlatCoordinates(), a.getLayout()), this.sketchLine_.setGeometry(i)) } else this.sketchLineCoords_ && (i = this.sketchLine_.getGeometry()).setCoordinates(this.sketchLineCoords_); this.updateSketchFeatures_() }, e.prototype.addToDrawing_ = function (t) { var e, n, i = this.sketchFeature_.getGeometry(), r = this.getMap().getView().getProjection(); this.mode_ === za ? (this.finishCoordinate_ = t.slice(), (n = this.sketchCoords_).length >= this.maxPoints_ && (this.freehand_ ? n.pop() : e = !0), n.push(t.slice()), this.geometryFunction_(n, i, r)) : this.mode_ === Ua && ((n = this.sketchCoords_[0]).length >= this.maxPoints_ && (this.freehand_ ? n.pop() : e = !0), n.push(t.slice()), e && (this.finishCoordinate_ = n[0]), this.geometryFunction_(this.sketchCoords_, i, r)), this.updateSketchFeatures_(), e && this.finishDrawing() }, e.prototype.removeLastPoint = function () { if (this.sketchFeature_) { var t, e = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection(); this.mode_ === za ? ((t = this.sketchCoords_).splice(-2, 1), this.geometryFunction_(t, e, n), t.length >= 2 && (this.finishCoordinate_ = t[t.length - 2].slice())) : this.mode_ === Ua && ((t = this.sketchCoords_[0]).splice(-2, 1), this.sketchLine_.getGeometry().setCoordinates(t), this.geometryFunction_(this.sketchCoords_, e, n)), 0 === t.length && this.abortDrawing(), this.updateSketchFeatures_() } }, e.prototype.finishDrawing = function () { var t = this.abortDrawing_(); if (t) { var e = this.sketchCoords_, n = t.getGeometry(), i = this.getMap().getView().getProjection(); this.mode_ === za ? (e.pop(), this.geometryFunction_(e, n, i)) : this.mode_ === Ua && (e[0].pop(), this.geometryFunction_(e, n, i), e = n.getCoordinates()), this.type_ === Ne ? t.setGeometry(new Fr([e])) : this.type_ === Le ? t.setGeometry(new Pa([e])) : this.type_ === Pe && t.setGeometry(new Da([e])), this.dispatchEvent(new Za(Ha, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t) } }, e.prototype.abortDrawing_ = function () { this.finishCoordinate_ = null; var t = this.sketchFeature_; return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), t }, e.prototype.abortDrawing = function () { var t = this.abortDrawing_(); t && this.dispatchEvent(new Za(Ka, t)) }, e.prototype.appendCoordinates = function (t) { var e = this.mode_, n = []; e === za ? n = this.sketchCoords_ : e === Ua && (n = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : []); for (var i = n.pop(), r = 0; r < t.length; r++)this.addToDrawing_(t[r]); this.addToDrawing_(i) }, e.prototype.extend = function (t) { var e = t.getGeometry(); this.sketchFeature_ = t, this.sketchCoords_ = e.getCoordinates(); var n = this.sketchCoords_[this.sketchCoords_.length - 1]; this.finishCoordinate_ = n.slice(), this.sketchCoords_.push(n.slice()), this.updateSketchFeatures_(), this.dispatchEvent(new Za(Wa, this.sketchFeature_)) }, e.prototype.updateSketchFeatures_ = function () { var t = []; this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_); var e = this.overlay_.getSource(); e.clear(!0), e.addFeatures(t) }, e.prototype.updateState_ = function () { var t = this.getMap(), e = this.getActive(); t && e || this.abortDrawing(), this.overlay_.setMap(e ? t : null) }, e }(Go), Qa = n(8), $a = n.n(Qa), tl = n(9), el = n.n(tl), nl = n(10), il = n.n(nl); function rl(t) { return (rl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function sl(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function al(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ll(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function hl(t, e, n) { return (hl = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = pl(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function cl(t, e) { return (cl = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function ul(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = pl(t); if (e) { var r = pl(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return fl(this, n) } } function fl(t, e) { return !e || "object" !== rl(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function pl(t) { return (pl = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var dl = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && cl(t, e) }(s, t); var e, n, i, r = ul(s); function s(t) { var e; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s); var n = null; switch (t.type) { case "Polygon": n = el.a; break; case "LineString": n = il.a; break; default: n = $a.a }return (e = r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? sl(Object(n), !0).forEach((function (e) { al(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sl(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Draw ".concat(t.type || "Point"), className: "ole-control-draw", image: n }, t))).drawInteraction = new Ja({ type: t.type || "Point", features: t.features, source: t.source, style: t.style, stopClick: !0 }), e } return e = s, (n = [{ key: "activate", value: function () { this.map.addInteraction(this.drawInteraction), hl(pl(s.prototype), "activate", this).call(this) } }, { key: "deactivate", value: function (t) { this.map.removeInteraction(this.drawInteraction), hl(pl(s.prototype), "deactivate", this).call(this, t) } }]) && ll(e.prototype, n), i && ll(e, i), s }(Dn), gl = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(); function _l(t) { for (var e = [], n = 0, i = t.length; n < i; ++n)e.push(t[n].clone()); return e } var yl = function (t) { function e(e) { var n = t.call(this) || this; return n.geometries_ = e || null, n.changeEventsKeys_ = [], n.listenGeometriesChange_(), n } return gl(e, t), e.prototype.unlistenGeometriesChange_ = function () { this.changeEventsKeys_.forEach(k), this.changeEventsKeys_.length = 0 }, e.prototype.listenGeometriesChange_ = function () { if (this.geometries_) for (var t = 0, e = this.geometries_.length; t < e; ++t)this.changeEventsKeys_.push(A(this.geometries_[t], R, this.changed, this)) }, e.prototype.clone = function () { var t = new e(null); return t.setGeometries(this.geometries_), t }, e.prototype.closestPointXY = function (t, e, n, i) { if (i < Tt(this.getExtent(), t, e)) return i; for (var r = this.geometries_, s = 0, o = r.length; s < o; ++s)i = r[s].closestPointXY(t, e, n, i); return i }, e.prototype.containsXY = function (t, e) { for (var n = this.geometries_, i = 0, r = n.length; i < r; ++i)if (n[i].containsXY(t, e)) return !0; return !1 }, e.prototype.computeExtent = function (t) { Dt(t); for (var e, n, i = this.geometries_, r = 0, s = i.length; r < s; ++r)e = t, (n = i[r].getExtent())[0] < e[0] && (e[0] = n[0]), n[2] > e[2] && (e[2] = n[2]), n[1] < e[1] && (e[1] = n[1]), n[3] > e[3] && (e[3] = n[3]); return t }, e.prototype.getGeometries = function () { return _l(this.geometries_) }, e.prototype.getGeometriesArray = function () { return this.geometries_ }, e.prototype.getGeometriesArrayRecursive = function () { for (var t = [], e = this.geometries_, n = 0, i = e.length; n < i; ++n)e[n].getType() === this.getType() ? t = t.concat(e[n].getGeometriesArrayRecursive()) : t.push(e[n]); return t }, e.prototype.getSimplifiedGeometry = function (t) { if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this; for (var n = [], i = this.geometries_, r = !1, s = 0, o = i.length; s < o; ++s) { var a = i[s], l = a.getSimplifiedGeometry(t); n.push(l), l !== a && (r = !0) } if (r) { var h = new e(null); return h.setGeometriesArray(n), h } return this.simplifiedGeometryMaxMinSquaredTolerance = t, this }, e.prototype.getType = function () { return Me }, e.prototype.intersectsExtent = function (t) { for (var e = this.geometries_, n = 0, i = e.length; n < i; ++n)if (e[n].intersectsExtent(t)) return !0; return !1 }, e.prototype.isEmpty = function () { return 0 === this.geometries_.length }, e.prototype.rotate = function (t, e) { for (var n = this.geometries_, i = 0, r = n.length; i < r; ++i)n[i].rotate(t, e); this.changed() }, e.prototype.scale = function (t, e, n) { var i = n; i || (i = zt(this.getExtent())); for (var r = this.geometries_, s = 0, o = r.length; s < o; ++s)r[s].scale(t, e, i); this.changed() }, e.prototype.setGeometries = function (t) { this.setGeometriesArray(_l(t)) }, e.prototype.setGeometriesArray = function (t) { this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed() }, e.prototype.applyTransform = function (t) { for (var e = this.geometries_, n = 0, i = e.length; n < i; ++n)e[n].applyTransform(t); this.changed() }, e.prototype.translate = function (t, e) { for (var n = this.geometries_, i = 0, r = n.length; i < r; ++i)n[i].translate(t, e); this.changed() }, e.prototype.disposeInternal = function () { this.unlistenGeometriesChange_(), t.prototype.disposeInternal.call(this) }, e }(ki), ml = function () { var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(e, n) }; return function (e, n) { function i() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i) } }(), vl = [0, 0, 0, 0], xl = [], El = "modifystart", Il = "modifyend", Cl = function (t) { function e(e, n, i) { var r = t.call(this, e) || this; return r.features = n, r.mapBrowserEvent = i, r } return ml(e, t), e }(f); function wl(t, e) { return t.index - e.index } function Sl(t, e, n) { var i = e.geometry; if (i.getType() === De) { var r = i; if (1 === e.index) { var s = tn(); s && (r = r.clone().transform(s, n)); var o = ke(r.getCenter(), nn(t, n)), a = Math.sqrt(o) - r.getRadius(); return a * a } } var l = nn(t, n); return xl[0] = nn(e.segment[0], n), xl[1] = nn(e.segment[1], n), je(l, xl) } function bl(t, e, n) { var i = e.geometry; if (i.getType() === De && 1 === e.index) { var r = i, s = tn(); return s && (r = r.clone().transform(s, n)), en(r.getClosestPoint(nn(t, n)), n) } var o = nn(t, n); return xl[0] = nn(e.segment[0], n), xl[1] = nn(e.segment[1], n), en(Ae(o, xl), n) } var Ol = function (t) { function e(e) { var n, i, r = t.call(this, e) || this; if (r.boundHandleFeatureChange_ = r.handleFeatureChange_.bind(r), r.condition_ = e.condition ? e.condition : Ya, r.defaultDeleteCondition_ = function (t) { return function (t) { var e = t.originalEvent; return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey }(t) && Ga(t) }, r.deleteCondition_ = e.deleteCondition ? e.deleteCondition : r.defaultDeleteCondition_, r.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : Aa, r.vertexFeature_ = null, r.vertexSegments_ = null, r.lastPixel_ = [0, 0], r.ignoreNextSingleClick_ = !1, r.modified_ = !1, r.rBush_ = new Jt, r.pixelTolerance_ = void 0 !== e.pixelTolerance ? e.pixelTolerance : 10, r.snappedToVertex_ = !1, r.changingFeature_ = !1, r.dragSegments_ = [], r.overlay_ = new bo({ source: new In({ useSpatialIndex: !1, wrapX: !!e.wrapX }), style: e.style ? e.style : (n = Ri(), function (t, e) { return n[be] }), updateWhileAnimating: !0, updateWhileInteracting: !0 }), r.SEGMENT_WRITERS_ = { Point: r.writePointGeometry_.bind(r), LineString: r.writeLineStringGeometry_.bind(r), LinearRing: r.writeLineStringGeometry_.bind(r), Polygon: r.writePolygonGeometry_.bind(r), MultiPoint: r.writeMultiPointGeometry_.bind(r), MultiLineString: r.writeMultiLineStringGeometry_.bind(r), MultiPolygon: r.writeMultiPolygonGeometry_.bind(r), Circle: r.writeCircleGeometry_.bind(r), GeometryCollection: r.writeGeometryCollectionGeometry_.bind(r) }, r.source_ = null, e.source ? (r.source_ = e.source, i = new Q(r.source_.getFeatures()), r.source_.addEventListener(hn, r.handleSourceAdd_.bind(r)), r.source_.addEventListener(fn, r.handleSourceRemove_.bind(r))) : i = e.features, !i) throw new Error("The modify interaction requires features or a source"); return r.features_ = i, r.features_.forEach(r.addFeature_.bind(r)), r.features_.addEventListener(W, r.handleFeatureAdd_.bind(r)), r.features_.addEventListener(H, r.handleFeatureRemove_.bind(r)), r.lastPointerEvent_ = null, r } return ml(e, t), e.prototype.addFeature_ = function (t) { var e = t.getGeometry(); if (e) { var n = this.SEGMENT_WRITERS_[e.getType()]; n && n(t, e) } var i = this.getMap(); i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i), t.addEventListener(R, this.boundHandleFeatureChange_) }, e.prototype.willModifyFeatures_ = function (t) { this.modified_ || (this.modified_ = !0, this.dispatchEvent(new Cl(El, this.features_, t))) }, e.prototype.removeFeature_ = function (t) { this.removeFeatureSegmentData_(t), this.vertexFeature_ && 0 === this.features_.getLength() && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.removeEventListener(R, this.boundHandleFeatureChange_) }, e.prototype.removeFeatureSegmentData_ = function (t) { var e = this.rBush_, n = []; e.forEach((function (e) { t === e.feature && n.push(e) })); for (var i = n.length - 1; i >= 0; --i) { for (var r = n[i], s = this.dragSegments_.length - 1; s >= 0; --s)this.dragSegments_[s][0] === r && this.dragSegments_.splice(s, 1); e.remove(r) } }, e.prototype.setActive = function (e) { this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.prototype.setActive.call(this, e) }, e.prototype.setMap = function (e) { this.overlay_.setMap(e), t.prototype.setMap.call(this, e) }, e.prototype.getOverlay = function () { return this.overlay_ }, e.prototype.handleSourceAdd_ = function (t) { t.feature && this.features_.push(t.feature) }, e.prototype.handleSourceRemove_ = function (t) { t.feature && this.features_.remove(t.feature) }, e.prototype.handleFeatureAdd_ = function (t) { this.addFeature_(t.element) }, e.prototype.handleFeatureChange_ = function (t) { if (!this.changingFeature_) { var e = t.target; this.removeFeature_(e), this.addFeature_(e) } }, e.prototype.handleFeatureRemove_ = function (t) { var e = t.element; this.removeFeature_(e) }, e.prototype.writePointGeometry_ = function (t, e) { var n = e.getCoordinates(), i = { feature: t, geometry: e, segment: [n, n] }; this.rBush_.insert(e.getExtent(), i) }, e.prototype.writeMultiPointGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) { var s = n[i], o = { feature: t, geometry: e, depth: [i], index: i, segment: [s, s] }; this.rBush_.insert(e.getExtent(), o) } }, e.prototype.writeLineStringGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length - 1; i < r; ++i) { var s = n.slice(i, i + 2), o = { feature: t, geometry: e, index: i, segment: s }; this.rBush_.insert(bt(s), o) } }, e.prototype.writeMultiLineStringGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i)for (var s = n[i], o = 0, a = s.length - 1; o < a; ++o) { var l = s.slice(o, o + 2), h = { feature: t, geometry: e, depth: [i], index: o, segment: l }; this.rBush_.insert(bt(l), h) } }, e.prototype.writePolygonGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i)for (var s = n[i], o = 0, a = s.length - 1; o < a; ++o) { var l = s.slice(o, o + 2), h = { feature: t, geometry: e, depth: [i], index: o, segment: l }; this.rBush_.insert(bt(l), h) } }, e.prototype.writeMultiPolygonGeometry_ = function (t, e) { for (var n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i)for (var s = n[i], o = 0, a = s.length; o < a; ++o)for (var l = s[o], h = 0, c = l.length - 1; h < c; ++h) { var u = l.slice(h, h + 2), f = { feature: t, geometry: e, depth: [o, i], index: h, segment: u }; this.rBush_.insert(bt(u), f) } }, e.prototype.writeCircleGeometry_ = function (t, e) { var n = e.getCenter(), i = { feature: t, geometry: e, index: 0, segment: [n, n] }, r = { feature: t, geometry: e, index: 1, segment: [n, n] }, s = [i, r]; i.featureSegments = s, r.featureSegments = s, this.rBush_.insert(At(n), i); var o = e, a = tn(); if (a && this.getMap()) { var l = this.getMap().getView().getProjection(); o = Mr(o = o.clone().transform(a, l)).transform(l, a) } this.rBush_.insert(o.getExtent(), r) }, e.prototype.writeGeometryCollectionGeometry_ = function (t, e) { for (var n = e.getGeometriesArray(), i = 0; i < n.length; ++i) { var r = n[i]; (0, this.SEGMENT_WRITERS_[r.getType()])(t, r) } }, e.prototype.createOrUpdateVertexFeature_ = function (t) { var e = this.vertexFeature_; e ? e.getGeometry().setCoordinates(t) : (e = new Gr(new Ki(t)), this.vertexFeature_ = e, this.overlay_.getSource().addFeature(e)); return e }, e.prototype.handleEvent = function (e) { return !e.originalEvent || (this.lastPointerEvent_ = e, e.map.getView().getInteracting() || e.type != Do || this.handlingDownUpSequence || this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (n = !(e.type != No || !this.ignoreNextSingleClick_) || this.removePoint()), e.type == No && (this.ignoreNextSingleClick_ = !1), t.prototype.handleEvent.call(this, e) && !n); var n }, e.prototype.handleDragEvent = function (t) { this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(t); for (var e = t.coordinate, n = 0, i = this.dragSegments_.length; n < i; ++n) { for (var r = this.dragSegments_[n], s = r[0], o = s.depth, a = s.geometry, l = void 0, h = s.segment, c = r[1]; e.length < a.getStride();)e.push(h[c][e.length]); switch (a.getType()) { case be: l = e, h[0] = e, h[1] = e; break; case Ne: (l = a.getCoordinates())[s.index] = e, h[0] = e, h[1] = e; break; case Oe: (l = a.getCoordinates())[s.index + c] = e, h[c] = e; break; case Le: case Re: (l = a.getCoordinates())[o[0]][s.index + c] = e, h[c] = e; break; case Pe: (l = a.getCoordinates())[o[1]][o[0]][s.index + c] = e, h[c] = e; break; case De: if (h[0] = e, h[1] = e, 0 === s.index) this.changingFeature_ = !0, a.setCenter(e), this.changingFeature_ = !1; else { this.changingFeature_ = !0; var u = t.map.getView().getProjection(), f = Ge(nn(a.getCenter(), u), nn(e, u)), p = tn(); if (p) { var d = a.clone().transform(p, u); d.setRadius(f), f = d.transform(u, p).getRadius() } a.setRadius(f), this.changingFeature_ = !1 } }l && this.setGeometryCoordinates_(a, l) } this.createOrUpdateVertexFeature_(e) }, e.prototype.handleDownEvent = function (t) { if (!this.condition_(t)) return !1; var e = t.coordinate; this.handlePointerAtPixel_(t.pixel, t.map, e), this.dragSegments_.length = 0, this.modified_ = !1; var n = this.vertexFeature_; if (n) { var i = t.map.getView().getProjection(), r = [], s = n.getGeometry().getCoordinates(), o = bt([s]), a = this.rBush_.getInExtent(o), h = {}; a.sort(wl); for (var c = 0, u = a.length; c < u; ++c) { var f = a[c], p = f.segment, d = l(f.geometry), g = f.depth; if (g && (d += "-" + g.join("-")), h[d] || (h[d] = new Array(2)), f.geometry.getType() !== De || 1 !== f.index) if (!Fe(p[0], s) || h[d][0]) if (!Fe(p[1], s) || h[d][1]) l(p) in this.vertexSegments_ && !h[d][0] && !h[d][1] && this.insertVertexCondition_(t) && r.push([f, s]); else { if ((f.geometry.getType() === Oe || f.geometry.getType() === Le) && h[d][0] && 0 === h[d][0].index) continue; this.dragSegments_.push([f, 1]), h[d][1] = f } else this.dragSegments_.push([f, 0]), h[d][0] = f; else Fe(bl(e, f, i), s) && !h[d][0] && (this.dragSegments_.push([f, 0]), h[d][0] = f) } r.length && this.willModifyFeatures_(t); for (var _ = r.length - 1; _ >= 0; --_)this.insertVertex_.apply(this, r[_]) } return !!this.vertexFeature_ }, e.prototype.handleUpEvent = function (t) { for (var e = this.dragSegments_.length - 1; e >= 0; --e) { var n = this.dragSegments_[e][0], i = n.geometry; if (i.getType() === De) { var r = i.getCenter(), s = n.featureSegments[0], o = n.featureSegments[1]; s.segment[0] = r, s.segment[1] = r, o.segment[0] = r, o.segment[1] = r, this.rBush_.update(At(r), s); var a = i, l = tn(); if (l) { var h = t.map.getView().getProjection(); a = Mr(a = a.clone().transform(l, h)).transform(h, l) } this.rBush_.update(a.getExtent(), o) } else this.rBush_.update(bt(n.segment), n) } return this.modified_ && (this.dispatchEvent(new Cl(Il, this.features_, t)), this.modified_ = !1), !1 }, e.prototype.handlePointerMove_ = function (t) { this.lastPixel_ = t.pixel, this.handlePointerAtPixel_(t.pixel, t.map, t.coordinate) }, e.prototype.handlePointerAtPixel_ = function (t, e, n) { var i = n || e.getCoordinateFromPixel(t), r = e.getView().getProjection(), s = rn(Ot(sn(At(i, vl), r), e.getView().getResolution() * this.pixelTolerance_, vl), r), o = this.rBush_.getInExtent(s); if (o.length > 0) { o.sort((function (t, e) { return Sl(i, t, r) - Sl(i, e, r) })); var a = o[0], h = a.segment, c = bl(i, a, r), u = e.getPixelFromCoordinate(c), f = Ge(t, u); if (f <= this.pixelTolerance_) { var p = {}; if (a.geometry.getType() === De && 1 === a.index) this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(c); else { var d = e.getPixelFromCoordinate(h[0]), g = e.getPixelFromCoordinate(h[1]), _ = ke(u, d), y = ke(u, g); f = Math.sqrt(Math.min(_, y)), this.snappedToVertex_ = f <= this.pixelTolerance_, this.snappedToVertex_ && (c = _ > y ? h[1] : h[0]), this.createOrUpdateVertexFeature_(c); for (var m = 1, v = o.length; m < v; ++m) { var x = o[m].segment; if (!(Fe(h[0], x[0]) && Fe(h[1], x[1]) || Fe(h[0], x[1]) && Fe(h[1], x[0]))) break; p[l(x)] = !0 } } return p[l(h)] = !0, void (this.vertexSegments_ = p) } } this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null) }, e.prototype.insertVertex_ = function (t, e) { for (var n, i = t.segment, r = t.feature, s = t.geometry, o = t.depth, a = t.index; e.length < s.getStride();)e.push(0); switch (s.getType()) { case Le: case Re: (n = s.getCoordinates())[o[0]].splice(a + 1, 0, e); break; case Pe: (n = s.getCoordinates())[o[1]][o[0]].splice(a + 1, 0, e); break; case Oe: (n = s.getCoordinates()).splice(a + 1, 0, e); break; default: return }this.setGeometryCoordinates_(s, n); var l = this.rBush_; l.remove(t), this.updateSegmentIndices_(s, a, o, 1); var h = { segment: [i[0], e], feature: r, geometry: s, depth: o, index: a }; l.insert(bt(h.segment), h), this.dragSegments_.push([h, 1]); var c = { segment: [e, i[1]], feature: r, geometry: s, depth: o, index: a + 1 }; l.insert(bt(c.segment), c), this.dragSegments_.push([c, 0]), this.ignoreNextSingleClick_ = !0 }, e.prototype.removePoint = function () { if (this.lastPointerEvent_ && this.lastPointerEvent_.type != Mo) { var t = this.lastPointerEvent_; this.willModifyFeatures_(t); var e = this.removeVertex_(); return this.dispatchEvent(new Cl(Il, this.features_, t)), this.modified_ = !1, e } return !1 }, e.prototype.removeVertex_ = function () { var t, e, n, i, r, s, o, a, h, c, u, f = this.dragSegments_, p = {}, d = !1; for (r = f.length - 1; r >= 0; --r)u = l((c = (n = f[r])[0]).feature), c.depth && (u += "-" + c.depth.join("-")), u in p || (p[u] = {}), 0 === n[1] ? (p[u].right = c, p[u].index = c.index) : 1 == n[1] && (p[u].left = c, p[u].index = c.index + 1); for (u in p) { switch (h = p[u].right, o = p[u].left, (a = (s = p[u].index) - 1) < 0 && (a = 0), t = e = (i = (c = void 0 !== o ? o : h).geometry).getCoordinates(), d = !1, i.getType()) { case Le: e[c.depth[0]].length > 2 && (e[c.depth[0]].splice(s, 1), d = !0); break; case Oe: e.length > 2 && (e.splice(s, 1), d = !0); break; case Pe: t = t[c.depth[1]]; case Re: (t = t[c.depth[0]]).length > 4 && (s == t.length - 1 && (s = 0), t.splice(s, 1), d = !0, 0 === s && (t.pop(), t.push(t[0]), a = t.length - 1)) }if (d) { this.setGeometryCoordinates_(i, e); var g = []; if (void 0 !== o && (this.rBush_.remove(o), g.push(o.segment[0])), void 0 !== h && (this.rBush_.remove(h), g.push(h.segment[1])), void 0 !== o && void 0 !== h) { var _ = { depth: c.depth, feature: c.feature, geometry: c.geometry, index: a, segment: g }; this.rBush_.insert(bt(_.segment), _) } this.updateSegmentIndices_(i, s, c.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), f.length = 0 } } return d }, e.prototype.setGeometryCoordinates_ = function (t, e) { this.changingFeature_ = !0, t.setCoordinates(e), this.changingFeature_ = !1 }, e.prototype.updateSegmentIndices_ = function (t, e, n, i) { this.rBush_.forEachInExtent(t.getExtent(), (function (r) { r.geometry === t && (void 0 === n || void 0 === r.depth || v(r.depth, n)) && r.index > e && (r.index += i) })) }, e }(Go); function Tl(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function Rl(t, e, n) { return (Rl = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Fl(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function Nl(t) { return (Nl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Ll(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Pl(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Ml(t, e) } function Ml(t, e) { return (Ml = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Dl(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Fl(t); if (e) { var r = Fl(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return Al(this, n) } } function Al(t, e) { return !e || "object" !== Nl(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Fl(t) { return (Fl = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var kl = "select", Gl = function (t) { Pl(n, t); var e = Dl(n); function n(t, i, r, s) { var o; return Ll(this, n), (o = e.call(this, t)).selected = i, o.deselected = r, o.mapBrowserEvent = s, o } return n }(f); function jl(t) { if (!this.condition_(t)) return !0; var e = this.addCondition_(t), n = this.removeCondition_(t), i = this.toggleCondition_(t), r = !e && !n && !i, s = t.map, o = this.getFeatures(), a = [], l = []; if (r) { w(this.featureLayerAssociation_), s.forEachFeatureAtPixel(t.pixel, function (t, e) { if (e && this.filter_(t, e)) return l.push(t), this.addFeatureLayerAssociation_(t, e), !this.multi_ }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }); for (var h = o.getLength() - 1; h >= 0; --h) { var c = o.item(h), u = l.indexOf(c); u > -1 ? l.splice(u, 1) : (o.remove(c), a.push(c)) } 0 !== l.length && o.extend(l) } else { s.forEachFeatureAtPixel(t.pixel, function (t, r) { if (r && this.filter_(t, r)) return !e && !i || _(o.getArray(), t) ? (n || i) && _(o.getArray(), t) && (a.push(t), this.removeFeatureLayerAssociation_(t)) : (l.push(t), this.addFeatureLayerAssociation_(t, r)), !this.multi_ }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }); for (var f = a.length - 1; f >= 0; --f)o.remove(a[f]); o.extend(l) } return (l.length > 0 || a.length > 0) && this.dispatchEvent(new Gl(kl, l, a, t)), function (t) { return "pointermove" == t.type }(t) } function Bl() { var t = Ri(); return m(t[Re], t[Oe]), m(t[Me], t[Oe]), function (e, n) { return e.getGeometry() ? t[e.getGeometry().getType()] : null } } var Yl = function (t) { Pl(s, t); var e, n, i, r = Dl(s); function s(t) { var e; Ll(this, s); var n = t || {}; (e = r.call(this, { handleEvent: jl })).condition_ = n.condition ? n.condition : Ga, e.addCondition_ = n.addCondition ? n.addCondition : ka, e.removeCondition_ = n.removeCondition ? n.removeCondition : ka, e.toggleCondition_ = n.toggleCondition ? n.toggleCondition : Ba, e.multi_ = !!n.multi && n.multi, e.filter_ = n.filter ? n.filter : x, e.hitTolerance_ = n.hitTolerance ? n.hitTolerance : 0; var i, o = new bo({ source: new In({ useSpatialIndex: !1, features: n.features, wrapX: n.wrapX }), style: n.style ? n.style : Bl(), updateWhileAnimating: !0, updateWhileInteracting: !0 }); if (e.featureOverlay_ = o, n.layers) if ("function" == typeof n.layers) i = n.layers; else { var a = n.layers; i = function (t) { return _(a, t) } } else i = x; return e.layerFilter_ = i, e.featureLayerAssociation_ = {}, e } return e = s, (n = [{ key: "addFeatureLayerAssociation_", value: function (t, e) { this.featureLayerAssociation_[l(t)] = e } }, { key: "getFeatures", value: function () { return this.featureOverlay_.getSource().getFeaturesCollection() } }, { key: "getHitTolerance", value: function () { return this.hitTolerance_ } }, { key: "getLayer", value: function (t) { return this.featureLayerAssociation_[l(t)] } }, { key: "getOverlay", value: function () { return this.featureOverlay_ } }, { key: "setHitTolerance", value: function (t) { this.hitTolerance_ = t } }, { key: "setMap", value: function (t) { Rl(Fl(s.prototype), "setMap", this).call(this, t), this.featureOverlay_.setMap(t) } }, { key: "removeFeatureLayerAssociation_", value: function (t) { delete this.featureLayerAssociation_[l(t)] } }]) && Tl(e.prototype, n), i && Tl(e, i), s }(Ro), ql = n(11), Xl = n.n(ql); function zl(t) { return (zl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Ul(t, e) { return (Ul = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Vl(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Hl(t); if (e) { var r = Hl(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return Wl(this, n) } } function Wl(t, e) { return !e || "object" !== zl(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Hl(t) { return (Hl = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Kl = "movestart", Zl = "moveend", Jl = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Ul(t, e) }(n, t); var e = Vl(n); function n(t, i, r) { var s; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, n), (s = e.call(this, t)).feature = i, s.mapBrowserEvent = r, s } return n }(f); function Ql(t) { return (Ql = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function $l(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function th(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function eh(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function nh(t, e, n) { return (nh = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = ah(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function ih(t, e) { return (ih = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function rh(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = ah(t); if (e) { var r = ah(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return sh(this, n) } } function sh(t, e) { return !e || "object" !== Ql(e) && "function" != typeof e ? oh(t) : e } function oh(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function ah(t) { return (ah = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function lh(t) { return function (t) { if (Array.isArray(t)) return hh(t) }(t) || function (t) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t) }(t) || function (t, e) { if (!t) return; if ("string" == typeof t) return hh(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hh(t, e) }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function hh(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, i = new Array(e); n < e; n++)i[n] = t[n]; return i } var ch = function (t, e) { if (!t) return []; var n = t; return "function" == typeof t && (n = e ? t(e) : t()), Array.isArray(n) ? n : [n] }, uh = new Li({ image: new Ci({ radius: 5, fill: new wi({ color: "#05A0FF" }), stroke: new Si({ color: "#05A0FF", width: 2 }) }), stroke: new Si({ color: "#05A0FF", width: 3 }), fill: new wi({ color: "rgba(255,255,255,0.4)" }), geometry: function (t) { var e = [], n = t.getGeometry(), i = [n]; return n.getType() === Me && (i = n.getGeometriesArrayRecursive()), i.forEach((function (t) { var n = [t]; t.getType() === Le ? n = t.getLineStrings() : t.getType() === Pe ? n = t.getPolygons() : t.getType() === Ne && (n = t.getPoints()), n.forEach((function (t) { t.getType() === Re ? t.getCoordinates()[0].forEach((function (t) { e.push(t) })) : t.getType() === Oe ? e.push.apply(e, lh(t.getCoordinates())) : t.getType() === be && e.push(t.getCoordinates()) })) })), new yl([t.getGeometry(), new Fr(e)]) } }), fh = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && ih(t, e) }(s, t); var e, n, i, r = rh(s); function s(t) { var e; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), e = r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? $l(Object(n), !0).forEach((function (e) { th(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $l(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Modify geometry", className: "ole-control-modify", image: Xl.a }, t)); var n; e.coordinate = null, e.previousCursor = null, e.hitTolerance = void 0 === t.hitTolerance ? 5 : t.hitTolerance, e.selectMoveStyle = t.selectMoveStyle, e.selectModifyStyle = t.selectModifyStyle || uh, e.modifyStyle = t.modifyStyle, e.deleteFeature = e.deleteFeature.bind(oh(e)), e.cursorHandler = e.cursorHandler.bind(oh(e)), e.cursorTimeout = null, e.deleteCondition = t.deleteCondition || function (t) { return 46 === t.keyCode || 8 === t.keyCode }, e.deleteNodeCondition = t.deleteNodeCondition || Fa, e.selectFilter = t.selectFilter || function (t, n) { return !n || !e.layerFilter || e.layerFilter(n) }, e.getFeatureFilter = t.getFeatureFilter || function () { return !0 }, e.onMapClick = t.onMapClick, e.getFeatureAtPixel = function (t) { var n = (e.map.getFeaturesAtPixel(t, { hitTolerance: e.hitTolerance, layerFilter: e.layerFilter }) || [])[0]; return e.getFeatureFilter(n) ? n : null }, e.isHoverVertexFeatureAtPixel = function (t) { var n = !1; return e.map.forEachFeatureAtPixel(t, (function (t, e) { return !e && (n = !0, !0) }), { hitTolerance: e.hitTolerance }), n }, e.applySelectStyle = function (t, e) { var n = ch(t.getStyleFunction()), i = ch(e, t), r = [].concat(lh(n), lh(i)); t.set("oldStyles", n), t.setStyle(r) }, e.onSelectFeature = function (t, n, i) { if (t.getStyleFunction()) { e.applySelectStyle(t, n); var r = t.get(i); r && (j(r), t.unset(r)), t.set(i, t.on("change", (function (t) { e.onSelectedFeatureChange(t.target, n) }))) } }, e.onDeselectFeature = function (t, e, n) { if (t.getStyleFunction()) { var i = t.get(n); i && (j(i), t.unset(i)), t.unset("oldStyles"); var r = ch(t.getStyleFunction(), null), s = ch(e, t), o = r.slice(0, r.indexOf(s[0])); t.setStyle(o) } }, e.onSelectedFeatureChange = function (t, n) { var i = ch(t.getStyleFunction()), r = t.get("oldStyles"); r && (r.some((function (t, e) { return t !== i[e] })) && e.applySelectStyle(t, n)) }, e.selectMove = new Yl({ condition: t.moveCondition || Ga, toggleCondition: t.moveToggleCondition || Ba, filter: function (t, n) { return !e.isSelectedByModify(t) && e.selectFilter(t, n) }, style: e.selectMoveStyle, hitTolerance: e.hitTolerance, wrapX: !1 }), e.selectMove.getFeatures().on("add", (function (t) { e.selectModify.getFeatures().clear(), document.addEventListener("keydown", e.deleteFeature), e.map.addInteraction(e.moveInteraction), j(n), n = e.map.on("singleclick", (function (t) { e.unselectInteraction(t, e.selectMove) })), e.selectMoveStyle && e.onSelectFeature(t.element, e.selectMoveStyle, "selectMoveOnChangeKey") })), e.selectMove.getFeatures().on("remove", (function (t) { document.removeEventListener("keydown", e.deleteFeature), e.map.removeInteraction(e.moveInteraction), j(n), e.selectMoveStyle && e.onDeselectFeature(t.element, e.selectMoveStyle, "selectMoveOnChangeKey") })); var i; return e.selectModify = new Yl({ condition: t.modifyCondition || function (t) { return function (t) { return "dblclick" === t.type && e.map.hasFeatureAtPixel(t.pixel) }(t) }, toggleCondition: t.modifyToggleCondition || Ba, filter: e.selectFilter, style: e.selectModifyStyle, hitTolerance: e.hitTolerance, wrapX: !1 }), e.selectModify.getFeatures().on("add", (function (t) { e.selectMove.getFeatures().clear(), document.addEventListener("keydown", e.deleteFeature), e.map.addInteraction(e.modifyInteraction), j(i), i = e.map.on("singleclick", (function (t) { e.unselectInteraction(t, e.selectModify) })), e.selectModifyStyle && e.onSelectFeature(t.element, e.selectModifyStyle, "selectModifyOnChangeKey") })), e.selectModify.getFeatures().on("remove", (function (t) { document.removeEventListener("keydown", e.deleteFeature), e.map.removeInteraction(e.modifyInteraction), j(i), e.selectModifyStyle && e.onDeselectFeature(t.element, e.selectModifyStyle, "selectModifyOnChangeKey") })), e.modifyInteraction = new Ol({ features: e.selectModify.getFeatures(), style: e.modifyStyle, deleteCondition: function (t) { return e.deleteNodeCondition(t) && (e.deleteNode = !0), e.deleteNodeCondition(t) } }), e.modifyInteraction.on("modifystart", (function (t) { e.editor.setEditFeature(t.features.item(0)), e.isModifying = !0 })), e.modifyInteraction.on("modifyend", (function () { e.editor.setEditFeature(null), e.isModifying = !1 })), e.moveInteraction = new Go({ handleDownEvent: e.startMoveFeature.bind(oh(e)), handleDragEvent: e.moveFeature.bind(oh(e)), handleUpEvent: e.stopMoveFeature.bind(oh(e)) }), e } return e = s, (n = [{ key: "deleteFeature", value: function (t) { var e, n = this; !/textarea|input/i.test(t.target.nodeName) && this.deleteCondition(t) && (this.selectMove.getFeatures().getArray().length > 0 ? e = this.selectMove.getFeatures() : this.selectModify.getFeatures().getArray().length > 0 && (e = this.selectModify.getFeatures()), e && (e.getArray().forEach((function (t, i) { return n.source.removeFeature(e.getArray()[i]) })), this.changeCursor(null), e.clear(), t.stopPropagation(), t.preventDefault())) } }, { key: "isSelectedByMove", value: function (t) { return -1 !== this.selectMove.getFeatures().getArray().indexOf(t) } }, { key: "isSelectedByModify", value: function (t) { return -1 !== this.selectModify.getFeatures().getArray().indexOf(t) } }, { key: "startMoveFeature", value: function (t) { if (this.featureToMove = this.getFeatureAtPixel(t.pixel), this.featureToMove && this.isSelectedByMove(this.featureToMove)) { if (this.featureToMove.getGeometry() instanceof Ki) { var e = this.featureToMove.getGeometry().getExtent(); this.coordinate = zt(e) } else this.coordinate = t.coordinate; return this.editor.setEditFeature(this.featureToMove), this.isMoving = !0, this.moveInteraction.dispatchEvent(new Jl(Kl, this.featureToMove, t)), !0 } return !1 } }, { key: "moveFeature", value: function (t) { var e = t.coordinate[0] - this.coordinate[0], n = t.coordinate[1] - this.coordinate[1]; this.featureToMove.getGeometry().translate(e, n), this.coordinate = t.coordinate } }, { key: "stopMoveFeature", value: function (t) { return this.moveInteraction.dispatchEvent(new Jl(Zl, this.featureToMove, t)), this.coordinate = null, this.editor.setEditFeature(null), this.isMoving = !1, this.featureToMove = null, !1 } }, { key: "cursorHandler", value: function (t) { var e = this; this.cursorTimeout && clearTimeout(this.cursorTimeout), this.cursorTimeout = setTimeout((function () { if (t.dragging || e.isMoving || e.isModifying) e.changeCursor("grabbing"); else { var n = e.getFeatureAtPixel(t.pixel); if (!n) return e.changeCursor(e.previousCursor), void (e.previousCursor = null); e.isSelectedByMove(n) ? e.changeCursor("grab") : e.isSelectedByModify(n) ? e.isHoverVertexFeatureAtPixel(t.pixel) ? e.changeCursor("grab") : e.changeCursor(e.previousCursor) : e.changeCursor("pointer") } }), 50) } }, { key: "unselectInteraction", value: function (t, e) { if (this.deleteNode) this.deleteNode = !1; else if (!this.map.hasFeatureAtPixel(t.pixel)) { if (this.onMapClick) return t.stopPropagation(), t.preventDefault(), void this.onMapClick(t, this); e.getFeatures().clear() } } }, { key: "changeCursor", value: function (t) { var e = this.map.getTargetElement(); (e.style.cursor || t) && e.style.cursor !== t && (null === this.previousCursor && (this.previousCursor = e.style.cursor), e.style.cursor = t) } }, { key: "activate", value: function () { nh(ah(s.prototype), "activate", this).call(this), clearTimeout(this.cursorTimeout), this.map.on("pointermove", this.cursorHandler), this.map.addInteraction(this.selectMove), this.map.addInteraction(this.selectModify) } }, { key: "deactivate", value: function (t) { clearTimeout(this.cursorTimeout), this.map.un("pointermove", this.cursorHandler), this.selectMove.getFeatures().clear(), this.selectModify.getFeatures().clear(), this.map.removeInteraction(this.selectMove), this.map.removeInteraction(this.selectModify), nh(ah(s.prototype), "deactivate", this).call(this, t) } }]) && eh(e.prototype, n), i && eh(e, i), s }(Dn); class ph { static equalsWithTolerance(t, e, n) { return Math.abs(t - e) <= n } } class dh extends Error { constructor(t) { super(t), this.name = Object.keys({ Exception: dh })[0] } toString() { return this.message } } class gh extends dh { constructor(t) { super(t), this.name = Object.keys({ IllegalArgumentException: gh })[0] } } class _h { constructor(t, e) { this.low = e || 0, this.high = t || 0 } static toBinaryString(t) { let e, n = ""; for (e = 2147483648; e > 0; e >>>= 1)n += (t.high & e) === e ? "1" : "0"; for (e = 2147483648; e > 0; e >>>= 1)n += (t.low & e) === e ? "1" : "0"; return n } } function yh() { } function mh() { } function vh() { } function xh() { } function Eh() { } yh.NaN = NaN, yh.isNaN = t => Number.isNaN(t), yh.isInfinite = t => !Number.isFinite(t), yh.MAX_VALUE = Number.MAX_VALUE, "function" == typeof Float64Array && "function" == typeof Int32Array ? function () { const t = new Float64Array(1), e = new Int32Array(t.buffer); yh.doubleToLongBits = function (n) { t[0] = n; let i = 0 | e[0], r = 0 | e[1]; return 2146435072 == (2146435072 & r) && 0 != (1048575 & r) && 0 !== i && (i = 0, r = 2146959360), new _h(r, i) }, yh.longBitsToDouble = function (n) { return e[0] = n.low, e[1] = n.high, t[0] } }() : function () { const t = Math.log2, e = Math.floor, n = Math.pow, i = function () { for (let i = 53; i > 0; i--) { const r = n(2, i) - 1; if (e(t(r)) + 1 === i) return r } return 0 }(); yh.doubleToLongBits = function (r) { let s, o, a, l, h, c, u, f, p; if (r < 0 || 1 / r === Number.NEGATIVE_INFINITY ? (c = 1 << 31, r = -r) : c = 0, 0 === r) return p = 0, f = c, new _h(f, p); if (r === 1 / 0) return p = 0, f = 2146435072 | c, new _h(f, p); if (r != r) return p = 0, f = 2146959360, new _h(f, p); if (l = 0, p = 0, s = e(r), s > 1) if (s <= i) l = e(t(s)), l <= 20 ? (p = 0, f = s << 20 - l & 1048575) : (a = l - 20, o = n(2, a), p = s % o << 32 - a, f = s / o & 1048575); else for (a = s, p = 0; o = a / 2, a = e(o), 0 !== a;)l++, p >>>= 1, p |= (1 & f) << 31, f >>>= 1, o !== a && (f |= 524288); if (u = l + 1023, h = 0 === s, s = r - s, l < 52 && 0 !== s) for (a = 0; ;) { if (o = 2 * s, o >= 1 ? (s = o - 1, h ? (u--, h = !1) : (a <<= 1, a |= 1, l++)) : (s = o, h ? 0 == --u && (l++, h = !1) : (a <<= 1, l++)), 20 === l) f |= a, a = 0; else if (52 === l) { p |= a; break } if (1 === o) { l < 20 ? f |= a << 20 - l : l < 52 && (p |= a << 52 - l); break } } return f |= u << 20, f |= c, new _h(f, p) }, yh.longBitsToDouble = function (t) { let e, i, r, s; const o = t.high, a = t.low, l = o & 1 << 31 ? -1 : 1; for (r = ((2146435072 & o) >> 20) - 1023, s = 0, i = 1 << 19, e = 1; e <= 20; e++)o & i && (s += n(2, -e)), i >>>= 1; for (i = 1 << 31, e = 21; e <= 52; e++)a & i && (s += n(2, -e)), i >>>= 1; if (-1023 === r) { if (0 === s) return 0 * l; r = -1022 } else { if (1024 === r) return 0 === s ? l / 0 : NaN; s += 1 } return l * s * n(2, r) } }(); class Ih extends dh { constructor(t) { super(t), this.name = Object.keys({ RuntimeException: Ih })[0] } } class Ch extends Ih { constructor() { super(), Ch.constructor_.apply(this, arguments) } static constructor_() { if (0 === arguments.length) Ih.constructor_.call(this); else if (1 === arguments.length) { const t = arguments[0]; Ih.constructor_.call(this, t) } } } class wh { static shouldNeverReachHere() { if (0 === arguments.length) wh.shouldNeverReachHere(null); else if (1 === arguments.length) { const t = arguments[0]; throw new Ch("Should never reach here" + (null !== t ? ": " + t : "")) } } static isTrue() { if (1 === arguments.length) { const t = arguments[0]; wh.isTrue(t, null) } else if (2 === arguments.length) { const t = arguments[1]; if (!arguments[0]) throw null === t ? new Ch : new Ch(t) } } static equals() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; wh.equals(t, e, null) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; if (!e.equals(t)) throw new Ch("Expected " + t + " but encountered " + e + (null !== n ? ": " + n : "")) } } } const Sh = new ArrayBuffer(8), bh = new Float64Array(Sh), Oh = new Int32Array(Sh); class Th { constructor() { Th.constructor_.apply(this, arguments) } static constructor_() { if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) Th.constructor_.call(this, 0, 0); else if (1 === arguments.length) { const t = arguments[0]; Th.constructor_.call(this, t.x, t.y, t.getZ()) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; Th.constructor_.call(this, t, e, Th.NULL_ORDINATE) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this.x = t, this.y = e, this.z = n } } static hashCode(t) { return bh[0] = t, Oh[0] ^ Oh[1] } getM() { return yh.NaN } setOrdinate(t, e) { switch (t) { case Th.X: this.x = e; break; case Th.Y: this.y = e; break; case Th.Z: this.setZ(e); break; default: throw new gh("Invalid ordinate index: " + t) } } equals2D() { if (1 === arguments.length) { const t = arguments[0]; return this.x === t.x && this.y === t.y } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return !!ph.equalsWithTolerance(this.x, t.x, e) && !!ph.equalsWithTolerance(this.y, t.y, e) } } setM(t) { throw new gh("Invalid ordinate index: " + Th.M) } getZ() { return this.z } getOrdinate(t) { switch (t) { case Th.X: return this.x; case Th.Y: return this.y; case Th.Z: return this.getZ() }throw new gh("Invalid ordinate index: " + t) } equals3D(t) { return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || yh.isNaN(this.getZ()) && yh.isNaN(t.getZ())) } equals(t) { return t instanceof Th && this.equals2D(t) } equalInZ(t, e) { return ph.equalsWithTolerance(this.getZ(), t.getZ(), e) } setX(t) { this.x = t } compareTo(t) { const e = t; return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0 } getX() { return this.x } setZ(t) { this.z = t } clone() { try { return null } catch (t) { if (t instanceof CloneNotSupportedException) return wh.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null; throw t } } copy() { return new Th(this) } toString() { return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")" } distance3D(t) { const e = this.x - t.x, n = this.y - t.y, i = this.getZ() - t.getZ(); return Math.sqrt(e * e + n * n + i * i) } getY() { return this.y } setY(t) { this.y = t } distance(t) { const e = this.x - t.x, n = this.y - t.y; return Math.sqrt(e * e + n * n) } hashCode() { let t = 17; return t = 37 * t + Th.hashCode(this.x), t = 37 * t + Th.hashCode(this.y), t } setCoordinate(t) { this.x = t.x, this.y = t.y, this.z = t.getZ() } get interfaces_() { return [mh, vh, Eh] } } class Rh { constructor() { Rh.constructor_.apply(this, arguments) } static constructor_() { if (this._dimensionsToTest = 2, 0 === arguments.length) Rh.constructor_.call(this, 2); else if (1 === arguments.length) { const t = arguments[0]; if (2 !== t && 3 !== t) throw new gh("only 2 or 3 dimensions may be specified"); this._dimensionsToTest = t } } static compare(t, e) { return t < e ? -1 : t > e ? 1 : yh.isNaN(t) ? yh.isNaN(e) ? 0 : -1 : yh.isNaN(e) ? 1 : 0 } compare(t, e) { const n = Rh.compare(t.x, e.x); if (0 !== n) return n; const i = Rh.compare(t.y, e.y); if (0 !== i) return i; if (this._dimensionsToTest <= 2) return 0; return Rh.compare(t.getZ(), e.getZ()) } get interfaces_() { return [xh] } } Th.DimensionalComparator = Rh, Th.NULL_ORDINATE = yh.NaN, Th.X = 0, Th.Y = 1, Th.Z = 2, Th.M = 3; var Nh = function (t, e) { return t.interfaces_ && t.interfaces_.indexOf(e) > -1 }; class Lh { getM(t) { if (this.hasM()) { const e = this.getDimension() - this.getMeasures(); return this.getOrdinate(t, e) } return yh.NaN } setOrdinate(t, e, n) { } getZ(t) { return this.hasZ() ? this.getOrdinate(t, 2) : yh.NaN } size() { } getOrdinate(t, e) { } getCoordinate() { if (1 === arguments.length) { } else if (2 === arguments.length) { } } getCoordinateCopy(t) { } createCoordinate() { } getDimension() { } hasM() { return this.getMeasures() > 0 } getX(t) { } hasZ() { return this.getDimension() - this.getMeasures() > 2 } getMeasures() { return 0 } expandEnvelope(t) { } copy() { } getY(t) { } toCoordinateArray() { } get interfaces_() { return [vh] } } Lh.X = 0, Lh.Y = 1, Lh.Z = 2, Lh.M = 3; class Ph { create() { if (1 === arguments.length) { if (arguments[0] instanceof Array) { } else if (Nh(arguments[0], Lh)) { } } else if (2 === arguments.length) { } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1]; return this.create(t, e) } } } class Mh { filter(t) { } } class Dh { constructor() { Dh.constructor_.apply(this, arguments) } static constructor_() { if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init(); else if (1 === arguments.length) { if (arguments[0] instanceof Th) { const t = arguments[0]; this.init(t.x, t.x, t.y, t.y) } else if (arguments[0] instanceof Dh) { const t = arguments[0]; this.init(t) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.init(t.x, e.x, t.y, e.y) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; this.init(t, e, n, i) } } static intersects() { if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y) } if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; let r = Math.min(n.x, i.x), s = Math.max(n.x, i.x), o = Math.min(t.x, e.x), a = Math.max(t.x, e.x); return !(o > s) && (!(a < r) && (r = Math.min(n.y, i.y), s = Math.max(n.y, i.y), o = Math.min(t.y, e.y), a = Math.max(t.y, e.y), !(o > s) && !(a < r))) } } getArea() { return this.getWidth() * this.getHeight() } equals(t) { if (!(t instanceof Dh)) return !1; const e = t; return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY() } intersection(t) { if (this.isNull() || t.isNull() || !this.intersects(t)) return new Dh; const e = this._minx > t._minx ? this._minx : t._minx, n = this._miny > t._miny ? this._miny : t._miny, i = this._maxx < t._maxx ? this._maxx : t._maxx, r = this._maxy < t._maxy ? this._maxy : t._maxy; return new Dh(e, i, n, r) } isNull() { return this._maxx < this._minx } getMaxX() { return this._maxx } covers() { if (1 === arguments.length) { if (arguments[0] instanceof Th) { const t = arguments[0]; return this.covers(t.x, t.y) } if (arguments[0] instanceof Dh) { const t = arguments[0]; return !this.isNull() && !t.isNull() && (t.getMinX() >= this._minx && t.getMaxX() <= this._maxx && t.getMinY() >= this._miny && t.getMaxY() <= this._maxy) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return !this.isNull() && (t >= this._minx && t <= this._maxx && e >= this._miny && e <= this._maxy) } } intersects() { if (1 === arguments.length) { if (arguments[0] instanceof Dh) { const t = arguments[0]; return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny) } if (arguments[0] instanceof Th) { const t = arguments[0]; return this.intersects(t.x, t.y) } } else if (2 === arguments.length) { if (arguments[0] instanceof Th && arguments[1] instanceof Th) { const t = arguments[0], e = arguments[1]; if (this.isNull()) return !1; if ((t.x < e.x ? t.x : e.x) > this._maxx) return !1; if ((t.x > e.x ? t.x : e.x) < this._minx) return !1; if ((t.y < e.y ? t.y : e.y) > this._maxy) return !1; return !((t.y > e.y ? t.y : e.y) < this._miny) } if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; return !this.isNull() && !(t > this._maxx || t < this._minx || e > this._maxy || e < this._miny) } } } getMinY() { return this._miny } getDiameter() { if (this.isNull()) return 0; const t = this.getWidth(), e = this.getHeight(); return Math.sqrt(t * t + e * e) } getMinX() { return this._minx } expandToInclude() { if (1 === arguments.length) { if (arguments[0] instanceof Th) { const t = arguments[0]; this.expandToInclude(t.x, t.y) } else if (arguments[0] instanceof Dh) { const t = arguments[0]; if (t.isNull()) return null; this.isNull() ? (this._minx = t.getMinX(), this._maxx = t.getMaxX(), this._miny = t.getMinY(), this._maxy = t.getMaxY()) : (t._minx < this._minx && (this._minx = t._minx), t._maxx > this._maxx && (this._maxx = t._maxx), t._miny < this._miny && (this._miny = t._miny), t._maxy > this._maxy && (this._maxy = t._maxy)) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.isNull() ? (this._minx = t, this._maxx = t, this._miny = e, this._maxy = e) : (t < this._minx && (this._minx = t), t > this._maxx && (this._maxx = t), e < this._miny && (this._miny = e), e > this._maxy && (this._maxy = e)) } } minExtent() { if (this.isNull()) return 0; const t = this.getWidth(), e = this.getHeight(); return t < e ? t : e } getWidth() { return this.isNull() ? 0 : this._maxx - this._minx } compareTo(t) { const e = t; return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0 } translate(t, e) { if (this.isNull()) return null; this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e) } copy() { return new Dh(this) } toString() { return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]" } setToNull() { this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1 } disjoint(t) { return !(!this.isNull() && !t.isNull()) || (t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny) } getHeight() { return this.isNull() ? 0 : this._maxy - this._miny } maxExtent() { if (this.isNull()) return 0; const t = this.getWidth(), e = this.getHeight(); return t > e ? t : e } expandBy() { if (1 === arguments.length) { const t = arguments[0]; this.expandBy(t, t) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; if (this.isNull()) return null; this._minx -= t, this._maxx += t, this._miny -= e, this._maxy += e, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull() } } contains() { if (1 === arguments.length) { if (arguments[0] instanceof Dh) { const t = arguments[0]; return this.covers(t) } if (arguments[0] instanceof Th) { const t = arguments[0]; return this.covers(t) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return this.covers(t, e) } } centre() { return this.isNull() ? null : new Th((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2) } init() { if (0 === arguments.length) this.setToNull(); else if (1 === arguments.length) { if (arguments[0] instanceof Th) { const t = arguments[0]; this.init(t.x, t.x, t.y, t.y) } else if (arguments[0] instanceof Dh) { const t = arguments[0]; this._minx = t._minx, this._maxx = t._maxx, this._miny = t._miny, this._maxy = t._maxy } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.init(t.x, e.x, t.y, e.y) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; t < e ? (this._minx = t, this._maxx = e) : (this._minx = e, this._maxx = t), n < i ? (this._miny = n, this._maxy = i) : (this._miny = i, this._maxy = n) } } getMaxY() { return this._maxy } distance(t) { if (this.intersects(t)) return 0; let e = 0; this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx); let n = 0; return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n) } hashCode() { let t = 17; return t = 37 * t + Th.hashCode(this._minx), t = 37 * t + Th.hashCode(this._maxx), t = 37 * t + Th.hashCode(this._miny), t = 37 * t + Th.hashCode(this._maxy), t } get interfaces_() { return [mh, Eh] } } class Ah { constructor() { Ah.constructor_.apply(this, arguments) } isGeometryCollection() { return this.getTypeCode() === Ah.TYPECODE_GEOMETRYCOLLECTION } getFactory() { return this._factory } getGeometryN(t) { return this } getArea() { return 0 } isRectangle() { return !1 } equalsExact(t) { return this === t || this.equalsExact(t, 0) } geometryChanged() { this.apply(Ah.geometryChangedFilter) } geometryChangedAction() { this._envelope = null } equalsNorm(t) { return null !== t && this.norm().equalsExact(t.norm()) } getLength() { return 0 } getNumGeometries() { return 1 } compareTo() { let t; if (1 === arguments.length) { const e = arguments[0]; return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e) } if (2 === arguments.length) { const e = arguments[0], n = arguments[1]; return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e, n) } } getUserData() { return this._userData } getSRID() { return this._SRID } getEnvelope() { return this.getFactory().toGeometry(this.getEnvelopeInternal()) } checkNotGeometryCollection(t) { if (t.getTypeCode() === Ah.TYPECODE_GEOMETRYCOLLECTION) throw new gh("This method does not support GeometryCollection arguments") } equal(t, e, n) { return 0 === n ? t.equals(e) : t.distance(e) <= n } norm() { const t = this.copy(); return t.normalize(), t } reverse() { const t = this.reverseInternal(); return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t } copy() { const t = this.copyInternal(); return t.envelope = null == this._envelope ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t } getPrecisionModel() { return this._factory.getPrecisionModel() } getEnvelopeInternal() { return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new Dh(this._envelope) } setSRID(t) { this._SRID = t } setUserData(t) { this._userData = t } compare(t, e) { const n = t.iterator(), i = e.iterator(); for (; n.hasNext() && i.hasNext();) { const t = n.next(), e = i.next(), r = t.compareTo(e); if (0 !== r) return r } return n.hasNext() ? 1 : i.hasNext() ? -1 : 0 } hashCode() { return this.getEnvelopeInternal().hashCode() } isEquivalentClass(t) { return this.getClass() === t.getClass() } isGeometryCollectionOrDerived() { return this.getTypeCode() === Ah.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Ah.TYPECODE_MULTIPOINT || this.getTypeCode() === Ah.TYPECODE_MULTILINESTRING || this.getTypeCode() === Ah.TYPECODE_MULTIPOLYGON } get interfaces_() { return [vh, mh, Eh] } getClass() { return Ah } static hasNonEmptyElements(t) { for (let e = 0; e < t.length; e++)if (!t[e].isEmpty()) return !0; return !1 } static hasNullElements(t) { for (let e = 0; e < t.length; e++)if (null === t[e]) return !0; return !1 } } Ah.constructor_ = function (t) { t && (this._envelope = null, this._userData = null, this._factory = t, this._SRID = t.getSRID()) }, Ah.TYPECODE_POINT = 0, Ah.TYPECODE_MULTIPOINT = 1, Ah.TYPECODE_LINESTRING = 2, Ah.TYPECODE_LINEARRING = 3, Ah.TYPECODE_MULTILINESTRING = 4, Ah.TYPECODE_POLYGON = 5, Ah.TYPECODE_MULTIPOLYGON = 6, Ah.TYPECODE_GEOMETRYCOLLECTION = 7, Ah.TYPENAME_POINT = "Point", Ah.TYPENAME_MULTIPOINT = "MultiPoint", Ah.TYPENAME_LINESTRING = "LineString", Ah.TYPENAME_LINEARRING = "LinearRing", Ah.TYPENAME_MULTILINESTRING = "MultiLineString", Ah.TYPENAME_POLYGON = "Polygon", Ah.TYPENAME_MULTIPOLYGON = "MultiPolygon", Ah.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", Ah.geometryChangedFilter = { get interfaces_() { return [Mh] }, filter(t) { t.geometryChangedAction() } }; class Fh { filter(t) { } } class kh { } class Gh { static copyCoord(t, e, n, i) { const r = Math.min(t.getDimension(), n.getDimension()); for (let s = 0; s < r; s++)n.setOrdinate(i, s, t.getOrdinate(e, s)) } static isRing(t) { const e = t.size(); return 0 === e || !(e <= 3) && (t.getOrdinate(0, Lh.X) === t.getOrdinate(e - 1, Lh.X) && t.getOrdinate(0, Lh.Y) === t.getOrdinate(e - 1, Lh.Y)) } static scroll() { if (2 === arguments.length) { if (Nh(arguments[0], Lh) && Number.isInteger(arguments[1])) { const t = arguments[0], e = arguments[1]; Gh.scroll(t, e, Gh.isRing(t)) } else if (Nh(arguments[0], Lh) && arguments[1] instanceof Th) { const t = arguments[0], e = arguments[1], n = Gh.indexOf(e, t); if (n <= 0) return null; Gh.scroll(t, n) } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; if (e <= 0) return null; const i = t.copy(), r = n ? t.size() - 1 : t.size(); for (let n = 0; n < r; n++)for (let s = 0; s < t.getDimension(); s++)t.setOrdinate(n, s, i.getOrdinate((e + n) % r, s)); if (n) for (let e = 0; e < t.getDimension(); e++)t.setOrdinate(r, e, t.getOrdinate(0, e)) } } static isEqual(t, e) { const n = t.size(); if (n !== e.size()) return !1; const i = Math.min(t.getDimension(), e.getDimension()); for (let r = 0; r < n; r++)for (let n = 0; n < i; n++) { const i = t.getOrdinate(r, n), s = e.getOrdinate(r, n); if (t.getOrdinate(r, n) !== e.getOrdinate(r, n) && (!yh.isNaN(i) || !yh.isNaN(s))) return !1 } return !0 } static minCoordinateIndex() { if (1 === arguments.length) { const t = arguments[0]; return Gh.minCoordinateIndex(t, 0, t.size() - 1) } if (3 === arguments.length) { const t = arguments[0], e = arguments[2]; let n = -1, i = null; for (let r = arguments[1]; r <= e; r++) { const e = t.getCoordinate(r); (null === i || i.compareTo(e) > 0) && (i = e, n = r) } return n } } static extend(t, e, n) { const i = t.create(n, e.getDimension()), r = e.size(); if (Gh.copy(e, 0, i, 0, r), r > 0) for (let t = r; t < n; t++)Gh.copy(e, r - 1, i, t, 1); return i } static reverse(t) { const e = t.size() - 1, n = Math.trunc(e / 2); for (let i = 0; i <= n; i++)Gh.swap(t, i, e - i) } static swap(t, e, n) { if (e === n) return null; for (let i = 0; i < t.getDimension(); i++) { const r = t.getOrdinate(e, i); t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r) } } static copy(t, e, n, i, r) { for (let s = 0; s < r; s++)Gh.copyCoord(t, e + s, n, i + s) } static ensureValidRing(t, e) { const n = e.size(); if (0 === n) return e; if (n <= 3) return Gh.createClosedRing(t, e, 4); return e.getOrdinate(0, Lh.X) === e.getOrdinate(n - 1, Lh.X) && e.getOrdinate(0, Lh.Y) === e.getOrdinate(n - 1, Lh.Y) ? e : Gh.createClosedRing(t, e, n + 1) } static indexOf(t, e) { for (let n = 0; n < e.size(); n++)if (t.x === e.getOrdinate(n, Lh.X) && t.y === e.getOrdinate(n, Lh.Y)) return n; return -1 } static createClosedRing(t, e, n) { const i = t.create(n, e.getDimension()), r = e.size(); Gh.copy(e, 0, i, 0, r); for (let t = r; t < n; t++)Gh.copy(e, 0, i, t, 1); return i } static minCoordinate(t) { let e = null; for (let n = 0; n < t.size(); n++) { const i = t.getCoordinate(n); (null === e || e.compareTo(i) > 0) && (e = i) } return e } } class jh extends dh { constructor(t) { super(t), this.name = Object.keys({ UnsupportedOperationException: jh })[0] } } class Bh { static isWhitespace(t) { return t <= 32 && t >= 0 || 127 === t } static toUpperCase(t) { return t.toUpperCase() } } class Yh { static toDimensionSymbol(t) { switch (t) { case Yh.FALSE: return Yh.SYM_FALSE; case Yh.TRUE: return Yh.SYM_TRUE; case Yh.DONTCARE: return Yh.SYM_DONTCARE; case Yh.P: return Yh.SYM_P; case Yh.L: return Yh.SYM_L; case Yh.A: return Yh.SYM_A }throw new gh("Unknown dimension value: " + t) } static toDimensionValue(t) { switch (Bh.toUpperCase(t)) { case Yh.SYM_FALSE: return Yh.FALSE; case Yh.SYM_TRUE: return Yh.TRUE; case Yh.SYM_DONTCARE: return Yh.DONTCARE; case Yh.SYM_P: return Yh.P; case Yh.SYM_L: return Yh.L; case Yh.SYM_A: return Yh.A }throw new gh("Unknown dimension symbol: " + t) } } Yh.P = 0, Yh.L = 1, Yh.A = 2, Yh.FALSE = -1, Yh.TRUE = -2, Yh.DONTCARE = -3, Yh.SYM_FALSE = "F", Yh.SYM_TRUE = "T", Yh.SYM_DONTCARE = "*", Yh.SYM_P = "0", Yh.SYM_L = "1", Yh.SYM_A = "2"; class qh { filter(t) { } } class Xh { filter(t, e) { } isDone() { } isGeometryChanged() { } } class zh extends Ah { constructor() { super(), zh.constructor_.apply(this, arguments) } static constructor_() { if (this._points = null, 0 === arguments.length); else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; Ah.constructor_.call(this, e), this.init(t) } } computeEnvelopeInternal() { return this.isEmpty() ? new Dh : this._points.expandEnvelope(new Dh) } isRing() { return this.isClosed() && this.isSimple() } getCoordinates() { return this._points.toCoordinateArray() } copyInternal() { return new zh(this._points.copy(), this._factory) } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; if (!this.isEquivalentClass(t)) return !1; const n = t; if (this._points.size() !== n._points.size()) return !1; for (let t = 0; t < this._points.size(); t++)if (!this.equal(this._points.getCoordinate(t), n._points.getCoordinate(t), e)) return !1; return !0 } return super.equalsExact.apply(this, arguments) } normalize() { for (let t = 0; t < Math.trunc(this._points.size() / 2); t++) { const e = this._points.size() - 1 - t; if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) { if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) { const t = this._points.copy(); Gh.reverse(t), this._points = t } return null } } } getCoordinate() { return this.isEmpty() ? null : this._points.getCoordinate(0) } getBoundaryDimension() { return this.isClosed() ? Yh.FALSE : 0 } isClosed() { return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1)) } reverseInternal() { const t = this._points.copy(); return Gh.reverse(t), this.getFactory().createLineString(t) } getEndPoint() { return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1) } getTypeCode() { return Ah.TYPECODE_LINESTRING } getDimension() { return 1 } getLength() { return class { static ofLine(t) { const e = t.size(); if (e <= 1) return 0; let n = 0; const i = new Th; t.getCoordinate(0, i); let r = i.x, s = i.y; for (let o = 1; o < e; o++) { t.getCoordinate(o, i); const e = i.x, a = i.y, l = e - r, h = a - s; n += Math.sqrt(l * l + h * h), r = e, s = a } return n } }.ofLine(this._points) } getNumPoints() { return this._points.size() } compareToSameClass() { if (1 === arguments.length) { const t = arguments[0]; let e = 0, n = 0; for (; e < this._points.size() && n < t._points.size();) { const i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n)); if (0 !== i) return i; e++, n++ } return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0 } if (2 === arguments.length) { const t = arguments[0]; return arguments[1].compare(this._points, t._points) } } apply() { if (Nh(arguments[0], Fh)) { const t = arguments[0]; for (let e = 0; e < this._points.size(); e++)t.filter(this._points.getCoordinate(e)) } else if (Nh(arguments[0], Xh)) { const t = arguments[0]; if (0 === this._points.size()) return null; for (let e = 0; e < this._points.size() && (t.filter(this._points, e), !t.isDone()); e++); t.isGeometryChanged() && this.geometryChanged() } else if (Nh(arguments[0], qh)) { arguments[0].filter(this) } else if (Nh(arguments[0], Mh)) { arguments[0].filter(this) } } getBoundary() { throw new jh } isEquivalentClass(t) { return t instanceof zh } getCoordinateN(t) { return this._points.getCoordinate(t) } getGeometryType() { return Ah.TYPENAME_LINESTRING } getCoordinateSequence() { return this._points } isEmpty() { return 0 === this._points.size() } init(t) { if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new gh("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)"); this._points = t } isCoordinate(t) { for (let e = 0; e < this._points.size(); e++)if (this._points.getCoordinate(e).equals(t)) return !0; return !1 } getStartPoint() { return this.isEmpty() ? null : this.getPointN(0) } getPointN(t) { return this.getFactory().createPoint(this._points.getCoordinate(t)) } get interfaces_() { return [kh] } } class Uh { } class Vh extends Ah { constructor() { super(), Vh.constructor_.apply(this, arguments) } static constructor_() { this._coordinates = null; const t = arguments[0], e = arguments[1]; Ah.constructor_.call(this, e), this.init(t) } computeEnvelopeInternal() { if (this.isEmpty()) return new Dh; const t = new Dh; return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t } getCoordinates() { return this.isEmpty() ? [] : [this.getCoordinate()] } copyInternal() { return new Vh(this._coordinates.copy(), this._factory) } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e)) } return super.equalsExact.apply(this, arguments) } normalize() { } getCoordinate() { return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null } getBoundaryDimension() { return Yh.FALSE } reverseInternal() { return this.getFactory().createPoint(this._coordinates.copy()) } getTypeCode() { return Ah.TYPECODE_POINT } getDimension() { return 0 } getNumPoints() { return this.isEmpty() ? 0 : 1 } getX() { if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point"); return this.getCoordinate().x } compareToSameClass() { if (1 === arguments.length) { const t = arguments[0]; return this.getCoordinate().compareTo(t.getCoordinate()) } if (2 === arguments.length) { const t = arguments[0]; return arguments[1].compare(this._coordinates, t._coordinates) } } apply() { if (Nh(arguments[0], Fh)) { const t = arguments[0]; if (this.isEmpty()) return null; t.filter(this.getCoordinate()) } else if (Nh(arguments[0], Xh)) { const t = arguments[0]; if (this.isEmpty()) return null; t.filter(this._coordinates, 0), t.isGeometryChanged() && this.geometryChanged() } else if (Nh(arguments[0], qh)) { arguments[0].filter(this) } else if (Nh(arguments[0], Mh)) { arguments[0].filter(this) } } getBoundary() { return this.getFactory().createGeometryCollection() } getGeometryType() { return Ah.TYPENAME_POINT } getCoordinateSequence() { return this._coordinates } getY() { if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point"); return this.getCoordinate().y } isEmpty() { return 0 === this._coordinates.size() } init(t) { null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), wh.isTrue(t.size() <= 1), this._coordinates = t } isSimple() { return !0 } get interfaces_() { return [Uh] } } class Wh { static ofRing() { if (arguments[0] instanceof Array) { const t = arguments[0]; return Math.abs(Wh.ofRingSigned(t)) } if (Nh(arguments[0], Lh)) { const t = arguments[0]; return Math.abs(Wh.ofRingSigned(t)) } } static ofRingSigned() { if (arguments[0] instanceof Array) { const t = arguments[0]; if (t.length < 3) return 0; let e = 0; const n = t[0].x; for (let i = 1; i < t.length - 1; i++) { const r = t[i].x - n, s = t[i + 1].y; e += r * (t[i - 1].y - s) } return e / 2 } if (Nh(arguments[0], Lh)) { const t = arguments[0], e = t.size(); if (e < 3) return 0; const n = new Th, i = new Th, r = new Th; t.getCoordinate(0, i), t.getCoordinate(1, r); const s = i.x; r.x -= s; let o = 0; for (let a = 1; a < e - 1; a++)n.y = i.y, i.x = r.x, i.y = r.y, t.getCoordinate(a + 1, r), r.x -= s, o += i.x * (n.y - r.y); return o / 2 } } } class Hh { add() { } addAll() { } isEmpty() { } iterator() { } size() { } toArray() { } remove() { } } class Kh extends dh { constructor(t) { super(t), this.name = Object.keys({ IndexOutOfBoundsException: Kh })[0] } } class Zh extends Hh { get() { } set() { } isEmpty() { } } class Jh extends dh { constructor(t) { super(t), this.name = Object.keys({ NoSuchElementException: Jh })[0] } } class Qh extends Zh { constructor(t) { super(), this.array = [], t instanceof Hh && this.addAll(t) } get interfaces_() { return [Zh, Hh] } ensureCapacity() { } add(t) { return 1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0 } clear() { this.array = [] } addAll(t) { for (const e of t) this.array.push(e) } set(t, e) { const n = this.array[t]; return this.array[t] = e, n } iterator() { return new $h(this) } get(t) { if (t < 0 || t >= this.size()) throw new Kh; return this.array[t] } isEmpty() { return 0 === this.array.length } sort(t) { t ? this.array.sort((e, n) => t.compare(e, n)) : this.array.sort() } size() { return this.array.length } toArray() { return this.array.slice() } remove(t) { for (let e = 0, n = this.array.length; e < n; e++)if (this.array[e] === t) return !!this.array.splice(e, 1); return !1 } [Symbol.iterator]() { return this.array.values() } } class $h { constructor(t) { this.arrayList = t, this.position = 0 } next() { if (this.position === this.arrayList.size()) throw new Jh; return this.arrayList.get(this.position++) } hasNext() { return this.position < this.arrayList.size() } set(t) { return this.arrayList.set(this.position - 1, t) } remove() { this.arrayList.remove(this.arrayList.get(this.position)) } } class tc { static sort() { const t = arguments[0]; if (1 === arguments.length) t.sort((t, e) => t.compareTo(e)); else if (2 === arguments.length) t.sort((t, e) => arguments[1].compare(t, e)); else if (3 === arguments.length) { const e = t.slice(arguments[1], arguments[2]); e.sort(); const n = t.slice(0, arguments[1]).concat(e, t.slice(arguments[2], t.length)); t.splice(0, t.length); for (const e of n) t.push(e) } else if (4 === arguments.length) { const e = t.slice(arguments[1], arguments[2]); e.sort((t, e) => arguments[3].compare(t, e)); const n = t.slice(0, arguments[1]).concat(e, t.slice(arguments[2], t.length)); t.splice(0, t.length); for (const e of n) t.push(e) } } static asList(t) { const e = new Qh; for (const n of t) e.add(n); return e } static copyOf(t, e) { return t.slice(0, e) } } class ec { constructor(t) { this.str = t } append(t) { this.str += t } setCharAt(t, e) { this.str = this.str.substr(0, t) + e + this.str.substr(t + 1) } toString() { return this.str } } class nc { constructor(t) { this.value = t } intValue() { return this.value } compareTo(t) { return this.value < t ? -1 : this.value > t ? 1 : 0 } static compare(t, e) { return t < e ? -1 : t > e ? 1 : 0 } static isNan(t) { return Number.isNaN(t) } static valueOf(t) { return new nc(t) } } class ic { constructor() { ic.constructor_.apply(this, arguments) } static constructor_() { if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0); else if (1 === arguments.length) { if ("number" == typeof arguments[0]) { const t = arguments[0]; this.init(t) } else if (arguments[0] instanceof ic) { const t = arguments[0]; this.init(t) } else if ("string" == typeof arguments[0]) { const t = arguments[0]; ic.constructor_.call(this, ic.parse(t)) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.init(t, e) } } static determinant() { if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; return ic.determinant(ic.valueOf(t), ic.valueOf(e), ic.valueOf(n), ic.valueOf(i)) } if (arguments[3] instanceof ic && arguments[2] instanceof ic && arguments[0] instanceof ic && arguments[1] instanceof ic) { const t = arguments[1], e = arguments[2], n = arguments[3]; return arguments[0].multiply(n).selfSubtract(t.multiply(e)) } } static sqr(t) { return ic.valueOf(t).selfMultiply(t) } static valueOf() { if ("string" == typeof arguments[0]) { const t = arguments[0]; return ic.parse(t) } if ("number" == typeof arguments[0]) { return new ic(arguments[0]) } } static sqrt(t) { return ic.valueOf(t).sqrt() } static parse(t) { let e = 0; const n = t.length; for (; Bh.isWhitespace(t.charAt(e));)e++; let i = !1; if (e < n) { const n = t.charAt(e); "-" !== n && "+" !== n || (e++, "-" === n && (i = !0)) } const r = new ic; let s = 0, o = 0, a = 0, l = !1; for (; !(e >= n);) { const n = t.charAt(e); if (e++, Bh.isDigit(n)) { const t = n - "0"; r.selfMultiply(ic.TEN), r.selfAdd(t), s++ } else { if ("." !== n) { if ("e" === n || "E" === n) { const n = t.substring(e); try { a = nc.parseInt(n) } catch (e) { throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + n + " in string " + t) : e } break } throw new NumberFormatException("Unexpected character '" + n + "' at position " + e + " in string " + t) } o = s, l = !0 } } let h = r; l || (o = s); const c = s - o - a; if (0 === c) h = r; else if (c > 0) { const t = ic.TEN.pow(c); h = r.divide(t) } else if (c < 0) { const t = ic.TEN.pow(-c); h = r.multiply(t) } return i ? h.negate() : h } static createNaN() { return new ic(yh.NaN, yh.NaN) } static copy(t) { return new ic(t) } static magnitude(t) { const e = Math.abs(t), n = Math.log(e) / Math.log(10); let i = Math.trunc(Math.floor(n)); return 10 * Math.pow(10, i) <= e && (i += 1), i } static stringOfChar(t, e) { const n = new ec; for (let i = 0; i < e; i++)n.append(t); return n.toString() } le(t) { return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo } extractSignificantDigits(t, e) { let n = this.abs(), i = ic.magnitude(n._hi); const r = ic.TEN.pow(i); n = n.divide(r), n.gt(ic.TEN) ? (n = n.divide(ic.TEN), i += 1) : n.lt(ic.ONE) && (n = n.multiply(ic.TEN), i -= 1); const s = i + 1, o = new ec, a = ic.MAX_PRINT_DIGITS - 1; for (let e = 0; e <= a; e++) { t && e === s && o.append("."); const i = Math.trunc(n._hi); if (i < 0) break; let r = !1, l = 0; i > 9 ? (r = !0, l = "9") : l = "0" + i, o.append(l), n = n.subtract(ic.valueOf(i)).multiply(ic.TEN), r && n.selfAdd(ic.TEN); let h = !0; const c = ic.magnitude(n._hi); if (c < 0 && Math.abs(c) >= a - e && (h = !1), !h) break } return e[0] = i, o.toString() } sqr() { return this.multiply(this) } doubleValue() { return this._hi + this._lo } subtract() { if (arguments[0] instanceof ic) { const t = arguments[0]; return this.add(t.negate()) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return this.add(-t) } } equals() { if (1 === arguments.length && arguments[0] instanceof ic) { const t = arguments[0]; return this._hi === t._hi && this._lo === t._lo } } isZero() { return 0 === this._hi && 0 === this._lo } selfSubtract() { if (arguments[0] instanceof ic) { const t = arguments[0]; return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return this.isNaN() ? this : this.selfAdd(-t, 0) } } getSpecialNumberString() { return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null } min(t) { return this.le(t) ? this : t } selfDivide() { if (1 === arguments.length) { if (arguments[0] instanceof ic) { const t = arguments[0]; return this.selfDivide(t._hi, t._lo) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return this.selfDivide(t, 0) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; let n = null, i = null, r = null, s = null, o = null, a = null, l = null, h = null; return o = this._hi / t, a = ic.SPLIT * o, n = a - o, h = ic.SPLIT * t, n = a - n, i = o - n, r = h - t, l = o * t, r = h - r, s = t - r, h = n * r - l + n * s + i * r + i * s, a = (this._hi - l - h + this._lo - o * e) / t, h = o + a, this._hi = h, this._lo = o - h + a, this } } dump() { return "DD<" + this._hi + ", " + this._lo + ">" } divide() { if (arguments[0] instanceof ic) { const t = arguments[0]; let e = null, n = null, i = null, r = null, s = null, o = null, a = null, l = null; s = this._hi / t._hi, o = ic.SPLIT * s, e = o - s, l = ic.SPLIT * t._hi, e = o - e, n = s - e, i = l - t._hi, a = s * t._hi, i = l - i, r = t._hi - i, l = e * i - a + e * r + n * i + n * r, o = (this._hi - a - l + this._lo - s * t._lo) / t._hi, l = s + o; return new ic(l, s - l + o) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return yh.isNaN(t) ? ic.createNaN() : ic.copy(this).selfDivide(t, 0) } } ge(t) { return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo } pow(t) { if (0 === t) return ic.valueOf(1); let e = new ic(this), n = ic.valueOf(1), i = Math.abs(t); if (i > 1) for (; i > 0;)i % 2 == 1 && n.selfMultiply(e), i /= 2, i > 0 && (e = e.sqr()); else n = e; return t < 0 ? n.reciprocal() : n } ceil() { if (this.isNaN()) return ic.NaN; const t = Math.ceil(this._hi); let e = 0; return t === this._hi && (e = Math.ceil(this._lo)), new ic(t, e) } compareTo(t) { const e = t; return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0 } rint() { if (this.isNaN()) return this; return this.add(.5).floor() } setValue() { if (arguments[0] instanceof ic) { const t = arguments[0]; return this.init(t), this } if ("number" == typeof arguments[0]) { const t = arguments[0]; return this.init(t), this } } max(t) { return this.ge(t) ? this : t } sqrt() { if (this.isZero()) return ic.valueOf(0); if (this.isNegative()) return ic.NaN; const t = 1 / Math.sqrt(this._hi), e = this._hi * t, n = ic.valueOf(e), i = this.subtract(n.sqr())._hi * (.5 * t); return n.add(i) } selfAdd() { if (1 === arguments.length) { if (arguments[0] instanceof ic) { const t = arguments[0]; return this.selfAdd(t._hi, t._lo) } if ("number" == typeof arguments[0]) { const t = arguments[0]; let e = null, n = null, i = null, r = null, s = null, o = null; return i = this._hi + t, s = i - this._hi, r = i - s, r = t - s + (this._hi - r), o = r + this._lo, e = i + o, n = o + (i - e), this._hi = e + n, this._lo = n + (e - this._hi), this } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; let n = null, i = null, r = null, s = null, o = null, a = null, l = null, h = null; o = this._hi + t, r = this._lo + e, l = o - this._hi, h = r - this._lo, a = o - l, s = r - h, a = t - l + (this._hi - a), s = e - h + (this._lo - s), l = a + r, n = o + l, i = l + (o - n), l = s + i; const c = n + l, u = l + (n - c); return this._hi = c, this._lo = u, this } } selfMultiply() { if (1 === arguments.length) { if (arguments[0] instanceof ic) { const t = arguments[0]; return this.selfMultiply(t._hi, t._lo) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return this.selfMultiply(t, 0) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; let n = null, i = null, r = null, s = null, o = null, a = null; o = ic.SPLIT * this._hi, n = o - this._hi, a = ic.SPLIT * t, n = o - n, i = this._hi - n, r = a - t, o = this._hi * t, r = a - r, s = t - r, a = n * r - o + n * s + i * r + i * s + (this._hi * e + this._lo * t); const l = o + a; n = o - l; const h = a + n; return this._hi = l, this._lo = h, this } } selfSqr() { return this.selfMultiply(this) } floor() { if (this.isNaN()) return ic.NaN; const t = Math.floor(this._hi); let e = 0; return t === this._hi && (e = Math.floor(this._lo)), new ic(t, e) } negate() { return this.isNaN() ? this : new ic(-this._hi, -this._lo) } clone() { try { return null } catch (t) { if (t instanceof CloneNotSupportedException) return null; throw t } } multiply() { if (arguments[0] instanceof ic) { const t = arguments[0]; return t.isNaN() ? ic.createNaN() : ic.copy(this).selfMultiply(t) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return yh.isNaN(t) ? ic.createNaN() : ic.copy(this).selfMultiply(t, 0) } } isNaN() { return yh.isNaN(this._hi) } intValue() { return Math.trunc(this._hi) } toString() { const t = ic.magnitude(this._hi); return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation() } toStandardNotation() { const t = this.getSpecialNumberString(); if (null !== t) return t; const e = new Array(1).fill(null), n = this.extractSignificantDigits(!0, e), i = e[0] + 1; let r = n; if ("." === n.charAt(0)) r = "0" + n; else if (i < 0) r = "0." + ic.stringOfChar("0", -i) + n; else if (-1 === n.indexOf(".")) { const t = i - n.length; r = n + ic.stringOfChar("0", t) + ".0" } return this.isNegative() ? "-" + r : r } reciprocal() { let t = null, e = null, n = null, i = null, r = null, s = null, o = null, a = null; r = 1 / this._hi, s = ic.SPLIT * r, t = s - r, a = ic.SPLIT * this._hi, t = s - t, e = r - t, n = a - this._hi, o = r * this._hi, n = a - n, i = this._hi - n, a = t * n - o + t * i + e * n + e * i, s = (1 - o - a - r * this._lo) / this._hi; const l = r + s; return new ic(l, r - l + s) } toSciNotation() { if (this.isZero()) return ic.SCI_NOT_ZERO; const t = this.getSpecialNumberString(); if (null !== t) return t; const e = new Array(1).fill(null), n = this.extractSignificantDigits(!1, e), i = ic.SCI_NOT_EXPONENT_CHAR + e[0]; if ("0" === n.charAt(0)) throw new IllegalStateException("Found leading zero: " + n); let r = ""; n.length > 1 && (r = n.substring(1)); const s = n.charAt(0) + "." + r; return this.isNegative() ? "-" + s + i : s + i } abs() { return this.isNaN() ? ic.NaN : this.isNegative() ? this.negate() : new ic(this) } isPositive() { return this._hi > 0 || 0 === this._hi && this._lo > 0 } lt(t) { return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo } add() { if (arguments[0] instanceof ic) { const t = arguments[0]; return ic.copy(this).selfAdd(t) } if ("number" == typeof arguments[0]) { const t = arguments[0]; return ic.copy(this).selfAdd(t) } } init() { if (1 === arguments.length) { if ("number" == typeof arguments[0]) { const t = arguments[0]; this._hi = t, this._lo = 0 } else if (arguments[0] instanceof ic) { const t = arguments[0]; this._hi = t._hi, this._lo = t._lo } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this._hi = t, this._lo = e } } gt(t) { return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo } isNegative() { return this._hi < 0 || 0 === this._hi && this._lo < 0 } trunc() { return this.isNaN() ? ic.NaN : this.isPositive() ? this.floor() : this.ceil() } signum() { return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0 } get interfaces_() { return [Eh, mh, vh] } } ic.PI = new ic(3.141592653589793, 12246467991473532e-32), ic.TWO_PI = new ic(6.283185307179586, 24492935982947064e-32), ic.PI_2 = new ic(1.5707963267948966, 6123233995736766e-32), ic.E = new ic(2.718281828459045, 14456468917292502e-32), ic.NaN = new ic(yh.NaN, yh.NaN), ic.EPS = 123259516440783e-46, ic.SPLIT = 134217729, ic.MAX_PRINT_DIGITS = 32, ic.TEN = ic.valueOf(10), ic.ONE = ic.valueOf(1), ic.SCI_NOT_EXPONENT_CHAR = "E", ic.SCI_NOT_ZERO = "0.0E0"; class rc { static orientationIndex(t, e, n) { const i = rc.orientationIndexFilter(t, e, n); if (i <= 1) return i; const r = ic.valueOf(e.x).selfAdd(-t.x), s = ic.valueOf(e.y).selfAdd(-t.y), o = ic.valueOf(n.x).selfAdd(-e.x), a = ic.valueOf(n.y).selfAdd(-e.y); return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum() } static signOfDet2x2() { if (arguments[3] instanceof ic && arguments[2] instanceof ic && arguments[0] instanceof ic && arguments[1] instanceof ic) { const t = arguments[1], e = arguments[2], n = arguments[3]; return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum() } if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3], r = ic.valueOf(t), s = ic.valueOf(e), o = ic.valueOf(n), a = ic.valueOf(i); return r.multiply(a).selfSubtract(s.multiply(o)).signum() } } static intersection(t, e, n, i) { const r = new ic(t.y).selfSubtract(e.y), s = new ic(e.x).selfSubtract(t.x), o = new ic(t.x).selfMultiply(e.y).selfSubtract(new ic(e.x).selfMultiply(t.y)), a = new ic(n.y).selfSubtract(i.y), l = new ic(i.x).selfSubtract(n.x), h = new ic(n.x).selfMultiply(i.y).selfSubtract(new ic(i.x).selfMultiply(n.y)), c = s.multiply(h).selfSubtract(l.multiply(o)), u = a.multiply(o).selfSubtract(r.multiply(h)), f = r.multiply(l).selfSubtract(a.multiply(s)), p = c.selfDivide(f).doubleValue(), d = u.selfDivide(f).doubleValue(); return yh.isNaN(p) || yh.isInfinite(p) || yh.isNaN(d) || yh.isInfinite(d) ? null : new Th(p, d) } static orientationIndexFilter(t, e, n) { let i = null; const r = (t.x - n.x) * (e.y - n.y), s = (t.y - n.y) * (e.x - n.x), o = r - s; if (r > 0) { if (s <= 0) return rc.signum(o); i = r + s } else { if (!(r < 0)) return rc.signum(o); if (s >= 0) return rc.signum(o); i = -r - s } const a = rc.DP_SAFE_EPSILON * i; return o >= a || -o >= a ? rc.signum(o) : 2 } static signum(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } } rc.DP_SAFE_EPSILON = 1e-15; class sc { static index(t, e, n) { return rc.orientationIndex(t, e, n) } static isCCW() { if (arguments[0] instanceof Array) { const t = arguments[0], e = t.length - 1; if (e < 3) throw new gh("Ring has fewer than 4 points, so orientation cannot be determined"); let n = t[0], i = 0; for (let r = 1; r <= e; r++) { const e = t[r]; e.y > n.y && (n = e, i = r) } let r = i; do { r -= 1, r < 0 && (r = e) } while (t[r].equals2D(n) && r !== i); let s = i; do { s = (s + 1) % e } while (t[s].equals2D(n) && s !== i); const o = t[r], a = t[s]; if (o.equals2D(n) || a.equals2D(n) || o.equals2D(a)) return !1; const l = sc.index(o, n, a); let h = null; return h = 0 === l ? o.x > a.x : l > 0, h } if (Nh(arguments[0], Lh)) { const t = arguments[0], e = t.size() - 1; if (e < 3) throw new gh("Ring has fewer than 4 points, so orientation cannot be determined"); let n = t.getCoordinate(0), i = 0; for (let r = 1; r <= e; r++) { const e = t.getCoordinate(r); e.y > n.y && (n = e, i = r) } let r = null, s = i; do { s -= 1, s < 0 && (s = e), r = t.getCoordinate(s) } while (r.equals2D(n) && s !== i); let o = null, a = i; do { a = (a + 1) % e, o = t.getCoordinate(a) } while (o.equals2D(n) && a !== i); if (r.equals2D(n) || o.equals2D(n) || r.equals2D(o)) return !1; const l = sc.index(r, n, o); let h = null; return h = 0 === l ? r.x > o.x : l > 0, h } } } sc.CLOCKWISE = -1, sc.RIGHT = sc.CLOCKWISE, sc.COUNTERCLOCKWISE = 1, sc.LEFT = sc.COUNTERCLOCKWISE, sc.COLLINEAR = 0, sc.STRAIGHT = sc.COLLINEAR; class oc { } class ac extends Ah { constructor() { super(), ac.constructor_.apply(this, arguments) } static constructor_() { this._shell = null, this._holes = null; let t = arguments[0], e = arguments[1], n = arguments[2]; if (Ah.constructor_.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), Ah.hasNullElements(e)) throw new gh("holes must not contain null elements"); if (t.isEmpty() && Ah.hasNonEmptyElements(e)) throw new gh("shell is empty but holes are not"); this._shell = t, this._holes = e } computeEnvelopeInternal() { return this._shell.getEnvelopeInternal() } getCoordinates() { if (this.isEmpty()) return []; const t = new Array(this.getNumPoints()).fill(null); let e = -1; const n = this._shell.getCoordinates(); for (let i = 0; i < n.length; i++)e++, t[e] = n[i]; for (let n = 0; n < this._holes.length; n++) { const i = this._holes[n].getCoordinates(); for (let n = 0; n < i.length; n++)e++, t[e] = i[n] } return t } getArea() { let t = 0; t += Wh.ofRing(this._shell.getCoordinateSequence()); for (let e = 0; e < this._holes.length; e++)t -= Wh.ofRing(this._holes[e].getCoordinateSequence()); return t } copyInternal() { const t = this._shell.copy(), e = new Array(this._holes.length).fill(null); for (let t = 0; t < this._holes.length; t++)e[t] = this._holes[t].copy(); return new ac(t, e, this._factory) } isRectangle() { if (0 !== this.getNumInteriorRing()) return !1; if (null === this._shell) return !1; if (5 !== this._shell.getNumPoints()) return !1; const t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(); for (let n = 0; n < 5; n++) { const i = t.getX(n); if (i !== e.getMinX() && i !== e.getMaxX()) return !1; const r = t.getY(n); if (r !== e.getMinY() && r !== e.getMaxY()) return !1 } let n = t.getX(0), i = t.getY(0); for (let e = 1; e <= 4; e++) { const r = t.getX(e), s = t.getY(e); if (r !== n === (s !== i)) return !1; n = r, i = s } return !0 } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; if (!this.isEquivalentClass(t)) return !1; const n = t, i = this._shell, r = n._shell; if (!i.equalsExact(r, e)) return !1; if (this._holes.length !== n._holes.length) return !1; for (let t = 0; t < this._holes.length; t++)if (!this._holes[t].equalsExact(n._holes[t], e)) return !1; return !0 } return super.equalsExact.apply(this, arguments) } normalize() { if (0 === arguments.length) { this._shell = this.normalized(this._shell, !0); for (let t = 0; t < this._holes.length; t++)this._holes[t] = this.normalized(this._holes[t], !1); tc.sort(this._holes) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; if (t.isEmpty()) return null; const n = t.getCoordinateSequence(), i = Gh.minCoordinateIndex(n, 0, n.size() - 2); Gh.scroll(n, i, !0), sc.isCCW(n) === e && Gh.reverse(n) } } getCoordinate() { return this._shell.getCoordinate() } getNumInteriorRing() { return this._holes.length } getBoundaryDimension() { return 1 } reverseInternal() { const t = this.getExteriorRing().reverse(), e = new Array(this.getNumInteriorRing()).fill(null); for (let t = 0; t < e.length; t++)e[t] = this.getInteriorRingN(t).reverse(); return this.getFactory().createPolygon(t, e) } getTypeCode() { return Ah.TYPECODE_POLYGON } getDimension() { return 2 } getLength() { let t = 0; t += this._shell.getLength(); for (let e = 0; e < this._holes.length; e++)t += this._holes[e].getLength(); return t } getNumPoints() { let t = this._shell.getNumPoints(); for (let e = 0; e < this._holes.length; e++)t += this._holes[e].getNumPoints(); return t } convexHull() { return this.getExteriorRing().convexHull() } normalized(t, e) { const n = t.copy(); return this.normalize(n, e), n } compareToSameClass() { if (1 === arguments.length) { const t = arguments[0], e = this._shell, n = t._shell; return e.compareToSameClass(n) } if (2 === arguments.length) { const t = arguments[1], e = arguments[0], n = this._shell, i = e._shell, r = n.compareToSameClass(i, t); if (0 !== r) return r; const s = this.getNumInteriorRing(), o = e.getNumInteriorRing(); let a = 0; for (; a < s && a < o;) { const n = this.getInteriorRingN(a), i = e.getInteriorRingN(a), r = n.compareToSameClass(i, t); if (0 !== r) return r; a++ } return a < s ? 1 : a < o ? -1 : 0 } } apply() { if (Nh(arguments[0], Fh)) { const t = arguments[0]; this._shell.apply(t); for (let e = 0; e < this._holes.length; e++)this._holes[e].apply(t) } else if (Nh(arguments[0], Xh)) { const t = arguments[0]; if (this._shell.apply(t), !t.isDone()) for (let e = 0; e < this._holes.length && (this._holes[e].apply(t), !t.isDone()); e++); t.isGeometryChanged() && this.geometryChanged() } else if (Nh(arguments[0], qh)) { arguments[0].filter(this) } else if (Nh(arguments[0], Mh)) { const t = arguments[0]; t.filter(this), this._shell.apply(t); for (let e = 0; e < this._holes.length; e++)this._holes[e].apply(t) } } getBoundary() { if (this.isEmpty()) return this.getFactory().createMultiLineString(); const t = new Array(this._holes.length + 1).fill(null); t[0] = this._shell; for (let e = 0; e < this._holes.length; e++)t[e + 1] = this._holes[e]; return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t) } getGeometryType() { return Ah.TYPENAME_POLYGON } getExteriorRing() { return this._shell } isEmpty() { return this._shell.isEmpty() } getInteriorRingN(t) { return this._holes[t] } get interfaces_() { return [oc] } } class lc extends Hh { contains() { } } class hc extends lc { } class cc extends hc { constructor(t) { super(), this.array = [], t instanceof Hh && this.addAll(t) } contains(t) { for (const e of this.array) if (0 === e.compareTo(t)) return !0; return !1 } add(t) { if (this.contains(t)) return !1; for (let e = 0, n = this.array.length; e < n; e++) { if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t) } return this.array.push(t), !0 } addAll(t) { for (const e of t) this.add(e); return !0 } remove() { throw new jh } size() { return this.array.length } isEmpty() { return 0 === this.array.length } toArray() { return this.array.slice() } iterator() { return new uc(this.array) } } class uc { constructor(t) { this.array = t, this.position = 0 } next() { if (this.position === this.array.length) throw new Jh; return this.array[this.position++] } hasNext() { return this.position < this.array.length } remove() { throw new jh } } class fc extends Ah { constructor() { super(), fc.constructor_.apply(this, arguments) } static constructor_() { if (this._geometries = null, 0 === arguments.length); else if (2 === arguments.length) { let t = arguments[0], e = arguments[1]; if (Ah.constructor_.call(this, e), null === t && (t = []), Ah.hasNullElements(t)) throw new gh("geometries must not contain null elements"); this._geometries = t } } computeEnvelopeInternal() { const t = new Dh; for (let e = 0; e < this._geometries.length; e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal()); return t } getGeometryN(t) { return this._geometries[t] } getCoordinates() { const t = new Array(this.getNumPoints()).fill(null); let e = -1; for (let n = 0; n < this._geometries.length; n++) { const i = this._geometries[n].getCoordinates(); for (let n = 0; n < i.length; n++)e++, t[e] = i[n] } return t } getArea() { let t = 0; for (let e = 0; e < this._geometries.length; e++)t += this._geometries[e].getArea(); return t } copyInternal() { const t = new Array(this._geometries.length).fill(null); for (let e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new fc(t, this._factory) } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; if (!this.isEquivalentClass(t)) return !1; const n = t; if (this._geometries.length !== n._geometries.length) return !1; for (let t = 0; t < this._geometries.length; t++)if (!this._geometries[t].equalsExact(n._geometries[t], e)) return !1; return !0 } return super.equalsExact.apply(this, arguments) } normalize() { for (let t = 0; t < this._geometries.length; t++)this._geometries[t].normalize(); tc.sort(this._geometries) } getCoordinate() { return this.isEmpty() ? null : this._geometries[0].getCoordinate() } getBoundaryDimension() { let t = Yh.FALSE; for (let e = 0; e < this._geometries.length; e++)t = Math.max(t, this._geometries[e].getBoundaryDimension()); return t } reverseInternal() { const t = this._geometries.length, e = new Qh(t); for (let n = 0; n < t; n++)e.add(this._geometries[n].reverse()); return this.getFactory().buildGeometry(e) } getTypeCode() { return Ah.TYPECODE_GEOMETRYCOLLECTION } getDimension() { let t = Yh.FALSE; for (let e = 0; e < this._geometries.length; e++)t = Math.max(t, this._geometries[e].getDimension()); return t } getLength() { let t = 0; for (let e = 0; e < this._geometries.length; e++)t += this._geometries[e].getLength(); return t } getNumPoints() { let t = 0; for (let e = 0; e < this._geometries.length; e++)t += this._geometries[e].getNumPoints(); return t } getNumGeometries() { return this._geometries.length } compareToSameClass() { if (1 === arguments.length) { const t = arguments[0], e = new cc(tc.asList(this._geometries)), n = new cc(tc.asList(t._geometries)); return this.compare(e, n) } if (2 === arguments.length) { const t = arguments[1], e = arguments[0], n = this.getNumGeometries(), i = e.getNumGeometries(); let r = 0; for (; r < n && r < i;) { const n = this.getGeometryN(r), i = e.getGeometryN(r), s = n.compareToSameClass(i, t); if (0 !== s) return s; r++ } return r < n ? 1 : r < i ? -1 : 0 } } apply() { if (Nh(arguments[0], Fh)) { const t = arguments[0]; for (let e = 0; e < this._geometries.length; e++)this._geometries[e].apply(t) } else if (Nh(arguments[0], Xh)) { const t = arguments[0]; if (0 === this._geometries.length) return null; for (let e = 0; e < this._geometries.length && (this._geometries[e].apply(t), !t.isDone()); e++); t.isGeometryChanged() && this.geometryChanged() } else if (Nh(arguments[0], qh)) { const t = arguments[0]; t.filter(this); for (let e = 0; e < this._geometries.length; e++)this._geometries[e].apply(t) } else if (Nh(arguments[0], Mh)) { const t = arguments[0]; t.filter(this); for (let e = 0; e < this._geometries.length; e++)this._geometries[e].apply(t) } } getBoundary() { return Ah.checkNotGeometryCollection(this), wh.shouldNeverReachHere(), null } getGeometryType() { return Ah.TYPENAME_GEOMETRYCOLLECTION } isEmpty() { for (let t = 0; t < this._geometries.length; t++)if (!this._geometries[t].isEmpty()) return !1; return !0 } } class pc extends fc { constructor() { super(), pc.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0], e = arguments[1]; fc.constructor_.call(this, t, e) } copyInternal() { const t = new Array(this._geometries.length).fill(null); for (let e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new pc(t, this._factory) } isValid() { return !0 } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && super.equalsExact.call(this, t, e) } return super.equalsExact.apply(this, arguments) } getCoordinate() { if (1 === arguments.length && Number.isInteger(arguments[0])) { const t = arguments[0]; return this._geometries[t].getCoordinate() } return super.getCoordinate.apply(this, arguments) } getBoundaryDimension() { return Yh.FALSE } getTypeCode() { return Ah.TYPECODE_MULTIPOINT } getDimension() { return 0 } getBoundary() { return this.getFactory().createGeometryCollection() } getGeometryType() { return Ah.TYPENAME_MULTIPOINT } get interfaces_() { return [Uh] } } class dc extends zh { constructor() { super(), dc.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0], e = arguments[1]; zh.constructor_.call(this, t, e), this.validateConstruction() } copyInternal() { return new dc(this._points.copy(), this._factory) } getBoundaryDimension() { return Yh.FALSE } isClosed() { return !!this.isEmpty() || super.isClosed.call(this) } reverseInternal() { const t = this._points.copy(); return Gh.reverse(t), this.getFactory().createLinearRing(t) } getTypeCode() { return Ah.TYPECODE_LINEARRING } validateConstruction() { if (!this.isEmpty() && !super.isClosed.call(this)) throw new gh("Points of LinearRing do not form a closed linestring"); if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < dc.MINIMUM_VALID_SIZE) throw new gh("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)") } getGeometryType() { return Ah.TYPENAME_LINEARRING } } dc.MINIMUM_VALID_SIZE = 4; class gc extends Th { constructor() { super(), gc.constructor_.apply(this, arguments) } static constructor_() { if (0 === arguments.length) Th.constructor_.call(this); else if (1 === arguments.length) { if (arguments[0] instanceof gc) { const t = arguments[0]; Th.constructor_.call(this, t.x, t.y) } else if (arguments[0] instanceof Th) { const t = arguments[0]; Th.constructor_.call(this, t.x, t.y) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; Th.constructor_.call(this, t, e, Th.NULL_ORDINATE) } } setOrdinate(t, e) { switch (t) { case gc.X: this.x = e; break; case gc.Y: this.y = e; break; default: throw new gh("Invalid ordinate index: " + t) } } getZ() { return Th.NULL_ORDINATE } getOrdinate(t) { switch (t) { case gc.X: return this.x; case gc.Y: return this.y }throw new gh("Invalid ordinate index: " + t) } setZ(t) { throw new gh("CoordinateXY dimension 2 does not support z-ordinate") } copy() { return new gc(this) } toString() { return "(" + this.x + ", " + this.y + ")" } setCoordinate(t) { this.x = t.x, this.y = t.y, this.z = t.getZ() } } gc.X = 0, gc.Y = 1, gc.Z = -1, gc.M = -1; class _c extends Th { constructor() { super(), _c.constructor_.apply(this, arguments) } static constructor_() { if (this._m = null, 0 === arguments.length) Th.constructor_.call(this), this._m = 0; else if (1 === arguments.length) { if (arguments[0] instanceof _c) { const t = arguments[0]; Th.constructor_.call(this, t.x, t.y), this._m = t._m } else if (arguments[0] instanceof Th) { const t = arguments[0]; Th.constructor_.call(this, t.x, t.y), this._m = this.getM() } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; Th.constructor_.call(this, t, e, Th.NULL_ORDINATE), this._m = n } } getM() { return this._m } setOrdinate(t, e) { switch (t) { case _c.X: this.x = e; break; case _c.Y: this.y = e; break; case _c.M: this._m = e; break; default: throw new gh("Invalid ordinate index: " + t) } } setM(t) { this._m = t } getZ() { return Th.NULL_ORDINATE } getOrdinate(t) { switch (t) { case _c.X: return this.x; case _c.Y: return this.y; case _c.M: return this._m }throw new gh("Invalid ordinate index: " + t) } setZ(t) { throw new gh("CoordinateXY dimension 2 does not support z-ordinate") } copy() { return new _c(this) } toString() { return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")" } setCoordinate(t) { this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM() } } _c.X = 0, _c.Y = 1, _c.Z = -1, _c.M = 2; class yc extends Th { constructor() { super(), yc.constructor_.apply(this, arguments) } static constructor_() { if (this._m = null, 0 === arguments.length) Th.constructor_.call(this), this._m = 0; else if (1 === arguments.length) { if (arguments[0] instanceof yc) { const t = arguments[0]; Th.constructor_.call(this, t), this._m = t._m } else if (arguments[0] instanceof Th) { const t = arguments[0]; Th.constructor_.call(this, t), this._m = this.getM() } } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; Th.constructor_.call(this, t, e, n), this._m = i } } getM() { return this._m } setOrdinate(t, e) { switch (t) { case Th.X: this.x = e; break; case Th.Y: this.y = e; break; case Th.Z: this.z = e; break; case Th.M: this._m = e; break; default: throw new gh("Invalid ordinate index: " + t) } } setM(t) { this._m = t } getOrdinate(t) { switch (t) { case Th.X: return this.x; case Th.Y: return this.y; case Th.Z: return this.getZ(); case Th.M: return this.getM() }throw new gh("Invalid ordinate index: " + t) } copy() { return new yc(this) } toString() { return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")" } setCoordinate(t) { this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM() } } class mc { static measures(t) { return t instanceof gc ? 0 : t instanceof _c || t instanceof yc ? 1 : 0 } static dimension(t) { return t instanceof gc ? 2 : t instanceof _c ? 3 : t instanceof yc ? 4 : 3 } static create() { if (1 === arguments.length) { const t = arguments[0]; return mc.create(t, 0) } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return 2 === t ? new gc : 3 === t && 0 === e ? new Th : 3 === t && 1 === e ? new _c : 4 === t && 1 === e ? new yc : new Th } } } class vc extends Qh { constructor() { super(), vc.constructor_.apply(this, arguments) } static constructor_() { if (0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; this.ensureCapacity(t.length), this.add(t, !0) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.ensureCapacity(t.length), this.add(t, e) } } getCoordinate(t) { return this.get(t) } addAll() { if (2 === arguments.length && "boolean" == typeof arguments[1] && Nh(arguments[0], Hh)) { const t = arguments[1]; let e = !1; for (let n = arguments[0].iterator(); n.hasNext();)this.add(n.next(), t), e = !0; return e } return super.addAll.apply(this, arguments) } clone() { const t = super.clone.call(this); for (let e = 0; e < this.size(); e++)t.add(e, this.get(e).clone()); return t } toCoordinateArray() { if (0 === arguments.length) return this.toArray(vc.coordArrayType); if (1 === arguments.length) { if (arguments[0]) return this.toArray(vc.coordArrayType); const t = this.size(), e = new Array(t).fill(null); for (let n = 0; n < t; n++)e[n] = this.get(t - n - 1); return e } } add() { if (1 === arguments.length) { const t = arguments[0]; return super.add.call(this, t) } if (2 === arguments.length) { if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; return this.add(t, e, !0), !0 } if (arguments[0] instanceof Th && "boolean" == typeof arguments[1]) { const t = arguments[0]; if (!arguments[1] && this.size() >= 1) { if (this.get(this.size() - 1).equals2D(t)) return null } super.add.call(this, t) } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; return this.add(t, e), !0 } } else if (3 === arguments.length) { if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; if (arguments[2]) for (let n = 0; n < t.length; n++)this.add(t[n], e); else for (let n = t.length - 1; n >= 0; n--)this.add(t[n], e); return !0 } if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof Th) { const t = arguments[0], e = arguments[1]; if (!arguments[2]) { const n = this.size(); if (n > 0) { if (t > 0) { if (this.get(t - 1).equals2D(e)) return null } if (t < n) { if (this.get(t).equals2D(e)) return null } } } super.add.call(this, t, e) } } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; let r = 1; n > i && (r = -1); for (let s = n; s !== i; s += r)this.add(t[s], e); return !0 } } closeRing() { if (this.size() > 0) { const t = this.get(0).copy(); this.add(t, !1) } } } vc.coordArrayType = new Array(0).fill(null); class xc { static log10(t) { const e = Math.log(t); return yh.isInfinite(e) || yh.isNaN(e) ? e : e / xc.LOG_10 } static min(t, e, n, i) { let r = t; return e < r && (r = e), n < r && (r = n), i < r && (r = i), r } static clamp() { if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1], n = arguments[2]; return t < e ? e : t > n ? n : t } if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { const t = arguments[0], e = arguments[1], n = arguments[2]; return t < e ? e : t > n ? n : t } } static wrap(t, e) { return t < 0 ? e - -t % e : t % e } static max() { if (3 === arguments.length) { const t = arguments[1], e = arguments[2]; let n = arguments[0]; return t > n && (n = t), e > n && (n = e), n } if (4 === arguments.length) { const t = arguments[1], e = arguments[2], n = arguments[3]; let i = arguments[0]; return t > i && (i = t), e > i && (i = e), n > i && (i = n), i } } static average(t, e) { return (t + e) / 2 } } xc.LOG_10 = Math.log(10); class Ec { static arraycopy(t, e, n, i, r) { let s = 0; for (let o = e; o < e + r; o++)n[i + s] = t[o], s++ } static getProperty(t) { return { "line.separator": "\n" }[t] } } class Ic { static isRing(t) { return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]) } static ptNotInList(t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; if (Ic.indexOf(i, e) < 0) return i } return null } static scroll(t, e) { const n = Ic.indexOf(e, t); if (n < 0) return null; const i = new Array(t.length).fill(null); Ec.arraycopy(t, n, i, 0, t.length - n), Ec.arraycopy(t, 0, i, t.length - n, n), Ec.arraycopy(i, 0, t, 0, t.length) } static equals() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; if (t === e) return !0; if (null === t || null === e) return !1; if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++)if (!t[n].equals(e[n])) return !1; return !0 } if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; if (t === e) return !0; if (null === t || null === e) return !1; if (t.length !== e.length) return !1; for (let i = 0; i < t.length; i++)if (0 !== n.compare(t[i], e[i])) return !1; return !0 } } static intersection(t, e) { const n = new vc; for (let i = 0; i < t.length; i++)e.intersects(t[i]) && n.add(t[i], !0); return n.toCoordinateArray() } static measures(t) { if (null === t || 0 === t.length) return 0; let e = 0; for (const n of t) e = Math.max(e, mc.measures(n)); return e } static hasRepeatedPoints(t) { for (let e = 1; e < t.length; e++)if (t[e - 1].equals(t[e])) return !0; return !1 } static removeRepeatedPoints(t) { if (!Ic.hasRepeatedPoints(t)) return t; return new vc(t, !1).toCoordinateArray() } static reverse(t) { const e = t.length - 1, n = Math.trunc(e / 2); for (let i = 0; i <= n; i++) { const n = t[i]; t[i] = t[e - i], t[e - i] = n } } static removeNull(t) { let e = 0; for (let n = 0; n < t.length; n++)null !== t[n] && e++; const n = new Array(e).fill(null); if (0 === e) return n; let i = 0; for (let e = 0; e < t.length; e++)null !== t[e] && (n[i++] = t[e]); return n } static copyDeep() { if (1 === arguments.length) { const t = arguments[0], e = new Array(t.length).fill(null); for (let n = 0; n < t.length; n++)e[n] = t[n].copy(); return e } if (5 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3], r = arguments[4]; for (let s = 0; s < r; s++)n[i + s] = t[e + s].copy() } } static isEqualReversed(t, e) { for (let n = 0; n < t.length; n++) { const i = t[n], r = e[t.length - n - 1]; if (0 !== i.compareTo(r)) return !1 } return !0 } static envelope(t) { const e = new Dh; for (let n = 0; n < t.length; n++)e.expandToInclude(t[n]); return e } static toCoordinateArray(t) { return t.toArray(Ic.coordArrayType) } static dimension(t) { if (null === t || 0 === t.length) return 3; let e = 0; for (const n of t) e = Math.max(e, mc.dimension(n)); return e } static atLeastNCoordinatesOrNothing(t, e) { return e.length >= t ? e : [] } static indexOf(t, e) { for (let n = 0; n < e.length; n++)if (t.equals(e[n])) return n; return -1 } static increasingDirection(t) { for (let e = 0; e < Math.trunc(t.length / 2); e++) { const n = t.length - 1 - e, i = t[e].compareTo(t[n]); if (0 !== i) return i } return 1 } static compare(t, e) { let n = 0; for (; n < t.length && n < e.length;) { const i = t[n].compareTo(e[n]); if (0 !== i) return i; n++ } return n < e.length ? -1 : n < t.length ? 1 : 0 } static minCoordinate(t) { let e = null; for (let n = 0; n < t.length; n++)(null === e || e.compareTo(t[n]) > 0) && (e = t[n]); return e } static extract(t, e, n) { e = xc.clamp(e, 0, t.length); let i = (n = xc.clamp(n, -1, t.length)) - e + 1; n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0); const r = new Array(i).fill(null); if (0 === i) return r; let s = 0; for (let i = e; i <= n; i++)r[s++] = t[i]; return r } } Ic.ForwardComparator = class { compare(t, e) { const n = t, i = e; return Ic.compare(n, i) } get interfaces_() { return [xh] } }, Ic.BidirectionalComparator = class { compare(t, e) { const n = t, i = e; if (n.length < i.length) return -1; if (n.length > i.length) return 1; if (0 === n.length) return 0; const r = Ic.compare(n, i); return Ic.isEqualReversed(n, i) ? 0 : r } OLDcompare(t, e) { const n = t, i = e; if (n.length < i.length) return -1; if (n.length > i.length) return 1; if (0 === n.length) return 0; const r = Ic.increasingDirection(n), s = Ic.increasingDirection(i); let o = r > 0 ? 0 : n.length - 1, a = s > 0 ? 0 : n.length - 1; for (let t = 0; t < n.length; t++) { const t = n[o].compareTo(i[a]); if (0 !== t) return t; o += r, a += s } return 0 } get interfaces_() { return [xh] } }, Ic.coordArrayType = new Array(0).fill(null); class Cc { constructor(t) { this.str = t } append(t) { this.str += t } setCharAt(t, e) { this.str = this.str.substr(0, t) + e + this.str.substr(t + 1) } toString() { return this.str } } class wc { constructor() { wc.constructor_.apply(this, arguments) } static constructor_() { if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) { if (arguments[0] instanceof Array) { const t = arguments[0]; wc.constructor_.call(this, t, Ic.dimension(t), Ic.measures(t)) } else if (Number.isInteger(arguments[0])) { const t = arguments[0]; this._coordinates = new Array(t).fill(null); for (let e = 0; e < t; e++)this._coordinates[e] = new Th } else if (Nh(arguments[0], Lh)) { const t = arguments[0]; if (null === t) return this._coordinates = new Array(0).fill(null), null; this._dimension = t.getDimension(), this._measures = t.getMeasures(), this._coordinates = new Array(t.size()).fill(null); for (let e = 0; e < this._coordinates.length; e++)this._coordinates[e] = t.getCoordinateCopy(e) } } else if (2 === arguments.length) { if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) { const t = arguments[0], e = arguments[1]; wc.constructor_.call(this, t, e, Ic.measures(t)) } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { const t = arguments[0], e = arguments[1]; this._coordinates = new Array(t).fill(null), this._dimension = e; for (let n = 0; n < t; n++)this._coordinates[n] = mc.create(e) } } else if (3 === arguments.length) if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._dimension = e, this._measures = n, this._coordinates = null === t ? new Array(0).fill(null) : t } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._coordinates = new Array(t).fill(null), this._dimension = e, this._measures = n; for (let e = 0; e < t; e++)this._coordinates[e] = this.createCoordinate() } } getM(t) { return this.hasM() ? this._coordinates[t].getM() : yh.NaN } setOrdinate(t, e, n) { switch (e) { case Lh.X: this._coordinates[t].x = n; break; case Lh.Y: this._coordinates[t].y = n; break; default: this._coordinates[t].setOrdinate(e, n) } } getZ(t) { return this.hasZ() ? this._coordinates[t].getZ() : yh.NaN } size() { return this._coordinates.length } getOrdinate(t, e) { switch (e) { case Lh.X: return this._coordinates[t].x; case Lh.Y: return this._coordinates[t].y; default: return this._coordinates[t].getOrdinate(e) } } getCoordinate() { if (1 === arguments.length) { const t = arguments[0]; return this._coordinates[t] } if (2 === arguments.length) { const t = arguments[0]; arguments[1].setCoordinate(this._coordinates[t]) } } getCoordinateCopy(t) { const e = this.createCoordinate(); return e.setCoordinate(this._coordinates[t]), e } createCoordinate() { return mc.create(this.getDimension(), this.getMeasures()) } getDimension() { return this._dimension } getX(t) { return this._coordinates[t].x } getMeasures() { return this._measures } expandEnvelope(t) { for (let e = 0; e < this._coordinates.length; e++)t.expandToInclude(this._coordinates[e]); return t } copy() { const t = new Array(this.size()).fill(null); for (let e = 0; e < this._coordinates.length; e++) { const n = this.createCoordinate(); n.setCoordinate(this._coordinates[e]), t[e] = n } return new wc(t, this._dimension, this._measures) } toString() { if (this._coordinates.length > 0) { const t = new Cc(17 * this._coordinates.length); t.append("("), t.append(this._coordinates[0]); for (let e = 1; e < this._coordinates.length; e++)t.append(", "), t.append(this._coordinates[e]); return t.append(")"), t.toString() } return "()" } getY(t) { return this._coordinates[t].y } toCoordinateArray() { return this._coordinates } get interfaces_() { return [Lh, Eh] } } class Sc { static instance() { return Sc.instanceObject } readResolve() { return Sc.instance() } create() { if (1 === arguments.length) { if (arguments[0] instanceof Array) { return new wc(arguments[0]) } if (Nh(arguments[0], Lh)) { return new wc(arguments[0]) } } else { if (2 === arguments.length) { let t = arguments[1]; return t > 3 && (t = 3), t < 2 && (t = 2), new wc(arguments[0], t) } if (3 === arguments.length) { let t = arguments[2], e = arguments[1] - t; return t > 1 && (t = 1), e > 3 && (e = 3), e < 2 && (e = 2), new wc(arguments[0], e + t, t) } } } get interfaces_() { return [Ph, Eh] } } Sc.instanceObject = new Sc; class bc extends fc { constructor() { super(), bc.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0], e = arguments[1]; fc.constructor_.call(this, t, e) } copyInternal() { const t = new Array(this._geometries.length).fill(null); for (let e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new bc(t, this._factory) } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && super.equalsExact.call(this, t, e) } return super.equalsExact.apply(this, arguments) } getBoundaryDimension() { return 1 } getTypeCode() { return Ah.TYPECODE_MULTIPOLYGON } getDimension() { return 2 } getBoundary() { if (this.isEmpty()) return this.getFactory().createMultiLineString(); const t = new Qh; for (let e = 0; e < this._geometries.length; e++) { const n = this._geometries[e].getBoundary(); for (let e = 0; e < n.getNumGeometries(); e++)t.add(n.getGeometryN(e)) } const e = new Array(t.size()).fill(null); return this.getFactory().createMultiLineString(t.toArray(e)) } getGeometryType() { return Ah.TYPENAME_MULTIPOLYGON } get interfaces_() { return [oc] } } class Oc { get() { } put() { } size() { } values() { } entrySet() { } } class Tc extends lc { constructor(t) { super(), this.map = new Map, t instanceof Hh && this.addAll(t) } contains(t) { const e = t.hashCode ? t.hashCode() : t; return !!this.map.has(e) } add(t) { const e = t.hashCode ? t.hashCode() : t; return !this.map.has(e) && !!this.map.set(e, t) } addAll(t) { for (const e of t) this.add(e); return !0 } remove() { throw new jh } size() { return this.map.size } isEmpty() { return 0 === this.map.size } toArray() { return Array.from(this.map.values()) } iterator() { return new Rc(this.map) } [Symbol.iterator]() { return this.map } } class Rc { constructor(t) { this.iterator = t.values(); const { done: e, value: n } = this.iterator.next(); this.done = e, this.value = n } next() { if (this.done) throw new Jh; const t = this.value, { done: e, value: n } = this.iterator.next(); return this.done = e, this.value = n, t } hasNext() { return !this.done } remove() { throw new jh } } class Nc extends Oc { constructor() { super(), this.map = new Map } get(t) { return this.map.get(t) || null } put(t, e) { return this.map.set(t, e), e } values() { const t = new Qh, e = this.map.values(); let n = e.next(); for (; !n.done;)t.add(n.value), n = e.next(); return t } entrySet() { const t = new Tc; return this.map.entries().forEach(e => t.add(e)), t } size() { return this.map.size() } } class Lc { constructor() { Lc.constructor_.apply(this, arguments) } static constructor_() { if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = Lc.FLOATING; else if (1 === arguments.length) if (arguments[0] instanceof Pc) { const t = arguments[0]; this._modelType = t, t === Lc.FIXED && this.setScale(1) } else if ("number" == typeof arguments[0]) { const t = arguments[0]; this._modelType = Lc.FIXED, this.setScale(t) } else if (arguments[0] instanceof Lc) { const t = arguments[0]; this._modelType = t._modelType, this._scale = t._scale } } static mostPrecise(t, e) { return t.compareTo(e) >= 0 ? t : e } equals(t) { if (!(t instanceof Lc)) return !1; const e = t; return this._modelType === e._modelType && this._scale === e._scale } compareTo(t) { const e = t, n = this.getMaximumSignificantDigits(), i = e.getMaximumSignificantDigits(); return nc.compare(n, i) } getScale() { return this._scale } isFloating() { return this._modelType === Lc.FLOATING || this._modelType === Lc.FLOATING_SINGLE } getType() { return this._modelType } toString() { let t = "UNKNOWN"; return this._modelType === Lc.FLOATING ? t = "Floating" : this._modelType === Lc.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === Lc.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t } makePrecise() { if ("number" == typeof arguments[0]) { const t = arguments[0]; if (yh.isNaN(t)) return t; if (this._modelType === Lc.FLOATING_SINGLE) { return t } return this._modelType === Lc.FIXED ? Math.round(t * this._scale) / this._scale : t } if (arguments[0] instanceof Th) { const t = arguments[0]; if (this._modelType === Lc.FLOATING) return null; t.x = this.makePrecise(t.x), t.y = this.makePrecise(t.y) } } getMaximumSignificantDigits() { let t = 16; return this._modelType === Lc.FLOATING ? t = 16 : this._modelType === Lc.FLOATING_SINGLE ? t = 6 : this._modelType === Lc.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t } setScale(t) { this._scale = Math.abs(t) } get interfaces_() { return [Eh, mh] } } class Pc { constructor() { Pc.constructor_.apply(this, arguments) } static constructor_() { this._name = null; const t = arguments[0]; this._name = t, Pc.nameToTypeMap.put(t, this) } readResolve() { return Pc.nameToTypeMap.get(this._name) } toString() { return this._name } get interfaces_() { return [Eh] } } Pc.nameToTypeMap = new Nc, Lc.Type = Pc, Lc.FIXED = new Pc("FIXED"), Lc.FLOATING = new Pc("FLOATING"), Lc.FLOATING_SINGLE = new Pc("FLOATING SINGLE"), Lc.maximumPreciseValue = 9007199254740992; class Mc extends fc { constructor() { super(), Mc.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0], e = arguments[1]; fc.constructor_.call(this, t, e) } copyInternal() { const t = new Array(this._geometries.length).fill(null); for (let e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new Mc(t, this._factory) } equalsExact() { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof Ah) { const t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && super.equalsExact.call(this, t, e) } return super.equalsExact.apply(this, arguments) } getBoundaryDimension() { return this.isClosed() ? Yh.FALSE : 0 } isClosed() { if (this.isEmpty()) return !1; for (let t = 0; t < this._geometries.length; t++)if (!this._geometries[t].isClosed()) return !1; return !0 } getTypeCode() { return Ah.TYPECODE_MULTILINESTRING } getDimension() { return 1 } getBoundary() { throw new jh } getGeometryType() { return Ah.TYPENAME_MULTILINESTRING } get interfaces_() { return [kh] } } class Dc { constructor() { Dc.constructor_.apply(this, arguments) } static constructor_() { if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) Dc.constructor_.call(this, new Lc, 0); else if (1 === arguments.length) { if (Nh(arguments[0], Ph)) { const t = arguments[0]; Dc.constructor_.call(this, new Lc, 0, t) } else if (arguments[0] instanceof Lc) { const t = arguments[0]; Dc.constructor_.call(this, t, 0, Dc.getDefaultCoordinateSequenceFactory()) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; Dc.constructor_.call(this, t, e, Dc.getDefaultCoordinateSequenceFactory()) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._precisionModel = t, this._coordinateSequenceFactory = n, this._SRID = e } } static toMultiPolygonArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static toGeometryArray(t) { if (null === t) return null; const e = new Array(t.size()).fill(null); return t.toArray(e) } static getDefaultCoordinateSequenceFactory() { return Sc.instance() } static toMultiLineStringArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static toLineStringArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static toMultiPointArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static toLinearRingArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static toPointArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static toPolygonArray(t) { const e = new Array(t.size()).fill(null); return t.toArray(e) } static createPointFromInternalCoord(t, e) { return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t) } createEmpty(t) { switch (t) { case -1: return this.createGeometryCollection(); case 0: return this.createPoint(); case 1: return this.createLineString(); case 2: return this.createPolygon(); default: throw new gh("Invalid dimension: " + t) } } toGeometry(t) { return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new Th(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new Th(t.getMinX(), t.getMinY()), new Th(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new Th(t.getMinX(), t.getMinY()), new Th(t.getMinX(), t.getMaxY()), new Th(t.getMaxX(), t.getMaxY()), new Th(t.getMaxX(), t.getMinY()), new Th(t.getMinX(), t.getMinY())]), null) } createLineString() { if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Array) { const t = arguments[0]; return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } if (Nh(arguments[0], Lh)) { return new zh(arguments[0], this) } } } createMultiLineString() { if (0 === arguments.length) return new Mc(null, this); if (1 === arguments.length) { return new Mc(arguments[0], this) } } buildGeometry(t) { let e = null, n = !1, i = !1; for (let r = t.iterator(); r.hasNext();) { const t = r.next(), s = t.getTypeCode(); null === e && (e = s), s !== e && (n = !0), t instanceof fc && (i = !0) } if (null === e) return this.createGeometryCollection(); if (n || i) return this.createGeometryCollection(Dc.toGeometryArray(t)); const r = t.iterator().next(); if (t.size() > 1) { if (r instanceof ac) return this.createMultiPolygon(Dc.toPolygonArray(t)); if (r instanceof zh) return this.createMultiLineString(Dc.toLineStringArray(t)); if (r instanceof Vh) return this.createMultiPoint(Dc.toPointArray(t)); wh.shouldNeverReachHere("Unhandled geometry type: " + r.getGeometryType()) } return r } createMultiPointFromCoords(t) { return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } createPoint() { if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Th) { const t = arguments[0]; return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null) } if (Nh(arguments[0], Lh)) { return new Vh(arguments[0], this) } } } getCoordinateSequenceFactory() { return this._coordinateSequenceFactory } createPolygon() { if (0 === arguments.length) return this.createPolygon(null, null); if (1 === arguments.length) { if (Nh(arguments[0], Lh)) { const t = arguments[0]; return this.createPolygon(this.createLinearRing(t)) } if (arguments[0] instanceof Array) { const t = arguments[0]; return this.createPolygon(this.createLinearRing(t)) } if (arguments[0] instanceof dc) { const t = arguments[0]; return this.createPolygon(t, null) } } else if (2 === arguments.length) { return new ac(arguments[0], arguments[1], this) } } getSRID() { return this._SRID } createGeometryCollection() { if (0 === arguments.length) return new fc(null, this); if (1 === arguments.length) { return new fc(arguments[0], this) } } getPrecisionModel() { return this._precisionModel } createLinearRing() { if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Array) { const t = arguments[0]; return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } if (Nh(arguments[0], Lh)) { return new dc(arguments[0], this) } } } createMultiPolygon() { if (0 === arguments.length) return new bc(null, this); if (1 === arguments.length) { return new bc(arguments[0], this) } } createMultiPoint() { if (0 === arguments.length) return new pc(null, this); if (1 === arguments.length) { if (arguments[0] instanceof Array) { return new pc(arguments[0], this) } if (Nh(arguments[0], Lh)) { const t = arguments[0]; if (null === t) return this.createMultiPoint(new Array(0).fill(null)); const e = new Array(t.size()).fill(null); for (let n = 0; n < t.size(); n++) { const i = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures()); Gh.copy(t, n, i, 0, 1), e[n] = this.createPoint(i) } return this.createMultiPoint(e) } } } get interfaces_() { return [Eh] } } function Ac(t) { return [t.x, t.y] } class Fc { constructor(t, e) { this.geometryFactory = t || new Dc, this.ol = e || "undefined" != typeof ol && ol } inject(t, e, n, i, r, s, o, a) { this.ol = { geom: { Point: t, LineString: e, LinearRing: n, Polygon: i, MultiPoint: r, MultiLineString: s, MultiPolygon: o, GeometryCollection: a } } } read(t) { const e = this.ol; return t instanceof e.geom.Point ? this.convertFromPoint(t) : t instanceof e.geom.LineString ? this.convertFromLineString(t) : t instanceof e.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof e.geom.Polygon ? this.convertFromPolygon(t) : t instanceof e.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof e.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof e.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof e.geom.GeometryCollection ? this.convertFromCollection(t) : void 0 } convertFromPoint(t) { const e = t.getCoordinates(); return this.geometryFactory.createPoint(new Th(e[0], e[1])) } convertFromLineString(t) { return this.geometryFactory.createLineString(t.getCoordinates().map((function (t) { return new Th(t[0], t[1]) }))) } convertFromLinearRing(t) { return this.geometryFactory.createLinearRing(t.getCoordinates().map((function (t) { return new Th(t[0], t[1]) }))) } convertFromPolygon(t) { const e = t.getLinearRings(); let n = null; const i = []; for (let t = 0; t < e.length; t++) { const r = this.convertFromLinearRing(e[t]); 0 === t ? n = r : i.push(r) } return this.geometryFactory.createPolygon(n, i) } convertFromMultiPoint(t) { const e = t.getPoints().map((function (t) { return this.convertFromPoint(t) }), this); return this.geometryFactory.createMultiPoint(e) } convertFromMultiLineString(t) { const e = t.getLineStrings().map((function (t) { return this.convertFromLineString(t) }), this); return this.geometryFactory.createMultiLineString(e) } convertFromMultiPolygon(t) { const e = t.getPolygons().map((function (t) { return this.convertFromPolygon(t) }), this); return this.geometryFactory.createMultiPolygon(e) } convertFromCollection(t) { const e = t.getGeometries().map((function (t) { return this.read(t) }), this); return this.geometryFactory.createGeometryCollection(e) } write(t) { return "Point" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : "LineString" === t.getGeometryType() ? this.convertToLineString(t) : "LinearRing" === t.getGeometryType() ? this.convertToLinearRing(t) : "Polygon" === t.getGeometryType() ? this.convertToPolygon(t) : "MultiPoint" === t.getGeometryType() ? this.convertToMultiPoint(t) : "MultiLineString" === t.getGeometryType() ? this.convertToMultiLineString(t) : "MultiPolygon" === t.getGeometryType() ? this.convertToMultiPolygon(t) : "GeometryCollection" === t.getGeometryType() ? this.convertToCollection(t) : void 0 } convertToPoint(t) { return new this.ol.geom.Point([t.x, t.y]) } convertToLineString(t) { const e = t._points._coordinates.map(Ac); return new this.ol.geom.LineString(e) } convertToLinearRing(t) { const e = t._points._coordinates.map(Ac); return new this.ol.geom.LinearRing(e) } convertToPolygon(t) { const e = [t._shell._points._coordinates.map(Ac)]; for (let n = 0; n < t._holes.length; n++)e.push(t._holes[n]._points._coordinates.map(Ac)); return new this.ol.geom.Polygon(e) } convertToMultiPoint(t) { return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ac)) } convertToMultiLineString(t) { const e = []; for (let n = 0; n < t._geometries.length; n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates()); return new this.ol.geom.MultiLineString(e) } convertToMultiPolygon(t) { const e = []; for (let n = 0; n < t._geometries.length; n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates()); return new this.ol.geom.MultiPolygon(e) } convertToCollection(t) { const e = []; for (let n = 0; n < t._geometries.length; n++) { const i = t._geometries[n]; e.push(this.write(i)) } return new this.ol.geom.GeometryCollection(e) } } class kc { constructor() { kc.constructor_.apply(this, arguments) } static constructor_() { if (this._quadrantSegments = kc.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = kc.CAP_ROUND, this._joinStyle = kc.JOIN_ROUND, this._mitreLimit = kc.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = kc.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; this.setQuadrantSegments(t) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.setQuadrantSegments(t), this.setEndCapStyle(e) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; this.setQuadrantSegments(t), this.setEndCapStyle(e), this.setJoinStyle(n), this.setMitreLimit(i) } } static bufferDistanceError(t) { const e = Math.PI / 2 / t; return 1 - Math.cos(e / 2) } getEndCapStyle() { return this._endCapStyle } isSingleSided() { return this._isSingleSided } setQuadrantSegments(t) { this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = kc.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = kc.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== kc.JOIN_ROUND && (this._quadrantSegments = kc.DEFAULT_QUADRANT_SEGMENTS) } getJoinStyle() { return this._joinStyle } setJoinStyle(t) { this._joinStyle = t } setSimplifyFactor(t) { this._simplifyFactor = t < 0 ? 0 : t } getSimplifyFactor() { return this._simplifyFactor } getQuadrantSegments() { return this._quadrantSegments } setEndCapStyle(t) { this._endCapStyle = t } getMitreLimit() { return this._mitreLimit } setMitreLimit(t) { this._mitreLimit = t } setSingleSided(t) { this._isSingleSided = t } } kc.CAP_ROUND = 1, kc.CAP_FLAT = 2, kc.CAP_SQUARE = 3, kc.JOIN_ROUND = 1, kc.JOIN_MITRE = 2, kc.JOIN_BEVEL = 3, kc.DEFAULT_QUADRANT_SEGMENTS = 8, kc.DEFAULT_MITRE_LIMIT = 5, kc.DEFAULT_SIMPLIFY_FACTOR = .01; class Gc { static toLocationSymbol(t) { switch (t) { case Gc.EXTERIOR: return "e"; case Gc.BOUNDARY: return "b"; case Gc.INTERIOR: return "i"; case Gc.NONE: return "-" }throw new gh("Unknown location value: " + t) } } Gc.INTERIOR = 0, Gc.BOUNDARY = 1, Gc.EXTERIOR = 2, Gc.NONE = -1; class jc { static opposite(t) { return t === jc.LEFT ? jc.RIGHT : t === jc.RIGHT ? jc.LEFT : t } } jc.ON = 0, jc.LEFT = 1, jc.RIGHT = 2; class Bc extends dh { constructor(t) { super(t), this.name = Object.keys({ EmptyStackException: Bc })[0] } } class Yc extends Zh { constructor() { super(), this.array = [] } add(t) { return this.array.push(t), !0 } get(t) { if (t < 0 || t >= this.size()) throw new Kh; return this.array[t] } push(t) { return this.array.push(t), t } pop() { if (0 === this.array.length) throw new Bc; return this.array.pop() } peek() { if (0 === this.array.length) throw new Bc; return this.array[this.array.length - 1] } empty() { return 0 === this.array.length } isEmpty() { return this.empty() } search(t) { return this.array.indexOf(t) } size() { return this.array.length } toArray() { return this.array.slice() } } class qc { constructor() { qc.constructor_.apply(this, arguments) } static constructor_() { this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null } getCoordinate() { return this._minCoord } getRightmostSide(t, e) { let n = this.getRightmostSideOfSegment(t, e); return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n } findRightmostEdgeAtVertex() { const t = this._minDe.getEdge().getCoordinates(); wh.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge"); const e = t[this._minIndex - 1], n = t[this._minIndex + 1], i = sc.index(this._minCoord, n, e); let r = !1; (e.y < this._minCoord.y && n.y < this._minCoord.y && i === sc.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && i === sc.CLOCKWISE) && (r = !0), r && (this._minIndex = this._minIndex - 1) } getRightmostSideOfSegment(t, e) { const n = t.getEdge().getCoordinates(); if (e < 0 || e + 1 >= n.length) return -1; if (n[e].y === n[e + 1].y) return -1; let i = jc.LEFT; return n[e].y < n[e + 1].y && (i = jc.RIGHT), i } getEdge() { return this._orientedDe } checkForRightmostCoordinate(t) { const e = t.getEdge().getCoordinates(); for (let n = 0; n < e.length - 1; n++)(null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]) } findRightmostEdgeAtNode() { const t = this._minDe.getNode().getEdges(); this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1) } findEdge(t) { for (let e = t.iterator(); e.hasNext();) { const t = e.next(); t.isForward() && this.checkForRightmostCoordinate(t) } wh.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe; this.getRightmostSide(this._minDe, this._minIndex) === jc.LEFT && (this._orientedDe = this._minDe.getSym()) } } class Xc extends Ih { constructor(t, e) { super(e ? t + " [ " + e + " ]" : t), this.pt = e ? new Th(e) : void 0, this.name = Object.keys({ TopologyException: Xc })[0] } getCoordinate() { return this.pt } } class zc { constructor() { this.array = [] } addLast(t) { this.array.push(t) } removeFirst() { return this.array.shift() } isEmpty() { return 0 === this.array.length } } class Uc { constructor() { Uc.constructor_.apply(this, arguments) } static constructor_() { this._finder = null, this._dirEdgeList = new Qh, this._nodes = new Qh, this._rightMostCoord = null, this._env = null, this._finder = new qc } clearVisitedEdges() { for (let t = this._dirEdgeList.iterator(); t.hasNext();) { t.next().setVisited(!1) } } getRightmostCoordinate() { return this._rightMostCoord } computeNodeDepth(t) { let e = null; for (let n = t.getEdges().iterator(); n.hasNext();) { const t = n.next(); if (t.isVisited() || t.getSym().isVisited()) { e = t; break } } if (null === e) throw new Xc("unable to find edge to compute depths at " + t.getCoordinate()); t.getEdges().computeDepths(e); for (let e = t.getEdges().iterator(); e.hasNext();) { const t = e.next(); t.setVisited(!0), this.copySymDepths(t) } } computeDepth(t) { this.clearVisitedEdges(); const e = this._finder.getEdge(); e.getNode(), e.getLabel(); e.setEdgeDepths(jc.RIGHT, t), this.copySymDepths(e), this.computeDepths(e) } create(t) { this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate() } findResultEdges() { for (let t = this._dirEdgeList.iterator(); t.hasNext();) { const e = t.next(); e.getDepth(jc.RIGHT) >= 1 && e.getDepth(jc.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0) } } computeDepths(t) { const e = new Tc, n = new zc, i = t.getNode(); for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) { const t = n.removeFirst(); e.add(t), this.computeNodeDepth(t); for (let i = t.getEdges().iterator(); i.hasNext();) { const t = i.next().getSym(); if (t.isVisited()) continue; const r = t.getNode(); e.contains(r) || (n.addLast(r), e.add(r)) } } } compareTo(t) { const e = t; return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0 } getEnvelope() { if (null === this._env) { const t = new Dh; for (let e = this._dirEdgeList.iterator(); e.hasNext();) { const n = e.next().getEdge().getCoordinates(); for (let e = 0; e < n.length - 1; e++)t.expandToInclude(n[e]) } this._env = t } return this._env } addReachable(t) { const e = new Yc; for (e.add(t); !e.empty();) { const t = e.pop(); this.add(t, e) } } copySymDepths(t) { const e = t.getSym(); e.setDepth(jc.LEFT, t.getDepth(jc.RIGHT)), e.setDepth(jc.RIGHT, t.getDepth(jc.LEFT)) } add(t, e) { t.setVisited(!0), this._nodes.add(t); for (let n = t.getEdges().iterator(); n.hasNext();) { const t = n.next(); this._dirEdgeList.add(t); const i = t.getSym().getNode(); i.isVisited() || e.push(i) } } getNodes() { return this._nodes } getDirectedEdges() { return this._dirEdgeList } get interfaces_() { return [mh] } } class Vc { static intersection(t, e, n, i) { const r = t.x < e.x ? t.x : e.x, s = t.y < e.y ? t.y : e.y, o = t.x > e.x ? t.x : e.x, a = t.y > e.y ? t.y : e.y, l = n.x < i.x ? n.x : i.x, h = n.y < i.y ? n.y : i.y, c = n.x > i.x ? n.x : i.x, u = n.y > i.y ? n.y : i.y, f = ((r > l ? r : l) + (o < c ? o : c)) / 2, p = ((s > h ? s : h) + (a < u ? a : u)) / 2, d = t.x - f, g = t.y - p, _ = e.x - f, y = e.y - p, m = n.x - f, v = n.y - p, x = i.x - f, E = i.y - p, I = g - y, C = _ - d, w = d * y - _ * g, S = v - E, b = x - m, O = m * E - x * v, T = I * b - S * C, R = (C * O - b * w) / T, N = (S * w - I * O) / T; return yh.isNaN(R) || yh.isInfinite(R) || yh.isNaN(N) || yh.isInfinite(N) ? null : new Th(R + f, N + p) } } class Wc { static segmentToSegment(t, e, n, i) { if (t.equals(e)) return Wc.pointToSegment(t, n, i); if (n.equals(i)) return Wc.pointToSegment(i, t, e); let r = !1; if (Dh.intersects(t, e, n, i)) { const s = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x); if (0 === s) r = !0; else { const o = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y), a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / s, l = o / s; (l < 0 || l > 1 || a < 0 || a > 1) && (r = !0) } } else r = !0; return r ? xc.min(Wc.pointToSegment(t, n, i), Wc.pointToSegment(e, n, i), Wc.pointToSegment(n, t, e), Wc.pointToSegment(i, t, e)) : 0 } static pointToSegment(t, e, n) { if (e.x === n.x && e.y === n.y) return t.distance(e); const i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y), r = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / i; if (r <= 0) return t.distance(e); if (r >= 1) return t.distance(n); const s = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i; return Math.abs(s) * Math.sqrt(i) } static pointToLinePerpendicular(t, e, n) { const i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y), r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i; return Math.abs(r) * Math.sqrt(i) } static pointToSegmentString(t, e) { if (0 === e.length) throw new gh("Line array must contain at least one vertex"); let n = t.distance(e[0]); for (let i = 0; i < e.length - 1; i++) { const r = Wc.pointToSegment(t, e[i], e[i + 1]); r < n && (n = r) } return n } } const Hc = "XY", Kc = "XYZ", Zc = "XYM", Jc = "XYZM", Qc = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, $c = 1, tu = 2, eu = 3, nu = 4, iu = 5, ru = 6, su = {}; for (const t in Qc) su[t] = Qc[t].toUpperCase(); class ou { constructor(t) { this.wkt = t, this.index_ = -1 } isAlpha_(t) { return t >= "a" && t <= "z" || t >= "A" && t <= "Z" } isNumeric_(t, e) { return t >= "0" && t <= "9" || "." == t && !(void 0 !== e && e) } isWhiteSpace_(t) { return " " == t || "\t" == t || "\r" == t || "\n" == t } nextChar_() { return this.wkt.charAt(++this.index_) } nextToken() { const t = this.nextChar_(), e = this.index_; let n, i = t; if ("(" == t) n = tu; else if ("," == t) n = iu; else if (")" == t) n = eu; else if (this.isNumeric_(t) || "-" == t) n = nu, i = this.readNumber_(); else if (this.isAlpha_(t)) n = $c, i = this.readText_(); else { if (this.isWhiteSpace_(t)) return this.nextToken(); if ("" !== t) throw new Error("Unexpected character: " + t); n = ru } return { position: e, value: i, type: n } } readNumber_() { let t; const e = this.index_; let n = !1, i = !1; do { "." == t ? n = !0 : "e" != t && "E" != t || (i = !0), t = this.nextChar_() } while (this.isNumeric_(t, n) || !i && ("e" == t || "E" == t) || i && ("-" == t || "+" == t)); return parseFloat(this.wkt.substring(e, this.index_--)) } readText_() { let t; const e = this.index_; do { t = this.nextChar_() } while (this.isAlpha_(t)); return this.wkt.substring(e, this.index_--).toUpperCase() } } class au { constructor(t, e) { this.lexer_ = t, this.token_, this.layout_ = Hc, this.factory = e } consume_() { this.token_ = this.lexer_.nextToken() } isTokenType(t) { return this.token_.type == t } match(t) { const e = this.isTokenType(t); return e && this.consume_(), e } parse() { this.consume_(); return this.parseGeometry_() } parseGeometryLayout_() { let t = Hc; const e = this.token_; if (this.isTokenType($c)) { const n = e.value; "Z" === n ? t = Kc : "M" === n ? t = Zc : "ZM" === n && (t = Jc), t !== Hc && this.consume_() } return t } parseGeometryCollectionText_() { if (this.match(tu)) { const t = []; do { t.push(this.parseGeometry_()) } while (this.match(iu)); if (this.match(eu)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } parsePointText_() { if (this.match(tu)) { const t = this.parsePoint_(); if (this.match(eu)) return t } else if (this.isEmptyGeometry_()) return null; throw new Error(this.formatErrorMessage_()) } parseLineStringText_() { if (this.match(tu)) { const t = this.parsePointList_(); if (this.match(eu)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } parsePolygonText_() { if (this.match(tu)) { const t = this.parseLineStringTextList_(); if (this.match(eu)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } parseMultiPointText_() { if (this.match(tu)) { let t; if (t = this.token_.type == tu ? this.parsePointTextList_() : this.parsePointList_(), this.match(eu)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } parseMultiLineStringText_() { if (this.match(tu)) { const t = this.parseLineStringTextList_(); if (this.match(eu)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } parseMultiPolygonText_() { if (this.match(tu)) { const t = this.parsePolygonTextList_(); if (this.match(eu)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } parsePoint_() { const t = [], e = this.layout_.length; for (let n = 0; n < e; ++n) { const e = this.token_; if (!this.match(nu)) break; t.push(e.value) } if (t.length == e) return t; throw new Error(this.formatErrorMessage_()) } parsePointList_() { const t = [this.parsePoint_()]; for (; this.match(iu);)t.push(this.parsePoint_()); return t } parsePointTextList_() { const t = [this.parsePointText_()]; for (; this.match(iu);)t.push(this.parsePointText_()); return t } parseLineStringTextList_() { const t = [this.parseLineStringText_()]; for (; this.match(iu);)t.push(this.parseLineStringText_()); return t } parsePolygonTextList_() { const t = [this.parsePolygonText_()]; for (; this.match(iu);)t.push(this.parsePolygonText_()); return t } isEmptyGeometry_() { const t = this.isTokenType($c) && "EMPTY" == this.token_.value; return t && this.consume_(), t } formatErrorMessage_() { return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`" } parseGeometry_() { const t = this.factory, e = t => new Th(...t), n = n => { const i = n.map(n => t.createLinearRing(n.map(e))); return i.length > 1 ? t.createPolygon(i[0], i.slice(1)) : t.createPolygon(i[0]) }, i = this.token_; if (this.match($c)) { const r = i.value; if (this.layout_ = this.parseGeometryLayout_(), "GEOMETRYCOLLECTION" == r) { const e = this.parseGeometryCollectionText_(); return t.createGeometryCollection(e) } switch (r) { case "POINT": { const e = this.parsePointText_(); return e ? t.createPoint(new Th(...e)) : t.createPoint() } case "LINESTRING": { const n = this.parseLineStringText_().map(e); return t.createLineString(n) } case "LINEARRING": { const n = this.parseLineStringText_().map(e); return t.createLinearRing(n) } case "POLYGON": { const e = this.parsePolygonText_(); return e && 0 !== e.length ? n(e) : t.createPolygon() } case "MULTIPOINT": { const n = this.parseMultiPointText_(); if (!n || 0 === n.length) return t.createMultiPoint(); const i = n.map(e).map(e => t.createPoint(e)); return t.createMultiPoint(i) } case "MULTILINESTRING": { const n = this.parseMultiLineStringText_().map(n => t.createLineString(n.map(e))); return t.createMultiLineString(n) } case "MULTIPOLYGON": { const e = this.parseMultiPolygonText_(); if (!e || 0 === e.length) return t.createMultiPolygon(); const i = e.map(n); return t.createMultiPolygon(i) } default: throw new Error("Invalid geometry type: " + r) } } throw new Error(this.formatErrorMessage_()) } } function lu(t) { if (t.isEmpty()) return ""; const e = t.getCoordinate(), n = [e.x, e.y]; return e.z && n.push(e.z), e.m && n.push(e.m), n.join(" ") } function hu(t) { const e = t.getCoordinates().map(t => [t.x, t.y]), n = []; for (let t = 0, i = e.length; t < i; ++t)n.push(e[t].join(" ")); return n.join(", ") } function cu(t) { const e = []; e.push("(" + hu(t.getExteriorRing()) + ")"); for (let n = 0, i = t.getNumInteriorRing(); n < i; ++n)e.push("(" + hu(t.getInteriorRingN(n)) + ")"); return e.join(", ") } const uu = { Point: lu, LineString: hu, LinearRing: hu, Polygon: cu, MultiPoint: function (t) { const e = []; for (let n = 0, i = t.getNumGeometries(); n < i; ++n)e.push("(" + lu(t.getGeometryN(n)) + ")"); return e.join(", ") }, MultiLineString: function (t) { const e = []; for (let n = 0, i = t.getNumGeometries(); n < i; ++n)e.push("(" + hu(t.getGeometryN(n)) + ")"); return e.join(", ") }, MultiPolygon: function (t) { const e = []; for (let n = 0, i = t.getNumGeometries(); n < i; ++n)e.push("(" + cu(t.getGeometryN(n)) + ")"); return e.join(", ") }, GeometryCollection: function (t) { const e = []; for (let n = 0, i = t.getNumGeometries(); n < i; ++n)e.push(fu(t.getGeometryN(n))); return e.join(", ") } }; function fu(t) { let e = t.getGeometryType(); const n = uu[e]; e = e.toUpperCase(); const i = function (t) { let e = ""; if (t.isEmpty()) return e; const n = t.getCoordinate(); return n.z && (e += "Z"), n.m && (e += "M"), e }(t); if (i.length > 0 && (e += " " + i), t.isEmpty()) return e + " EMPTY"; return e + " (" + n(t) + ")" } class pu { constructor(t) { this.geometryFactory = t || new Dc, this.precisionModel = this.geometryFactory.getPrecisionModel() } read(t) { const e = new ou(t); return new au(e, this.geometryFactory).parse() } write(t) { return fu(t) } } class du { constructor(t) { this.parser = new pu(t) } write(t) { return this.parser.write(t) } static toLineString(t, e) { if (2 !== arguments.length) throw new Error("Not implemented"); return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )" } } class gu { constructor() { gu.constructor_.apply(this, arguments) } static constructor_() { this._result = null, this._inputLines = Array(2).fill().map(() => Array(2)), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new Th, this._intPt[1] = new Th, this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0 } static computeEdgeDistance(t, e, n) { const i = Math.abs(n.x - e.x), r = Math.abs(n.y - e.y); let s = -1; if (t.equals(e)) s = 0; else if (t.equals(n)) s = i > r ? i : r; else { const n = Math.abs(t.x - e.x), o = Math.abs(t.y - e.y); s = i > r ? n : o, 0 !== s || t.equals(e) || (s = Math.max(n, o)) } return wh.isTrue(!(0 === s && !t.equals(e)), "Bad distance calculation"), s } static nonRobustComputeEdgeDistance(t, e, n) { const i = t.x - e.x, r = t.y - e.y, s = Math.sqrt(i * i + r * r); return wh.isTrue(!(0 === s && !t.equals(e)), "Invalid distance calculation"), s } getIndexAlongSegment(t, e) { return this.computeIntLineIndex(), this._intLineIndex[t][e] } getTopologySummary() { const t = new Cc; return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString() } computeIntersection(t, e, n, i) { this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i) } getIntersectionNum() { return this._result } computeIntLineIndex() { if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(() => Array(2)), this.computeIntLineIndex(0), this.computeIntLineIndex(1)); else if (1 === arguments.length) { const t = arguments[0]; this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0) } } isProper() { return this.hasIntersection() && this._isProper } setPrecisionModel(t) { this._precisionModel = t } isInteriorIntersection() { if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1); if (1 === arguments.length) { const t = arguments[0]; for (let e = 0; e < this._result; e++)if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0; return !1 } } getIntersection(t) { return this._intPt[t] } isEndPoint() { return this.hasIntersection() && !this._isProper } hasIntersection() { return this._result !== gu.NO_INTERSECTION } getEdgeDistance(t, e) { return gu.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]) } isCollinear() { return this._result === gu.COLLINEAR_INTERSECTION } toString() { return du.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + du.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary() } getEndpoint(t, e) { return this._inputLines[t][e] } isIntersection(t) { for (let e = 0; e < this._result; e++)if (this._intPt[e].equals2D(t)) return !0; return !1 } getIntersectionAlongSegment(t, e) { return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]] } } gu.DONT_INTERSECT = 0, gu.DO_INTERSECT = 1, gu.COLLINEAR = 2, gu.NO_INTERSECTION = 0, gu.POINT_INTERSECTION = 1, gu.COLLINEAR_INTERSECTION = 2; class _u extends gu { constructor() { super() } static nearestEndpoint(t, e, n, i) { let r = t, s = Wc.pointToSegment(t, n, i), o = Wc.pointToSegment(e, n, i); return o < s && (s = o, r = e), o = Wc.pointToSegment(n, t, e), o < s && (s = o, r = n), o = Wc.pointToSegment(i, t, e), o < s && (s = o, r = i), r } isInSegmentEnvelopes(t) { const e = new Dh(this._inputLines[0][0], this._inputLines[0][1]), n = new Dh(this._inputLines[1][0], this._inputLines[1][1]); return e.contains(t) && n.contains(t) } computeIntersection() { if (3 !== arguments.length) return super.computeIntersection.apply(this, arguments); { const t = arguments[0], e = arguments[1], n = arguments[2]; if (this._isProper = !1, Dh.intersects(e, n, t) && 0 === sc.index(e, n, t) && 0 === sc.index(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = gu.POINT_INTERSECTION, null; this._result = gu.NO_INTERSECTION } } intersection(t, e, n, i) { let r = this.intersectionSafe(t, e, n, i); return this.isInSegmentEnvelopes(r) || (r = new Th(_u.nearestEndpoint(t, e, n, i))), null !== this._precisionModel && this._precisionModel.makePrecise(r), r } checkDD(t, e, n, i, r) { const s = rc.intersection(t, e, n, i), o = this.isInSegmentEnvelopes(s); Ec.out.println("DD in env = " + o + "  --------------------- " + s), r.distance(s) > 1e-4 && Ec.out.println("Distance = " + r.distance(s)) } intersectionSafe(t, e, n, i) { let r = Vc.intersection(t, e, n, i); return null === r && (r = _u.nearestEndpoint(t, e, n, i)), r } computeCollinearIntersection(t, e, n, i) { const r = Dh.intersects(t, e, n), s = Dh.intersects(t, e, i), o = Dh.intersects(n, i, t), a = Dh.intersects(n, i, e); return r && s ? (this._intPt[0] = n, this._intPt[1] = i, gu.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = t, this._intPt[1] = e, gu.COLLINEAR_INTERSECTION) : r && o ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || s || a ? gu.COLLINEAR_INTERSECTION : gu.POINT_INTERSECTION) : r && a ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || s || o ? gu.COLLINEAR_INTERSECTION : gu.POINT_INTERSECTION) : s && o ? (this._intPt[0] = i, this._intPt[1] = t, !i.equals(t) || r || a ? gu.COLLINEAR_INTERSECTION : gu.POINT_INTERSECTION) : s && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || r || o ? gu.COLLINEAR_INTERSECTION : gu.POINT_INTERSECTION) : gu.NO_INTERSECTION } computeIntersect(t, e, n, i) { if (this._isProper = !1, !Dh.intersects(t, e, n, i)) return gu.NO_INTERSECTION; const r = sc.index(t, e, n), s = sc.index(t, e, i); if (r > 0 && s > 0 || r < 0 && s < 0) return gu.NO_INTERSECTION; const o = sc.index(n, i, t), a = sc.index(n, i, e); if (o > 0 && a > 0 || o < 0 && a < 0) return gu.NO_INTERSECTION; return 0 === r && 0 === s && 0 === o && 0 === a ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === s || 0 === o || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this._intPt[0] = e : 0 === r ? this._intPt[0] = new Th(n) : 0 === s ? this._intPt[0] = new Th(i) : 0 === o ? this._intPt[0] = new Th(t) : 0 === a && (this._intPt[0] = new Th(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, i)), gu.POINT_INTERSECTION) } } class yu { constructor() { yu.constructor_.apply(this, arguments) } static constructor_() { this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1; const t = arguments[0]; this._p = t } static locatePointInRing() { if (arguments[0] instanceof Th && Nh(arguments[1], Lh)) { const t = arguments[1], e = new yu(arguments[0]), n = new Th, i = new Th; for (let r = 1; r < t.size(); r++)if (t.getCoordinate(r, n), t.getCoordinate(r - 1, i), e.countSegment(n, i), e.isOnSegment()) return e.getLocation(); return e.getLocation() } if (arguments[0] instanceof Th && arguments[1] instanceof Array) { const t = arguments[1], e = new yu(arguments[0]); for (let n = 1; n < t.length; n++) { const i = t[n], r = t[n - 1]; if (e.countSegment(i, r), e.isOnSegment()) return e.getLocation() } return e.getLocation() } } countSegment(t, e) { if (t.x < this._p.x && e.x < this._p.x) return null; if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null; if (t.y === this._p.y && e.y === this._p.y) { let n = t.x, i = e.x; return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null } if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) { let n = sc.index(t, e, this._p); if (n === sc.COLLINEAR) return this._isPointOnSegment = !0, null; e.y < t.y && (n = -n), n === sc.LEFT && this._crossingCount++ } } isPointInPolygon() { return this.getLocation() !== Gc.EXTERIOR } getLocation() { return this._isPointOnSegment ? Gc.BOUNDARY : this._crossingCount % 2 == 1 ? Gc.INTERIOR : Gc.EXTERIOR } isOnSegment() { return this._isPointOnSegment } } class mu { static isOnLine() { if (arguments[0] instanceof Th && Nh(arguments[1], Lh)) { const t = arguments[0], e = arguments[1], n = new _u, i = new Th, r = new Th, s = e.size(); for (let o = 1; o < s; o++)if (e.getCoordinate(o - 1, i), e.getCoordinate(o, r), n.computeIntersection(t, i, r), n.hasIntersection()) return !0; return !1 } if (arguments[0] instanceof Th && arguments[1] instanceof Array) { const t = arguments[0], e = arguments[1], n = new _u; for (let i = 1; i < e.length; i++) { const r = e[i - 1], s = e[i]; if (n.computeIntersection(t, r, s), n.hasIntersection()) return !0 } return !1 } } static locateInRing(t, e) { return yu.locatePointInRing(t, e) } static isInRing(t, e) { return mu.locateInRing(t, e) !== Gc.EXTERIOR } } class vu { constructor() { vu.constructor_.apply(this, arguments) } static constructor_() { if (this.location = null, 1 === arguments.length) { if (arguments[0] instanceof Array) { const t = arguments[0]; this.init(t.length) } else if (Number.isInteger(arguments[0])) { const t = arguments[0]; this.init(1), this.location[jc.ON] = t } else if (arguments[0] instanceof vu) { const t = arguments[0]; if (this.init(t.location.length), null !== t) for (let e = 0; e < this.location.length; e++)this.location[e] = t.location[e] } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this.init(3), this.location[jc.ON] = t, this.location[jc.LEFT] = e, this.location[jc.RIGHT] = n } } setAllLocations(t) { for (let e = 0; e < this.location.length; e++)this.location[e] = t } isNull() { for (let t = 0; t < this.location.length; t++)if (this.location[t] !== Gc.NONE) return !1; return !0 } setAllLocationsIfNull(t) { for (let e = 0; e < this.location.length; e++)this.location[e] === Gc.NONE && (this.location[e] = t) } isLine() { return 1 === this.location.length } merge(t) { if (t.location.length > this.location.length) { const t = new Array(3).fill(null); t[jc.ON] = this.location[jc.ON], t[jc.LEFT] = Gc.NONE, t[jc.RIGHT] = Gc.NONE, this.location = t } for (let e = 0; e < this.location.length; e++)this.location[e] === Gc.NONE && e < t.location.length && (this.location[e] = t.location[e]) } getLocations() { return this.location } flip() { if (this.location.length <= 1) return null; const t = this.location[jc.LEFT]; this.location[jc.LEFT] = this.location[jc.RIGHT], this.location[jc.RIGHT] = t } toString() { const t = new ec; return this.location.length > 1 && t.append(Gc.toLocationSymbol(this.location[jc.LEFT])), t.append(Gc.toLocationSymbol(this.location[jc.ON])), this.location.length > 1 && t.append(Gc.toLocationSymbol(this.location[jc.RIGHT])), t.toString() } setLocations(t, e, n) { this.location[jc.ON] = t, this.location[jc.LEFT] = e, this.location[jc.RIGHT] = n } get(t) { return t < this.location.length ? this.location[t] : Gc.NONE } isArea() { return this.location.length > 1 } isAnyNull() { for (let t = 0; t < this.location.length; t++)if (this.location[t] === Gc.NONE) return !0; return !1 } setLocation() { if (1 === arguments.length) { const t = arguments[0]; this.setLocation(jc.ON, t) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.location[t] = e } } init(t) { this.location = new Array(t).fill(null), this.setAllLocations(Gc.NONE) } isEqualOnSide(t, e) { return this.location[e] === t.location[e] } allPositionsEqual(t) { for (let e = 0; e < this.location.length; e++)if (this.location[e] !== t) return !1; return !0 } } class xu { constructor() { xu.constructor_.apply(this, arguments) } static constructor_() { if (this.elt = new Array(2).fill(null), 1 === arguments.length) { if (Number.isInteger(arguments[0])) { const t = arguments[0]; this.elt[0] = new vu(t), this.elt[1] = new vu(t) } else if (arguments[0] instanceof xu) { const t = arguments[0]; this.elt[0] = new vu(t.elt[0]), this.elt[1] = new vu(t.elt[1]) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.elt[0] = new vu(Gc.NONE), this.elt[1] = new vu(Gc.NONE), this.elt[t].setLocation(e) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this.elt[0] = new vu(t, e, n), this.elt[1] = new vu(t, e, n) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; this.elt[0] = new vu(Gc.NONE, Gc.NONE, Gc.NONE), this.elt[1] = new vu(Gc.NONE, Gc.NONE, Gc.NONE), this.elt[t].setLocations(e, n, i) } } static toLineLabel(t) { const e = new xu(Gc.NONE); for (let n = 0; n < 2; n++)e.setLocation(n, t.getLocation(n)); return e } getGeometryCount() { let t = 0; return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t } setAllLocations(t, e) { this.elt[t].setAllLocations(e) } isNull(t) { return this.elt[t].isNull() } setAllLocationsIfNull() { if (1 === arguments.length) { const t = arguments[0]; this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.elt[t].setAllLocationsIfNull(e) } } isLine(t) { return this.elt[t].isLine() } merge(t) { for (let e = 0; e < 2; e++)null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new vu(t.elt[e]) : this.elt[e].merge(t.elt[e]) } flip() { this.elt[0].flip(), this.elt[1].flip() } getLocation() { if (1 === arguments.length) { const t = arguments[0]; return this.elt[t].get(jc.ON) } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return this.elt[t].get(e) } } toString() { const t = new ec; return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString() } isArea() { if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea(); if (1 === arguments.length) { const t = arguments[0]; return this.elt[t].isArea() } } isAnyNull(t) { return this.elt[t].isAnyNull() } setLocation() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.elt[t].setLocation(jc.ON, e) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this.elt[t].setLocation(e, n) } } isEqualOnSide(t, e) { return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e) } allPositionsEqual(t, e) { return this.elt[t].allPositionsEqual(e) } toLine(t) { this.elt[t].isArea() && (this.elt[t] = new vu(this.elt[t].location[0])) } } class Eu { constructor() { Eu.constructor_.apply(this, arguments) } static constructor_() { if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new Qh, this._pts = new Qh, this._label = new xu(Gc.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Qh, this._geometryFactory = null, 0 === arguments.length); else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this._geometryFactory = e, this.computePoints(t), this.computeRing() } } computeRing() { if (null !== this._ring) return null; const t = new Array(this._pts.size()).fill(null); for (let e = 0; e < this._pts.size(); e++)t[e] = this._pts.get(e); this._ring = this._geometryFactory.createLinearRing(t), this._isHole = sc.isCCW(this._ring.getCoordinates()) } isIsolated() { return 1 === this._label.getGeometryCount() } computePoints(t) { this._startDe = t; let e = t, n = !0; do { if (null === e) throw new Xc("Found null DirectedEdge"); if (e.getEdgeRing() === this) throw new Xc("Directed Edge visited twice during ring-building at " + e.getCoordinate()); this._edges.add(e); const t = e.getLabel(); wh.isTrue(t.isArea()), this.mergeLabel(t), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e) } while (e !== this._startDe) } getLinearRing() { return this._ring } getCoordinate(t) { return this._pts.get(t) } computeMaxNodeDegree() { this._maxNodeDegree = 0; let t = this._startDe; do { const e = t.getNode().getEdges().getOutgoingDegree(this); e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t) } while (t !== this._startDe); this._maxNodeDegree *= 2 } addPoints(t, e, n) { const i = t.getCoordinates(); if (e) { let t = 1; n && (t = 0); for (let e = t; e < i.length; e++)this._pts.add(i[e]) } else { let t = i.length - 2; n && (t = i.length - 1); for (let e = t; e >= 0; e--)this._pts.add(i[e]) } } isHole() { return this._isHole } setInResult() { let t = this._startDe; do { t.getEdge().setInResult(!0), t = t.getNext() } while (t !== this._startDe) } containsPoint(t) { const e = this.getLinearRing(); if (!e.getEnvelopeInternal().contains(t)) return !1; if (!mu.isInRing(t, e.getCoordinates())) return !1; for (let e = this._holes.iterator(); e.hasNext();) { if (e.next().containsPoint(t)) return !1 } return !0 } addHole(t) { this._holes.add(t) } isShell() { return null === this._shell } getLabel() { return this._label } getEdges() { return this._edges } getMaxNodeDegree() { return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree } getShell() { return this._shell } mergeLabel() { if (1 === arguments.length) { const t = arguments[0]; this.mergeLabel(t, 0), this.mergeLabel(t, 1) } else if (2 === arguments.length) { const t = arguments[1], e = arguments[0].getLocation(t, jc.RIGHT); if (e === Gc.NONE) return null; if (this._label.getLocation(t) === Gc.NONE) return this._label.setLocation(t, e), null } } setShell(t) { this._shell = t, null !== t && t.addHole(this) } toPolygon(t) { const e = new Array(this._holes.size()).fill(null); for (let t = 0; t < this._holes.size(); t++)e[t] = this._holes.get(t).getLinearRing(); return t.createPolygon(this.getLinearRing(), e) } } class Iu extends Eu { constructor() { super(), Iu.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0], e = arguments[1]; Eu.constructor_.call(this, t, e) } setEdgeRing(t, e) { t.setMinEdgeRing(e) } getNext(t) { return t.getNextMin() } } class Cu extends Eu { constructor() { super(), Cu.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0], e = arguments[1]; Eu.constructor_.call(this, t, e) } buildMinimalRings() { const t = new Qh; let e = this._startDe; do { if (null === e.getMinEdgeRing()) { const n = new Iu(e, this._geometryFactory); t.add(n) } e = e.getNext() } while (e !== this._startDe); return t } setEdgeRing(t, e) { t.setEdgeRing(e) } linkDirectedEdgesForMinimalEdgeRings() { let t = this._startDe; do { t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext() } while (t !== this._startDe) } getNext(t) { return t.getNext() } } class wu { constructor() { wu.constructor_.apply(this, arguments) } static constructor_() { if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; this._label = t } } setVisited(t) { this._isVisited = t } setInResult(t) { this._isInResult = t } isCovered() { return this._isCovered } isCoveredSet() { return this._isCoveredSet } setLabel(t) { this._label = t } getLabel() { return this._label } setCovered(t) { this._isCovered = t, this._isCoveredSet = !0 } updateIM(t) { wh.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t) } isInResult() { return this._isInResult } isVisited() { return this._isVisited } } class Su extends wu { constructor() { super(), Su.constructor_.apply(this, arguments) } static constructor_() { this._coord = null, this._edges = null; const t = arguments[0], e = arguments[1]; this._coord = t, this._edges = e, this._label = new xu(0, Gc.NONE) } isIncidentEdgeInResult() { for (let t = this.getEdges().getEdges().iterator(); t.hasNext();) { if (t.next().getEdge().isInResult()) return !0 } return !1 } isIsolated() { return 1 === this._label.getGeometryCount() } getCoordinate() { return this._coord } print(t) { t.println("node " + this._coord + " lbl: " + this._label) } computeIM(t) { } computeMergedLocation(t, e) { let n = Gc.NONE; if (n = this._label.getLocation(e), !t.isNull(e)) { const i = t.getLocation(e); n !== Gc.BOUNDARY && (n = i) } return n } setLabel() { if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return super.setLabel.apply(this, arguments); { const t = arguments[0], e = arguments[1]; null === this._label ? this._label = new xu(t, e) : this._label.setLocation(t, e) } } getEdges() { return this._edges } mergeLabel() { if (arguments[0] instanceof Su) { const t = arguments[0]; this.mergeLabel(t._label) } else if (arguments[0] instanceof xu) { const t = arguments[0]; for (let e = 0; e < 2; e++) { const n = this.computeMergedLocation(t, e); this._label.getLocation(e) === Gc.NONE && this._label.setLocation(e, n) } } } add(t) { this._edges.insert(t), t.setNode(this) } setLabelBoundary(t) { if (null === this._label) return null; let e = Gc.NONE; null !== this._label && (e = this._label.getLocation(t)); let n = null; switch (e) { case Gc.BOUNDARY: n = Gc.INTERIOR; break; case Gc.INTERIOR: default: n = Gc.BOUNDARY }this._label.setLocation(t, n) } } class bu extends Oc { } function Ou(t) { return null == t ? 0 : t.color } function Tu(t) { return null == t ? null : t.parent } function Ru(t, e) { null !== t && (t.color = e) } function Nu(t) { return null == t ? null : t.left } function Lu(t) { return null == t ? null : t.right } class Pu extends bu { constructor() { super(), this.root_ = null, this.size_ = 0 } get(t) { let e = this.root_; for (; null !== e;) { const n = t.compareTo(e.key); if (n < 0) e = e.left; else { if (!(n > 0)) return e.value; e = e.right } } return null } put(t, e) { if (null === this.root_) return this.root_ = { key: t, value: e, left: null, right: null, parent: null, color: 0, getValue() { return this.value }, getKey() { return this.key } }, this.size_ = 1, null; let n, i, r = this.root_; do { if (n = r, i = t.compareTo(r.key), i < 0) r = r.left; else { if (!(i > 0)) { const t = r.value; return r.value = e, t } r = r.right } } while (null !== r); const s = { key: t, left: null, right: null, value: e, parent: n, color: 0, getValue() { return this.value }, getKey() { return this.key } }; return i < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null } fixAfterInsertion(t) { let e; for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;)Tu(t) === Nu(Tu(Tu(t))) ? (e = Lu(Tu(Tu(t))), 1 === Ou(e) ? (Ru(Tu(t), 0), Ru(e, 0), Ru(Tu(Tu(t)), 1), t = Tu(Tu(t))) : (t === Lu(Tu(t)) && (t = Tu(t), this.rotateLeft(t)), Ru(Tu(t), 0), Ru(Tu(Tu(t)), 1), this.rotateRight(Tu(Tu(t))))) : (e = Nu(Tu(Tu(t))), 1 === Ou(e) ? (Ru(Tu(t), 0), Ru(e, 0), Ru(Tu(Tu(t)), 1), t = Tu(Tu(t))) : (t === Nu(Tu(t)) && (t = Tu(t), this.rotateRight(t)), Ru(Tu(t), 0), Ru(Tu(Tu(t)), 1), this.rotateLeft(Tu(Tu(t))))); this.root_.color = 0 } values() { const t = new Qh; let e = this.getFirstEntry(); if (null !== e) for (t.add(e.value); null !== (e = Pu.successor(e));)t.add(e.value); return t } entrySet() { const t = new Tc; let e = this.getFirstEntry(); if (null !== e) for (t.add(e); null !== (e = Pu.successor(e));)t.add(e); return t } rotateLeft(t) { if (null != t) { const e = t.right; t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e } } rotateRight(t) { if (null != t) { const e = t.left; t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e } } getFirstEntry() { let t = this.root_; if (null != t) for (; null != t.left;)t = t.left; return t } static successor(t) { let e; if (null === t) return null; if (null !== t.right) { for (e = t.right; null !== e.left;)e = e.left; return e } { e = t.parent; let n = t; for (; null !== e && n === e.right;)n = e, e = e.parent; return e } } size() { return this.size_ } containsKey(t) { let e = this.root_; for (; null !== e;) { const n = t.compareTo(e.key); if (n < 0) e = e.left; else { if (!(n > 0)) return !0; e = e.right } } return !1 } } class Mu { constructor() { Mu.constructor_.apply(this, arguments) } static constructor_() { this.nodeMap = new Pu, this.nodeFact = null; const t = arguments[0]; this.nodeFact = t } find(t) { return this.nodeMap.get(t) } addNode() { if (arguments[0] instanceof Th) { const t = arguments[0]; let e = this.nodeMap.get(t); return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e } if (arguments[0] instanceof Su) { const t = arguments[0], e = this.nodeMap.get(t.getCoordinate()); return null === e ? (this.nodeMap.put(t.getCoordinate(), t), t) : (e.mergeLabel(t), e) } } print(t) { for (let e = this.iterator(); e.hasNext();) { e.next().print(t) } } iterator() { return this.nodeMap.values().iterator() } values() { return this.nodeMap.values() } getBoundaryNodes(t) { const e = new Qh; for (let n = this.iterator(); n.hasNext();) { const i = n.next(); i.getLabel().getLocation(t) === Gc.BOUNDARY && e.add(i) } return e } add(t) { const e = t.getCoordinate(); this.addNode(e).add(t) } } class Du { static isNorthern(t) { return t === Du.NE || t === Du.NW } static isOpposite(t, e) { if (t === e) return !1; return 2 === (t - e + 4) % 4 } static commonHalfPlane(t, e) { if (t === e) return t; if (2 === (t - e + 4) % 4) return -1; const n = t < e ? t : e; return 0 === n && 3 === (t > e ? t : e) ? 3 : n } static isInHalfPlane(t, e) { return e === Du.SE ? t === Du.SE || t === Du.SW : t === e || t === e + 1 } static quadrant() { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; if (0 === t && 0 === e) throw new gh("Cannot compute the quadrant for point ( " + t + ", " + e + " )"); return t >= 0 ? e >= 0 ? Du.NE : Du.SE : e >= 0 ? Du.NW : Du.SW } if (arguments[0] instanceof Th && arguments[1] instanceof Th) { const t = arguments[0], e = arguments[1]; if (e.x === t.x && e.y === t.y) throw new gh("Cannot compute the quadrant for two identical points " + t); return e.x >= t.x ? e.y >= t.y ? Du.NE : Du.SE : e.y >= t.y ? Du.NW : Du.SW } } } Du.NE = 0, Du.NW = 1, Du.SW = 2, Du.SE = 3; class Au { constructor() { Au.constructor_.apply(this, arguments) } static constructor_() { if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) { const t = arguments[0]; this._edge = t } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; Au.constructor_.call(this, t, e, n, null) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; Au.constructor_.call(this, t), this.init(e, n), this._label = i } } compareDirection(t) { return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : sc.index(t._p0, t._p1, this._p1) } getDy() { return this._dy } getCoordinate() { return this._p0 } setNode(t) { this._node = t } print(t) { const e = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), i = n.lastIndexOf("."), r = n.substring(i + 1); t.print("  " + r + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label) } compareTo(t) { const e = t; return this.compareDirection(e) } getDirectedCoordinate() { return this._p1 } getDx() { return this._dx } getLabel() { return this._label } getEdge() { return this._edge } getQuadrant() { return this._quadrant } getNode() { return this._node } toString() { const t = Math.atan2(this._dy, this._dx), e = this.getClass().getName(), n = e.lastIndexOf("."); return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label } computeLabel(t) { } init(t, e) { this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Du.quadrant(this._dx, this._dy), wh.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found") } get interfaces_() { return [mh] } } class Fu extends Au { constructor() { super(), Fu.constructor_.apply(this, arguments) } static constructor_() { this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999]; const t = arguments[0], e = arguments[1]; if (Au.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1)); else { const e = t.getNumPoints() - 1; this.init(t.getCoordinate(e), t.getCoordinate(e - 1)) } this.computeDirectedLabel() } static depthFactor(t, e) { return t === Gc.EXTERIOR && e === Gc.INTERIOR ? 1 : t === Gc.INTERIOR && e === Gc.EXTERIOR ? -1 : 0 } getNextMin() { return this._nextMin } getDepth(t) { return this._depth[t] } setVisited(t) { this._isVisited = t } computeDirectedLabel() { this._label = new xu(this._edge.getLabel()), this._isForward || this._label.flip() } getNext() { return this._next } setDepth(t, e) { if (-999 !== this._depth[t] && this._depth[t] !== e) throw new Xc("assigned depths do not match", this.getCoordinate()); this._depth[t] = e } isInteriorAreaEdge() { let t = !0; for (let e = 0; e < 2; e++)this._label.isArea(e) && this._label.getLocation(e, jc.LEFT) === Gc.INTERIOR && this._label.getLocation(e, jc.RIGHT) === Gc.INTERIOR || (t = !1); return t } setNextMin(t) { this._nextMin = t } print(t) { super.print.call(this, t), t.print(" " + this._depth[jc.LEFT] + "/" + this._depth[jc.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult") } setMinEdgeRing(t) { this._minEdgeRing = t } isLineEdge() { const t = this._label.isLine(0) || this._label.isLine(1), e = !this._label.isArea(0) || this._label.allPositionsEqual(0, Gc.EXTERIOR), n = !this._label.isArea(1) || this._label.allPositionsEqual(1, Gc.EXTERIOR); return t && e && n } setEdgeRing(t) { this._edgeRing = t } getMinEdgeRing() { return this._minEdgeRing } getDepthDelta() { let t = this._edge.getDepthDelta(); return this._isForward || (t = -t), t } setInResult(t) { this._isInResult = t } getSym() { return this._sym } isForward() { return this._isForward } getEdge() { return this._edge } printEdge(t) { this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t) } setSym(t) { this._sym = t } setVisitedEdge(t) { this.setVisited(t), this._sym.setVisited(t) } setEdgeDepths(t, e) { let n = this.getEdge().getDepthDelta(); this._isForward || (n = -n); let i = 1; t === jc.LEFT && (i = -1); const r = jc.opposite(t), s = e + n * i; this.setDepth(t, e), this.setDepth(r, s) } getEdgeRing() { return this._edgeRing } isInResult() { return this._isInResult } setNext(t) { this._next = t } isVisited() { return this._isVisited } } class ku { createNode(t) { return new Su(t, null) } } class Gu { constructor() { Gu.constructor_.apply(this, arguments) } static constructor_() { if (this._edges = new Qh, this._nodes = null, this._edgeEndList = new Qh, 0 === arguments.length) this._nodes = new Mu(new ku); else if (1 === arguments.length) { const t = arguments[0]; this._nodes = new Mu(t) } } static linkResultDirectedEdges(t) { for (let e = t.iterator(); e.hasNext();) { e.next().getEdges().linkResultDirectedEdges() } } printEdges(t) { t.println("Edges:"); for (let e = 0; e < this._edges.size(); e++) { t.println("edge " + e + ":"); const n = this._edges.get(e); n.print(t), n.eiList.print(t) } } find(t) { return this._nodes.find(t) } addNode() { if (arguments[0] instanceof Su) { const t = arguments[0]; return this._nodes.addNode(t) } if (arguments[0] instanceof Th) { const t = arguments[0]; return this._nodes.addNode(t) } } getNodeIterator() { return this._nodes.iterator() } linkResultDirectedEdges() { for (let t = this._nodes.iterator(); t.hasNext();) { t.next().getEdges().linkResultDirectedEdges() } } debugPrintln(t) { Ec.out.println(t) } isBoundaryNode(t, e) { const n = this._nodes.find(e); if (null === n) return !1; const i = n.getLabel(); return null !== i && i.getLocation(t) === Gc.BOUNDARY } linkAllDirectedEdges() { for (let t = this._nodes.iterator(); t.hasNext();) { t.next().getEdges().linkAllDirectedEdges() } } matchInSameDirection(t, e, n, i) { return !!t.equals(n) && (sc.index(t, e, i) === sc.COLLINEAR && Du.quadrant(t, e) === Du.quadrant(n, i)) } getEdgeEnds() { return this._edgeEndList } debugPrint(t) { Ec.out.print(t) } getEdgeIterator() { return this._edges.iterator() } findEdgeInSameDirection(t, e) { for (let n = 0; n < this._edges.size(); n++) { const i = this._edges.get(n), r = i.getCoordinates(); if (this.matchInSameDirection(t, e, r[0], r[1])) return i; if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i } return null } insertEdge(t) { this._edges.add(t) } findEdgeEnd(t) { for (let e = this.getEdgeEnds().iterator(); e.hasNext();) { const n = e.next(); if (n.getEdge() === t) return n } return null } addEdges(t) { for (let e = t.iterator(); e.hasNext();) { const t = e.next(); this._edges.add(t); const n = new Fu(t, !0), i = new Fu(t, !1); n.setSym(i), i.setSym(n), this.add(n), this.add(i) } } add(t) { this._nodes.add(t), this._edgeEndList.add(t) } getNodes() { return this._nodes.values() } findEdge(t, e) { for (let n = 0; n < this._edges.size(); n++) { const i = this._edges.get(n), r = i.getCoordinates(); if (t.equals(r[0]) && e.equals(r[1])) return i } return null } } class ju { constructor() { ju.constructor_.apply(this, arguments) } static constructor_() { this._geometryFactory = null, this._shellList = new Qh; const t = arguments[0]; this._geometryFactory = t } static findEdgeRingContaining(t, e) { const n = t.getLinearRing(), i = n.getEnvelopeInternal(); let r = n.getCoordinateN(0), s = null, o = null; for (let t = e.iterator(); t.hasNext();) { const e = t.next(), a = e.getLinearRing(), l = a.getEnvelopeInternal(); if (l.equals(i)) continue; if (!l.contains(i)) continue; r = Ic.ptNotInList(n.getCoordinates(), a.getCoordinates()); let h = !1; mu.isInRing(r, a.getCoordinates()) && (h = !0), h && (null === s || o.contains(l)) && (s = e, o = s.getLinearRing().getEnvelopeInternal()) } return s } sortShellsAndHoles(t, e, n) { for (let i = t.iterator(); i.hasNext();) { const t = i.next(); t.isHole() ? n.add(t) : e.add(t) } } computePolygons(t) { const e = new Qh; for (let n = t.iterator(); n.hasNext();) { const t = n.next().toPolygon(this._geometryFactory); e.add(t) } return e } placeFreeHoles(t, e) { for (let n = e.iterator(); n.hasNext();) { const e = n.next(); if (null === e.getShell()) { const n = ju.findEdgeRingContaining(e, t); if (null === n) throw new Xc("unable to assign hole to a shell", e.getCoordinate(0)); e.setShell(n) } } } buildMinimalEdgeRings(t, e, n) { const i = new Qh; for (let r = t.iterator(); r.hasNext();) { const t = r.next(); if (t.getMaxNodeDegree() > 2) { t.linkDirectedEdgesForMinimalEdgeRings(); const i = t.buildMinimalRings(), r = this.findShell(i); null !== r ? (this.placePolygonHoles(r, i), e.add(r)) : n.addAll(i) } else i.add(t) } return i } buildMaximalEdgeRings(t) { const e = new Qh; for (let n = t.iterator(); n.hasNext();) { const t = n.next(); if (t.isInResult() && t.getLabel().isArea() && null === t.getEdgeRing()) { const n = new Cu(t, this._geometryFactory); e.add(n), n.setInResult() } } return e } placePolygonHoles(t, e) { for (let n = e.iterator(); n.hasNext();) { const e = n.next(); e.isHole() && e.setShell(t) } } getPolygons() { return this.computePolygons(this._shellList) } findShell(t) { let e = 0, n = null; for (let i = t.iterator(); i.hasNext();) { const t = i.next(); t.isHole() || (n = t, e++) } return wh.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n } add() { if (1 === arguments.length) { const t = arguments[0]; this.add(t.getEdgeEnds(), t.getNodes()) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; Gu.linkResultDirectedEdges(e); const n = this.buildMaximalEdgeRings(t), i = new Qh, r = this.buildMinimalEdgeRings(n, this._shellList, i); this.sortShellsAndHoles(r, this._shellList, i), this.placeFreeHoles(this._shellList, i) } } } class Bu { getBounds() { } } class Yu { constructor() { Yu.constructor_.apply(this, arguments) } static constructor_() { this._bounds = null, this._item = null; const t = arguments[0], e = arguments[1]; this._bounds = t, this._item = e } getItem() { return this._item } getBounds() { return this._bounds } get interfaces_() { return [Bu, Eh] } } class qu { constructor() { qu.constructor_.apply(this, arguments) } static constructor_() { this._size = null, this._items = null, this._size = 0, this._items = new Qh, this._items.add(null) } poll() { if (this.isEmpty()) return null; const t = this._items.get(1); return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t } size() { return this._size } reorder(t) { let e = null; const n = this._items.get(t); for (; 2 * t <= this._size && (e = 2 * t, e !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e)this._items.set(t, this._items.get(e)); this._items.set(t, n) } clear() { this._size = 0, this._items.clear() } peek() { if (this.isEmpty()) return null; return this._items.get(1) } isEmpty() { return 0 === this._size } add(t) { this._items.add(null), this._size += 1; let e = this._size; for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2)this._items.set(e, this._items.get(Math.trunc(e / 2))); this._items.set(e, t) } } class Xu { insert(t, e) { } remove(t, e) { } query() { if (1 === arguments.length) { } else if (2 === arguments.length) { } } } class zu { constructor() { zu.constructor_.apply(this, arguments) } static constructor_() { if (this._childBoundables = new Qh, this._bounds = null, this._level = null, 0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; this._level = t } } getLevel() { return this._level } size() { return this._childBoundables.size() } getChildBoundables() { return this._childBoundables } addChildBoundable(t) { wh.isTrue(null === this._bounds), this._childBoundables.add(t) } isEmpty() { return this._childBoundables.isEmpty() } getBounds() { return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds } get interfaces_() { return [Bu, Eh] } } const Uu = { reverseOrder: function () { return { compare: (t, e) => e.compareTo(t) } }, min: function (t) { return Uu.sort(t), t.get(0) }, sort: function (t, e) { const n = t.toArray(); e ? tc.sort(n, e) : tc.sort(n); const i = t.iterator(); for (let t = 0, e = n.length; t < e; t++)i.next(), i.set(n[t]) }, singletonList: function (t) { const e = new Qh; return e.add(t), e } }; var Vu = Uu; class Wu { static maxDistance(t, e, n, i, r, s, o, a) { let l = Wu.distance(t, e, r, s); return l = Math.max(l, Wu.distance(t, e, o, a)), l = Math.max(l, Wu.distance(n, i, r, s)), l = Math.max(l, Wu.distance(n, i, o, a)), l } static distance(t, e, n, i) { const r = n - t, s = i - e; return Math.sqrt(r * r + s * s) } static maximumDistance(t, e) { const n = Math.min(t.getMinX(), e.getMinX()), i = Math.min(t.getMinY(), e.getMinY()), r = Math.max(t.getMaxX(), e.getMaxX()), s = Math.max(t.getMaxY(), e.getMaxY()); return Wu.distance(n, i, r, s) } static minMaxDistance(t, e) { const n = t.getMinX(), i = t.getMinY(), r = t.getMaxX(), s = t.getMaxY(), o = e.getMinX(), a = e.getMinY(), l = e.getMaxX(), h = e.getMaxY(); let c = Wu.maxDistance(n, i, n, s, o, a, o, h); return c = Math.min(c, Wu.maxDistance(n, i, n, s, o, a, l, a)), c = Math.min(c, Wu.maxDistance(n, i, n, s, l, h, o, h)), c = Math.min(c, Wu.maxDistance(n, i, n, s, l, h, l, a)), c = Math.min(c, Wu.maxDistance(n, i, r, i, o, a, o, h)), c = Math.min(c, Wu.maxDistance(n, i, r, i, o, a, l, a)), c = Math.min(c, Wu.maxDistance(n, i, r, i, l, h, o, h)), c = Math.min(c, Wu.maxDistance(n, i, r, i, l, h, l, a)), c = Math.min(c, Wu.maxDistance(r, s, n, s, o, a, o, h)), c = Math.min(c, Wu.maxDistance(r, s, n, s, o, a, l, a)), c = Math.min(c, Wu.maxDistance(r, s, n, s, l, h, o, h)), c = Math.min(c, Wu.maxDistance(r, s, n, s, l, h, l, a)), c = Math.min(c, Wu.maxDistance(r, s, r, i, o, a, o, h)), c = Math.min(c, Wu.maxDistance(r, s, r, i, o, a, l, a)), c = Math.min(c, Wu.maxDistance(r, s, r, i, l, h, o, h)), c = Math.min(c, Wu.maxDistance(r, s, r, i, l, h, l, a)), c } } class Hu { constructor() { Hu.constructor_.apply(this, arguments) } static constructor_() { this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null; const t = arguments[0], e = arguments[1], n = arguments[2]; this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance() } static area(t) { return t.getBounds().getArea() } static isComposite(t) { return t instanceof zu } maximumDistance() { return Wu.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds()) } expandToQueue(t, e) { const n = Hu.isComposite(this._boundable1), i = Hu.isComposite(this._boundable2); if (n && i) return Hu.area(this._boundable1) > Hu.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, t, e), null) : (this.expand(this._boundable2, this._boundable1, !0, t, e), null); if (n) return this.expand(this._boundable1, this._boundable2, !1, t, e), null; if (i) return this.expand(this._boundable2, this._boundable1, !0, t, e), null; throw new gh("neither boundable is composite") } isLeaves() { return !(Hu.isComposite(this._boundable1) || Hu.isComposite(this._boundable2)) } compareTo(t) { const e = t; return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0 } expand(t, e, n, i, r) { for (let s = t.getChildBoundables().iterator(); s.hasNext();) { const t = s.next(); let o = null; o = n ? new Hu(e, t, this._itemDistance) : new Hu(t, e, this._itemDistance), o.getDistance() < r && i.add(o) } } getBoundable(t) { return 0 === t ? this._boundable1 : this._boundable2 } getDistance() { return this._distance } distance() { return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds()) } get interfaces_() { return [mh] } } class Ku { visitItem(t) { } } class Zu { constructor() { Zu.constructor_.apply(this, arguments) } static constructor_() { if (this._root = null, this._built = !1, this._itemBoundables = new Qh, this._nodeCapacity = null, 0 === arguments.length) Zu.constructor_.call(this, Zu.DEFAULT_NODE_CAPACITY); else if (1 === arguments.length) { const t = arguments[0]; wh.isTrue(t > 1, "Node capacity must be greater than 1"), this._nodeCapacity = t } } static compareDoubles(t, e) { return t > e ? 1 : t < e ? -1 : 0 } queryInternal() { if (Nh(arguments[2], Ku) && arguments[0] instanceof Object && arguments[1] instanceof zu) { const t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(); for (let i = 0; i < n.size(); i++) { const r = n.get(i); this.getIntersectsOp().intersects(r.getBounds(), t) && (r instanceof zu ? this.queryInternal(t, r, e) : r instanceof Yu ? e.visitItem(r.getItem()) : wh.shouldNeverReachHere()) } } else if (Nh(arguments[2], Zh) && arguments[0] instanceof Object && arguments[1] instanceof zu) { const t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(); for (let i = 0; i < n.size(); i++) { const r = n.get(i); this.getIntersectsOp().intersects(r.getBounds(), t) && (r instanceof zu ? this.queryInternal(t, r, e) : r instanceof Yu ? e.add(r.getItem()) : wh.shouldNeverReachHere()) } } } getNodeCapacity() { return this._nodeCapacity } lastNode(t) { return t.get(t.size() - 1) } size() { if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root)); if (1 === arguments.length) { let t = 0; for (let e = arguments[0].getChildBoundables().iterator(); e.hasNext();) { const n = e.next(); n instanceof zu ? t += this.size(n) : n instanceof Yu && (t += 1) } return t } } removeItem(t, e) { let n = null; for (let i = t.getChildBoundables().iterator(); i.hasNext();) { const t = i.next(); t instanceof Yu && t.getItem() === e && (n = t) } return null !== n && (t.getChildBoundables().remove(n), !0) } itemsTree() { if (0 === arguments.length) { this.build(); const t = this.itemsTree(this._root); return null === t ? new Qh : t } if (1 === arguments.length) { const t = arguments[0], e = new Qh; for (let n = t.getChildBoundables().iterator(); n.hasNext();) { const t = n.next(); if (t instanceof zu) { const n = this.itemsTree(t); null !== n && e.add(n) } else t instanceof Yu ? e.add(t.getItem()) : wh.shouldNeverReachHere() } return e.size() <= 0 ? null : e } } insert(t, e) { wh.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Yu(t, e)) } boundablesAtLevel() { if (1 === arguments.length) { const t = arguments[0], e = new Qh; return this.boundablesAtLevel(t, this._root, e), e } if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; if (wh.isTrue(t > -2), e.getLevel() === t) return n.add(e), null; for (let i = e.getChildBoundables().iterator(); i.hasNext();) { const e = i.next(); e instanceof zu ? this.boundablesAtLevel(t, e, n) : (wh.isTrue(e instanceof Yu), -1 === t && n.add(e)) } return null } } query() { if (1 === arguments.length) { const t = arguments[0]; this.build(); const e = new Qh; return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e), e } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; if (this.build(), this.isEmpty()) return null; this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e) } } build() { if (this._built) return null; this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0 } getRoot() { return this.build(), this._root } remove() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e) } if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; let i = this.removeItem(e, n); if (i) return !0; let r = null; for (let s = e.getChildBoundables().iterator(); s.hasNext();) { const e = s.next(); if (this.getIntersectsOp().intersects(e.getBounds(), t) && (e instanceof zu && (i = this.remove(t, e, n), i))) { r = e; break } } return null !== r && r.getChildBoundables().isEmpty() && e.getChildBoundables().remove(r), i } } createHigherLevels(t, e) { wh.isTrue(!t.isEmpty()); const n = this.createParentBoundables(t, e + 1); return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1) } depth() { if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root)); if (1 === arguments.length) { let t = 0; for (let e = arguments[0].getChildBoundables().iterator(); e.hasNext();) { const n = e.next(); if (n instanceof zu) { const e = this.depth(n); e > t && (t = e) } } return t + 1 } } createParentBoundables(t, e) { wh.isTrue(!t.isEmpty()); const n = new Qh; n.add(this.createNode(e)); const i = new Qh(t); Vu.sort(i, this.getComparator()); for (let t = i.iterator(); t.hasNext();) { const i = t.next(); this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(i) } return n } isEmpty() { return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty() } get interfaces_() { return [Eh] } } Zu.IntersectsOp = function () { }, Zu.DEFAULT_NODE_CAPACITY = 10; class Ju { distance(t, e) { } } class Qu extends Zu { constructor() { super(), Qu.constructor_.apply(this, arguments) } static constructor_() { if (0 === arguments.length) Qu.constructor_.call(this, Qu.DEFAULT_NODE_CAPACITY); else if (1 === arguments.length) { const t = arguments[0]; Zu.constructor_.call(this, t) } } static centreX(t) { return Qu.avg(t.getMinX(), t.getMaxX()) } static avg(t, e) { return (t + e) / 2 } static getItems(t) { const e = new Array(t.size()).fill(null); let n = 0; for (; !t.isEmpty();) { const i = t.poll(); e[n] = i.getBoundable(0).getItem(), n++ } return e } static centreY(t) { return Qu.avg(t.getMinY(), t.getMaxY()) } createParentBoundablesFromVerticalSlices(t, e) { wh.isTrue(t.length > 0); const n = new Qh; for (let i = 0; i < t.length; i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e)); return n } nearestNeighbourK() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return this.nearestNeighbourK(t, yh.POSITIVE_INFINITY, e) } if (3 === arguments.length) { const t = arguments[0], e = arguments[2]; let n = arguments[1]; const i = new qu; i.add(t); const r = new qu; for (; !i.isEmpty() && n >= 0;) { const t = i.poll(), s = t.getDistance(); if (s >= n) break; if (t.isLeaves()) if (r.size() < e) r.add(t); else { r.peek().getDistance() > s && (r.poll(), r.add(t)); n = r.peek().getDistance() } else t.expandToQueue(i, n) } return Qu.getItems(r) } } createNode(t) { return new $u(t) } size() { return 0 === arguments.length ? super.size.call(this) : super.size.apply(this, arguments) } insert() { if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof Dh)) return super.insert.apply(this, arguments); { const t = arguments[0], e = arguments[1]; if (t.isNull()) return null; super.insert.call(this, t, e) } } getIntersectsOp() { return Qu.intersectsOp } verticalSlices(t, e) { const n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(); for (let t = 0; t < e; t++) { i[t] = new Qh; let e = 0; for (; r.hasNext() && e < n;) { const n = r.next(); i[t].add(n), e++ } } return i } query() { if (1 === arguments.length) { const t = arguments[0]; return super.query.call(this, t) } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; super.query.call(this, t, e) } } getComparator() { return Qu.yComparator } createParentBoundablesFromVerticalSlice(t, e) { return super.createParentBoundables.call(this, t, e) } remove() { if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof Dh) { const t = arguments[0], e = arguments[1]; return super.remove.call(this, t, e) } return super.remove.apply(this, arguments) } depth() { return 0 === arguments.length ? super.depth.call(this) : super.depth.apply(this, arguments) } createParentBoundables(t, e) { wh.isTrue(!t.isEmpty()); const n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())), i = new Qh(t); Vu.sort(i, Qu.xComparator); const r = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(n)))); return this.createParentBoundablesFromVerticalSlices(r, e) } nearestNeighbour() { if (1 === arguments.length) { if (Nh(arguments[0], Ju)) { const t = arguments[0]; if (this.isEmpty()) return null; const e = new Hu(this.getRoot(), this.getRoot(), t); return this.nearestNeighbour(e) } if (arguments[0] instanceof Hu) { const t = arguments[0]; let e = yh.POSITIVE_INFINITY, n = null; const i = new qu; for (i.add(t); !i.isEmpty() && e > 0;) { const t = i.poll(), r = t.getDistance(); if (r >= e) break; t.isLeaves() ? (e = r, n = t) : t.expandToQueue(i, e) } return null === n ? null : [n.getBoundable(0).getItem(), n.getBoundable(1).getItem()] } } else { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; if (this.isEmpty() || t.isEmpty()) return null; const n = new Hu(this.getRoot(), t.getRoot(), e); return this.nearestNeighbour(n) } if (3 === arguments.length) { const t = arguments[2], e = new Yu(arguments[0], arguments[1]), n = new Hu(this.getRoot(), e, t); return this.nearestNeighbour(n)[0] } if (4 === arguments.length) { const t = arguments[2], e = arguments[3], n = new Yu(arguments[0], arguments[1]), i = new Hu(this.getRoot(), n, t); return this.nearestNeighbourK(i, e) } } } isWithinDistance() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; let n = yh.POSITIVE_INFINITY; const i = new qu; for (i.add(t); !i.isEmpty();) { const t = i.poll(), r = t.getDistance(); if (r > e) return !1; if (t.maximumDistance() <= e) return !0; if (t.isLeaves()) { if (n = r, n <= e) return !0 } else t.expandToQueue(i, n) } return !1 } if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = new Hu(this.getRoot(), t.getRoot(), e); return this.isWithinDistance(i, n) } } get interfaces_() { return [Xu, Eh] } } class $u extends zu { constructor() { super(), $u.constructor_.apply(this, arguments) } static constructor_() { const t = arguments[0]; zu.constructor_.call(this, t) } computeBounds() { let t = null; for (let e = this.getChildBoundables().iterator(); e.hasNext();) { const n = e.next(); null === t ? t = new Dh(n.getBounds()) : t.expandToInclude(n.getBounds()) } return t } } Qu.STRtreeNode = $u, Qu.xComparator = new class { get interfaces_() { return [xh] } compare(t, e) { return Zu.compareDoubles(Qu.centreX(t.getBounds()), Qu.centreX(e.getBounds())) } }, Qu.yComparator = new class { get interfaces_() { return [xh] } compare(t, e) { return Zu.compareDoubles(Qu.centreY(t.getBounds()), Qu.centreY(e.getBounds())) } }, Qu.intersectsOp = new class { get interfaces_() { return [IntersectsOp] } intersects(t, e) { return t.intersects(e) } }, Qu.DEFAULT_NODE_CAPACITY = 10; class tf { static relativeSign(t, e) { return t < e ? -1 : t > e ? 1 : 0 } static compare(t, e, n) { if (e.equals2D(n)) return 0; const i = tf.relativeSign(e.x, n.x), r = tf.relativeSign(e.y, n.y); switch (t) { case 0: return tf.compareValue(i, r); case 1: return tf.compareValue(r, i); case 2: return tf.compareValue(r, -i); case 3: return tf.compareValue(-i, r); case 4: return tf.compareValue(-i, -r); case 5: return tf.compareValue(-r, -i); case 6: return tf.compareValue(-r, i); case 7: return tf.compareValue(i, -r) }return wh.shouldNeverReachHere("invalid octant value"), 0 } static compareValue(t, e) { return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0 } } class ef { constructor() { ef.constructor_.apply(this, arguments) } static constructor_() { this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null; const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; this._segString = t, this.coord = new Th(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n)) } getCoordinate() { return this.coord } print(t) { t.print(this.coord), t.print(" seg # = " + this.segmentIndex) } compareTo(t) { const e = t; return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? tf.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1 } isEndPoint(t) { return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t } toString() { return this.segmentIndex + ":" + this.coord.toString() } isInterior() { return this._isInterior } get interfaces_() { return [mh] } } class nf { hasNext() { } next() { } remove() { } } class rf { constructor() { rf.constructor_.apply(this, arguments) } static constructor_() { this._nodeMap = new Pu, this._edge = null; const t = arguments[0]; this._edge = t } getSplitCoordinates() { const t = new vc; this.addEndpoints(); const e = this.iterator(); let n = e.next(); for (; e.hasNext();) { const i = e.next(); this.addEdgeCoordinates(n, i, t), n = i } return t.toCoordinateArray() } addCollapsedNodes() { const t = new Qh; this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t); for (let e = t.iterator(); e.hasNext();) { const t = e.next().intValue(); this.add(this._edge.getCoordinate(t), t) } } createSplitEdgePts(t, e) { let n = e.segmentIndex - t.segmentIndex + 2; if (2 === n) return [new Th(t.coord), new Th(e.coord)]; const i = this._edge.getCoordinate(e.segmentIndex), r = e.isInterior() || !e.coord.equals2D(i); r || n--; const s = new Array(n).fill(null); let o = 0; s[o++] = new Th(t.coord); for (let n = t.segmentIndex + 1; n <= e.segmentIndex; n++)s[o++] = this._edge.getCoordinate(n); return r && (s[o] = new Th(e.coord)), s } print(t) { t.println("Intersections:"); for (let e = this.iterator(); e.hasNext();) { e.next().print(t) } } findCollapsesFromExistingVertices(t) { for (let e = 0; e < this._edge.size() - 2; e++) { const n = this._edge.getCoordinate(e), i = (this._edge.getCoordinate(e + 1), this._edge.getCoordinate(e + 2)); n.equals2D(i) && t.add(nc.valueOf(e + 1)) } } addEdgeCoordinates(t, e, n) { const i = this.createSplitEdgePts(t, e); n.add(i, !1) } iterator() { return this._nodeMap.values().iterator() } addSplitEdges(t) { this.addEndpoints(), this.addCollapsedNodes(); const e = this.iterator(); let n = e.next(); for (; e.hasNext();) { const i = e.next(), r = this.createSplitEdge(n, i); t.add(r), n = i } } findCollapseIndex(t, e, n) { if (!t.coord.equals2D(e.coord)) return !1; let i = e.segmentIndex - t.segmentIndex; return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0) } findCollapsesFromInsertedNodes(t) { const e = new Array(1).fill(null), n = this.iterator(); let i = n.next(); for (; n.hasNext();) { const r = n.next(); this.findCollapseIndex(i, r, e) && t.add(nc.valueOf(e[0])), i = r } } getEdge() { return this._edge } addEndpoints() { const t = this._edge.size() - 1; this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t) } createSplitEdge(t, e) { const n = this.createSplitEdgePts(t, e); return new lf(n, this._edge.getData()) } add(t, e) { const n = new ef(this._edge, t, e, this._edge.getSegmentOctant(e)), i = this._nodeMap.get(n); return null !== i ? (wh.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this._nodeMap.put(n, n), n) } checkSplitEdgesCorrectness(t) { const e = this._edge.getCoordinates(), n = t.get(0).getCoordinate(0); if (!n.equals2D(e[0])) throw new Ih("bad split edge start point at " + n); const i = t.get(t.size() - 1).getCoordinates(), r = i[i.length - 1]; if (!r.equals2D(e[e.length - 1])) throw new Ih("bad split edge end point at " + r) } } class sf { static octant() { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; if (0 === t && 0 === e) throw new gh("Cannot compute the octant for point ( " + t + ", " + e + " )"); const n = Math.abs(t), i = Math.abs(e); return t >= 0 ? e >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : e >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5 } if (arguments[0] instanceof Th && arguments[1] instanceof Th) { const t = arguments[0], e = arguments[1], n = e.x - t.x, i = e.y - t.y; if (0 === n && 0 === i) throw new gh("Cannot compute the octant for two identical points " + t); return sf.octant(n, i) } } } class of { getCoordinates() { } size() { } getCoordinate(t) { } isClosed() { } setData(t) { } getData() { } } class af { addIntersection(t, e) { } get interfaces_() { return [of] } } class lf { constructor() { lf.constructor_.apply(this, arguments) } static constructor_() { this._nodeList = new rf(this), this._pts = null, this._data = null; const t = arguments[0], e = arguments[1]; this._pts = t, this._data = e } static getNodedSubstrings() { if (1 === arguments.length) { const t = arguments[0], e = new Qh; return lf.getNodedSubstrings(t, e), e } if (2 === arguments.length) { const t = arguments[1]; for (let e = arguments[0].iterator(); e.hasNext();) { e.next().getNodeList().addSplitEdges(t) } } } getCoordinates() { return this._pts } size() { return this._pts.length } getCoordinate(t) { return this._pts[t] } isClosed() { return this._pts[0].equals(this._pts[this._pts.length - 1]) } getSegmentOctant(t) { return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1)) } setData(t) { this._data = t } safeOctant(t, e) { return t.equals2D(e) ? 0 : sf.octant(t, e) } getData() { return this._data } addIntersection() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.addIntersectionNode(t, e) } else if (4 === arguments.length) { const t = arguments[1], e = arguments[3], n = new Th(arguments[0].getIntersection(e)); this.addIntersection(n, t) } } toString() { return du.toLineString(new wc(this._pts)) } getNodeList() { return this._nodeList } addIntersectionNode(t, e) { let n = e; const i = n + 1; if (i < this._pts.length) { const e = this._pts[i]; t.equals2D(e) && (n = i) } return this._nodeList.add(t, n) } addIntersections(t, e, n) { for (let i = 0; i < t.getIntersectionNum(); i++)this.addIntersection(t, e, n, i) } get interfaces_() { return [af] } } class hf { constructor() { hf.constructor_.apply(this, arguments) } static constructor_() { if (this.p0 = null, this.p1 = null, 0 === arguments.length) hf.constructor_.call(this, new Th, new Th); else if (1 === arguments.length) { const t = arguments[0]; hf.constructor_.call(this, t.p0, t.p1) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.p0 = t, this.p1 = e } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; hf.constructor_.call(this, new Th(t, e), new Th(n, i)) } } static midPoint(t, e) { return new Th((t.x + e.x) / 2, (t.y + e.y) / 2) } minX() { return Math.min(this.p0.x, this.p1.x) } orientationIndex() { if (arguments[0] instanceof hf) { const t = arguments[0], e = sc.index(this.p0, this.p1, t.p0), n = sc.index(this.p0, this.p1, t.p1); return e >= 0 && n >= 0 || e <= 0 && n <= 0 ? Math.max(e, n) : 0 } if (arguments[0] instanceof Th) { const t = arguments[0]; return sc.index(this.p0, this.p1, t) } } toGeometry(t) { return t.createLineString([this.p0, this.p1]) } isVertical() { return this.p0.x === this.p1.x } equals(t) { if (!(t instanceof hf)) return !1; const e = t; return this.p0.equals(e.p0) && this.p1.equals(e.p1) } intersection(t) { const e = new _u; return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null } project() { if (arguments[0] instanceof Th) { const t = arguments[0]; if (t.equals(this.p0) || t.equals(this.p1)) return new Th(t); const e = this.projectionFactor(t), n = new Th; return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n } if (arguments[0] instanceof hf) { const t = arguments[0], e = this.projectionFactor(t.p0), n = this.projectionFactor(t.p1); if (e >= 1 && n >= 1) return null; if (e <= 0 && n <= 0) return null; let i = this.project(t.p0); e < 0 && (i = this.p0), e > 1 && (i = this.p1); let r = this.project(t.p1); return n < 0 && (r = this.p0), n > 1 && (r = this.p1), new hf(i, r) } } normalize() { this.p1.compareTo(this.p0) < 0 && this.reverse() } angle() { return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x) } getCoordinate(t) { return 0 === t ? this.p0 : this.p1 } distancePerpendicular(t) { return Wc.pointToLinePerpendicular(t, this.p0, this.p1) } minY() { return Math.min(this.p0.y, this.p1.y) } midPoint() { return hf.midPoint(this.p0, this.p1) } projectionFactor(t) { if (t.equals(this.p0)) return 0; if (t.equals(this.p1)) return 1; const e = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, i = e * e + n * n; if (i <= 0) return yh.NaN; return ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i } closestPoints(t) { const e = this.intersection(t); if (null !== e) return [e, e]; const n = new Array(2).fill(null); let i = yh.MAX_VALUE, r = null; const s = this.closestPoint(t.p0); i = s.distance(t.p0), n[0] = s, n[1] = t.p0; const o = this.closestPoint(t.p1); r = o.distance(t.p1), r < i && (i = r, n[0] = o, n[1] = t.p1); const a = t.closestPoint(this.p0); r = a.distance(this.p0), r < i && (i = r, n[0] = this.p0, n[1] = a); const l = t.closestPoint(this.p1); return r = l.distance(this.p1), r < i && (i = r, n[0] = this.p1, n[1] = l), n } closestPoint(t) { const e = this.projectionFactor(t); if (e > 0 && e < 1) return this.project(t); return this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1 } maxX() { return Math.max(this.p0.x, this.p1.x) } getLength() { return this.p0.distance(this.p1) } compareTo(t) { const e = t, n = this.p0.compareTo(e.p0); return 0 !== n ? n : this.p1.compareTo(e.p1) } reverse() { const t = this.p0; this.p0 = this.p1, this.p1 = t } equalsTopo(t) { return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0) } lineIntersection(t) { return Vc.intersection(this.p0, this.p1, t.p0, t.p1) } maxY() { return Math.max(this.p0.y, this.p1.y) } pointAlongOffset(t, e) { const n = this.p0.x + t * (this.p1.x - this.p0.x), i = this.p0.y + t * (this.p1.y - this.p0.y), r = this.p1.x - this.p0.x, s = this.p1.y - this.p0.y, o = Math.sqrt(r * r + s * s); let a = 0, l = 0; if (0 !== e) { if (o <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment"); a = e * r / o, l = e * s / o } return new Th(n - l, i + a) } setCoordinates() { if (1 === arguments.length) { const t = arguments[0]; this.setCoordinates(t.p0, t.p1) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.p0.x = t.x, this.p0.y = t.y, this.p1.x = e.x, this.p1.y = e.y } } segmentFraction(t) { let e = this.projectionFactor(t); return e < 0 ? e = 0 : (e > 1 || yh.isNaN(e)) && (e = 1), e } toString() { return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")" } isHorizontal() { return this.p0.y === this.p1.y } reflect(t) { const e = this.p1.getY() - this.p0.getY(), n = this.p0.getX() - this.p1.getX(), i = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), r = e * e + n * n, s = e * e - n * n, o = t.getX(), a = t.getY(); return new Th((-s * o - 2 * e * n * a - 2 * e * i) / r, (s * a - 2 * e * n * o - 2 * n * i) / r) } distance() { if (arguments[0] instanceof hf) { const t = arguments[0]; return Wc.segmentToSegment(this.p0, this.p1, t.p0, t.p1) } if (arguments[0] instanceof Th) { const t = arguments[0]; return Wc.pointToSegment(t, this.p0, this.p1) } } pointAlong(t) { const e = new Th; return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e } hashCode() { let t = yh.doubleToLongBits(this.p0.x); t ^= 31 * yh.doubleToLongBits(this.p0.y); const e = Math.trunc(t) ^ Math.trunc(t >> 32); let n = yh.doubleToLongBits(this.p1.x); n ^= 31 * yh.doubleToLongBits(this.p1.y); return e ^ (Math.trunc(n) ^ Math.trunc(n >> 32)) } get interfaces_() { return [mh, Eh] } } class cf { constructor() { cf.constructor_.apply(this, arguments) } static constructor_() { this._overlapSeg1 = new hf, this._overlapSeg2 = new hf } overlap() { if (2 === arguments.length) { } else if (4 === arguments.length) { const t = arguments[1], e = arguments[2], n = arguments[3]; arguments[0].getLineSegment(t, this._overlapSeg1), e.getLineSegment(n, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2) } } } class uf { constructor() { uf.constructor_.apply(this, arguments) } static constructor_() { this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null; const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; this._pts = t, this._start = e, this._end = n, this._context = i } getLineSegment(t, e) { e.p0 = this._pts[t], e.p1 = this._pts[t + 1] } computeSelect(t, e, n, i) { const r = this._pts[e], s = this._pts[n]; if (n - e == 1) return i.select(this, e), null; if (!t.intersects(r, s)) return null; const o = Math.trunc((e + n) / 2); e < o && this.computeSelect(t, e, o, i), o < n && this.computeSelect(t, o, n, i) } getCoordinates() { const t = new Array(this._end - this._start + 1).fill(null); let e = 0; for (let n = this._start; n <= this._end; n++)t[e++] = this._pts[n]; return t } computeOverlaps() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.computeOverlaps(this._start, this._end, t, t._start, t._end, e) } else if (6 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3], r = arguments[4], s = arguments[5]; if (e - t == 1 && r - i == 1) return s.overlap(this, t, n, i), null; if (!this.overlaps(t, e, n, i, r)) return null; const o = Math.trunc((t + e) / 2), a = Math.trunc((i + r) / 2); t < o && (i < a && this.computeOverlaps(t, o, n, i, a, s), a < r && this.computeOverlaps(t, o, n, a, r, s)), o < e && (i < a && this.computeOverlaps(o, e, n, i, a, s), a < r && this.computeOverlaps(o, e, n, a, r, s)) } } setId(t) { this._id = t } select(t, e) { this.computeSelect(t, this._start, this._end, e) } getEnvelope() { if (null === this._env) { const t = this._pts[this._start], e = this._pts[this._end]; this._env = new Dh(t, e) } return this._env } overlaps(t, e, n, i, r) { return Dh.intersects(this._pts[t], this._pts[e], n._pts[i], n._pts[r]) } getEndIndex() { return this._end } getStartIndex() { return this._start } getContext() { return this._context } getId() { return this._id } } class ff { static findChainEnd(t, e) { let n = e; for (; n < t.length - 1 && t[n].equals2D(t[n + 1]);)n++; if (n >= t.length - 1) return t.length - 1; const i = Du.quadrant(t[n], t[n + 1]); let r = e + 1; for (; r < t.length;) { if (!t[r - 1].equals2D(t[r])) { if (Du.quadrant(t[r - 1], t[r]) !== i) break } r++ } return r - 1 } static getChains() { if (1 === arguments.length) { const t = arguments[0]; return ff.getChains(t, null) } if (2 === arguments.length) { const t = arguments[0], e = arguments[1], n = new Qh; let i = 0; do { const r = ff.findChainEnd(t, i), s = new uf(t, i, r, e); n.add(s), i = r } while (i < t.length - 1); return n } } } class pf { computeNodes(t) { } getNodedSubstrings() { } } class df { constructor() { df.constructor_.apply(this, arguments) } static constructor_() { if (this._segInt = null, 0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; this.setSegmentIntersector(t) } } setSegmentIntersector(t) { this._segInt = t } get interfaces_() { return [pf] } } class gf extends df { constructor() { super(), gf.constructor_.apply(this, arguments) } static constructor_() { if (this._monoChains = new Qh, this._index = new Qu, this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; df.constructor_.call(this, t) } } getMonotoneChains() { return this._monoChains } getNodedSubstrings() { return lf.getNodedSubstrings(this._nodedSegStrings) } getIndex() { return this._index } add(t) { for (let e = ff.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) { const t = e.next(); t.setId(this._idCounter++), this._index.insert(t.getEnvelope(), t), this._monoChains.add(t) } } computeNodes(t) { this._nodedSegStrings = t; for (let e = t.iterator(); e.hasNext();)this.add(e.next()); this.intersectChains() } intersectChains() { const t = new _f(this._segInt); for (let e = this._monoChains.iterator(); e.hasNext();) { const n = e.next(); for (let e = this._index.query(n.getEnvelope()).iterator(); e.hasNext();) { const i = e.next(); if (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++), this._segInt.isDone()) return null } } } } class _f extends cf { constructor() { super(), _f.constructor_.apply(this, arguments) } static constructor_() { this._si = null; const t = arguments[0]; this._si = t } overlap() { if (4 !== arguments.length) return super.overlap.apply(this, arguments); { const t = arguments[1], e = arguments[2], n = arguments[3], i = arguments[0].getContext(), r = e.getContext(); this._si.processIntersections(i, t, r, n) } } } gf.SegmentOverlapAction = _f; class yf { constructor() { yf.constructor_.apply(this, arguments) } static constructor_() { this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = sc.COUNTERCLOCKWISE; const t = arguments[0]; this._inputLine = t } static simplify(t, e) { return new yf(t).simplify(e) } isDeletable(t, e, n, i) { const r = this._inputLine[t], s = this._inputLine[e], o = this._inputLine[n]; return !!this.isConcave(r, s, o) && (!!this.isShallow(r, s, o, i) && this.isShallowSampled(r, s, t, n, i)) } deleteShallowConcavities() { let t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), i = !1; for (; n < this._inputLine.length;) { let r = !1; this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = yf.DELETE, r = !0, i = !0), t = r ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e) } return i } isShallowConcavity(t, e, n, i) { if (!(sc.index(t, e, n) === this._angleOrientation)) return !1; return Wc.pointToSegment(e, t, n) < i } isShallowSampled(t, e, n, i, r) { let s = Math.trunc((i - n) / yf.NUM_PTS_TO_CHECK); s <= 0 && (s = 1); for (let o = n; o < i; o += s)if (!this.isShallow(t, e, this._inputLine[o], r)) return !1; return !0 } isConcave(t, e, n) { return sc.index(t, e, n) === this._angleOrientation } simplify(t) { this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = sc.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null); let e = !1; do { e = this.deleteShallowConcavities() } while (e); return this.collapseLine() } findNextNonDeletedIndex(t) { let e = t + 1; for (; e < this._inputLine.length && this._isDeleted[e] === yf.DELETE;)e++; return e } isShallow(t, e, n, i) { return Wc.pointToSegment(e, t, n) < i } collapseLine() { const t = new vc; for (let e = 0; e < this._inputLine.length; e++)this._isDeleted[e] !== yf.DELETE && t.add(this._inputLine[e]); return t.toCoordinateArray() } } yf.INIT = 0, yf.DELETE = 1, yf.KEEP = 1, yf.NUM_PTS_TO_CHECK = 10; class mf { constructor() { mf.constructor_.apply(this, arguments) } static constructor_() { this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Qh } getCoordinates() { return this._ptList.toArray(mf.COORDINATE_ARRAY_TYPE) } setPrecisionModel(t) { this._precisionModel = t } addPt(t) { const e = new Th(t); if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null; this._ptList.add(e) } reverse() { } addPts(t, e) { if (e) for (let e = 0; e < t.length; e++)this.addPt(t[e]); else for (let e = t.length - 1; e >= 0; e--)this.addPt(t[e]) } isRedundant(t) { if (this._ptList.size() < 1) return !1; const e = this._ptList.get(this._ptList.size() - 1); return t.distance(e) < this._minimimVertexDistance } toString() { return (new Dc).createLineString(this.getCoordinates()).toString() } closeRing() { if (this._ptList.size() < 1) return null; const t = new Th(this._ptList.get(0)), e = this._ptList.get(this._ptList.size() - 1); if (t.equals(e)) return null; this._ptList.add(t) } setMinimumVertexDistance(t) { this._minimimVertexDistance = t } } mf.COORDINATE_ARRAY_TYPE = new Array(0).fill(null); class vf { static toDegrees(t) { return 180 * t / Math.PI } static normalize(t) { for (; t > Math.PI;)t -= vf.PI_TIMES_2; for (; t <= -Math.PI;)t += vf.PI_TIMES_2; return t } static angle() { if (1 === arguments.length) { const t = arguments[0]; return Math.atan2(t.y, t.x) } if (2 === arguments.length) { const t = arguments[0], e = arguments[1], n = e.x - t.x, i = e.y - t.y; return Math.atan2(i, n) } } static isAcute(t, e, n) { const i = t.x - e.x, r = t.y - e.y; return i * (n.x - e.x) + r * (n.y - e.y) > 0 } static isObtuse(t, e, n) { const i = t.x - e.x, r = t.y - e.y; return i * (n.x - e.x) + r * (n.y - e.y) < 0 } static interiorAngle(t, e, n) { const i = vf.angle(e, t), r = vf.angle(e, n); return Math.abs(r - i) } static normalizePositive(t) { if (t < 0) { for (; t < 0;)t += vf.PI_TIMES_2; t >= vf.PI_TIMES_2 && (t = 0) } else { for (; t >= vf.PI_TIMES_2;)t -= vf.PI_TIMES_2; t < 0 && (t = 0) } return t } static angleBetween(t, e, n) { const i = vf.angle(e, t), r = vf.angle(e, n); return vf.diff(i, r) } static diff(t, e) { let n = null; return n = t < e ? e - t : t - e, n > Math.PI && (n = 2 * Math.PI - n), n } static toRadians(t) { return t * Math.PI / 180 } static getTurn(t, e) { const n = Math.sin(e - t); return n > 0 ? vf.COUNTERCLOCKWISE : n < 0 ? vf.CLOCKWISE : vf.NONE } static angleBetweenOriented(t, e, n) { const i = vf.angle(e, t), r = vf.angle(e, n) - i; return r <= -Math.PI ? r + vf.PI_TIMES_2 : r > Math.PI ? r - vf.PI_TIMES_2 : r } } vf.PI_TIMES_2 = 2 * Math.PI, vf.PI_OVER_2 = Math.PI / 2, vf.PI_OVER_4 = Math.PI / 4, vf.COUNTERCLOCKWISE = sc.COUNTERCLOCKWISE, vf.CLOCKWISE = sc.CLOCKWISE, vf.NONE = sc.COLLINEAR; class xf { constructor() { xf.constructor_.apply(this, arguments) } static constructor_() { this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new hf, this._seg1 = new hf, this._offset0 = new hf, this._offset1 = new hf, this._side = 0, this._hasNarrowConcaveAngle = !1; const t = arguments[0], e = arguments[1], n = arguments[2]; this._precisionModel = t, this._bufParams = e, this._li = new _u, this._filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === kc.JOIN_ROUND && (this._closingSegLengthFactor = xf.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n) } addNextSegment(t, e) { if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null; const n = sc.index(this._s0, this._s1, this._s2), i = n === sc.CLOCKWISE && this._side === jc.LEFT || n === sc.COUNTERCLOCKWISE && this._side === jc.RIGHT; 0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e) } addLineEndCap(t, e) { const n = new hf(t, e), i = new hf; this.computeOffsetSegment(n, jc.LEFT, this._distance, i); const r = new hf; this.computeOffsetSegment(n, jc.RIGHT, this._distance, r); const s = e.x - t.x, o = e.y - t.y, a = Math.atan2(o, s); switch (this._bufParams.getEndCapStyle()) { case kc.CAP_ROUND: this._segList.addPt(i.p1), this.addDirectedFillet(e, a + Math.PI / 2, a - Math.PI / 2, sc.CLOCKWISE, this._distance), this._segList.addPt(r.p1); break; case kc.CAP_FLAT: this._segList.addPt(i.p1), this._segList.addPt(r.p1); break; case kc.CAP_SQUARE: const t = new Th; t.x = Math.abs(this._distance) * Math.cos(a), t.y = Math.abs(this._distance) * Math.sin(a); const n = new Th(i.p1.x + t.x, i.p1.y + t.y), s = new Th(r.p1.x + t.x, r.p1.y + t.y); this._segList.addPt(n), this._segList.addPt(s) } } getCoordinates() { return this._segList.getCoordinates() } addMitreJoin(t, e, n, i) { const r = Vc.intersection(e.p0, e.p1, n.p0, n.p1); if (null !== r) { if ((i <= 0 ? 1 : r.distance(t) / Math.abs(i)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(r), null } this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit()) } addOutsideTurn(t, e) { if (this._offset0.p1.distance(this._offset1.p0) < this._distance * xf.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null; this._bufParams.getJoinStyle() === kc.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === kc.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0)) } createSquare(t) { this._segList.addPt(new Th(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new Th(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new Th(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new Th(t.x - this._distance, t.y + this._distance)), this._segList.closeRing() } addSegments(t, e) { this._segList.addPts(t, e) } addFirstSegment() { this._segList.addPt(this._offset1.p0) } addCornerFillet(t, e, n, i, r) { const s = e.x - t.x, o = e.y - t.y; let a = Math.atan2(o, s); const l = n.x - t.x, h = n.y - t.y, c = Math.atan2(h, l); i === sc.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, a, c, i, r), this._segList.addPt(n) } addLastSegment() { this._segList.addPt(this._offset1.p1) } initSideSegments(t, e, n) { this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1) } addLimitedMitreJoin(t, e, n, i) { const r = this._seg0.p1, s = vf.angle(r, this._seg0.p0), o = vf.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2, a = vf.normalize(s + o), l = vf.normalize(a + Math.PI), h = i * n, c = n - h * Math.abs(Math.sin(o)), u = r.x + h * Math.cos(l), f = r.y + h * Math.sin(l), p = new Th(u, f), d = new hf(r, p), g = d.pointAlongOffset(1, c), _ = d.pointAlongOffset(1, -c); this._side === jc.LEFT ? (this._segList.addPt(g), this._segList.addPt(_)) : (this._segList.addPt(_), this._segList.addPt(g)) } addDirectedFillet(t, e, n, i, r) { const s = i === sc.CLOCKWISE ? -1 : 1, o = Math.abs(e - n), a = Math.trunc(o / this._filletAngleQuantum + .5); if (a < 1) return null; const l = o / a, h = new Th; for (let n = 0; n < a; n++) { const i = e + s * n * l; h.x = t.x + r * Math.cos(i), h.y = t.y + r * Math.sin(i), this._segList.addPt(h) } } computeOffsetSegment(t, e, n, i) { const r = e === jc.LEFT ? 1 : -1, s = t.p1.x - t.p0.x, o = t.p1.y - t.p0.y, a = Math.sqrt(s * s + o * o), l = r * n * s / a, h = r * n * o / a; i.p0.x = t.p0.x - h, i.p0.y = t.p0.y + l, i.p1.x = t.p1.x - h, i.p1.y = t.p1.y + l } addInsideTurn(t, e) { if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0)); else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * xf.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1); else { if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) { const t = new Th((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1)); this._segList.addPt(t); const e = new Th((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1)); this._segList.addPt(e) } else this._segList.addPt(this._s1); this._segList.addPt(this._offset1.p0) } } createCircle(t) { const e = new Th(t.x + this._distance, t.y); this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing() } addBevelJoin(t, e) { this._segList.addPt(t.p1), this._segList.addPt(e.p0) } init(t) { this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new mf, this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * xf.CURVE_VERTEX_SNAP_DISTANCE_FACTOR) } addCollinear(t) { this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2); this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === kc.JOIN_BEVEL || this._bufParams.getJoinStyle() === kc.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, sc.CLOCKWISE, this._distance)) } closeRing() { this._segList.closeRing() } hasNarrowConcaveAngle() { return this._hasNarrowConcaveAngle } } xf.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, xf.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, xf.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, xf.MAX_CLOSING_SEG_LEN_FACTOR = 80; class Ef { constructor() { Ef.constructor_.apply(this, arguments) } static constructor_() { this._distance = 0, this._precisionModel = null, this._bufParams = null; const t = arguments[0], e = arguments[1]; this._precisionModel = t, this._bufParams = e } static copyCoordinates(t) { const e = new Array(t.length).fill(null); for (let n = 0; n < e.length; n++)e[n] = new Th(t[n]); return e } getOffsetCurve(t, e) { if (this._distance = e, 0 === e) return null; const n = e < 0, i = Math.abs(e), r = this.getSegGen(i); t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r); const s = r.getCoordinates(); return n && Ic.reverse(s), s } computeSingleSidedBufferCurve(t, e, n) { const i = this.simplifyTolerance(this._distance); if (e) { n.addSegments(t, !0); const e = yf.simplify(t, -i), r = e.length - 1; n.initSideSegments(e[r], e[r - 1], jc.LEFT), n.addFirstSegment(); for (let t = r - 2; t >= 0; t--)n.addNextSegment(e[t], !0) } else { n.addSegments(t, !1); const e = yf.simplify(t, i), r = e.length - 1; n.initSideSegments(e[0], e[1], jc.LEFT), n.addFirstSegment(); for (let t = 2; t <= r; t++)n.addNextSegment(e[t], !0) } n.addLastSegment(), n.closeRing() } computeRingBufferCurve(t, e, n) { let i = this.simplifyTolerance(this._distance); e === jc.RIGHT && (i = -i); const r = yf.simplify(t, i), s = r.length - 1; n.initSideSegments(r[s - 1], r[0], e); for (let t = 1; t <= s; t++) { const e = 1 !== t; n.addNextSegment(r[t], e) } n.closeRing() } computeLineBufferCurve(t, e) { const n = this.simplifyTolerance(this._distance), i = yf.simplify(t, n), r = i.length - 1; e.initSideSegments(i[0], i[1], jc.LEFT); for (let t = 2; t <= r; t++)e.addNextSegment(i[t], !0); e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]); const s = yf.simplify(t, -n), o = s.length - 1; e.initSideSegments(s[o], s[o - 1], jc.LEFT); for (let t = o - 2; t >= 0; t--)e.addNextSegment(s[t], !0); e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing() } computePointCurve(t, e) { switch (this._bufParams.getEndCapStyle()) { case kc.CAP_ROUND: e.createCircle(t); break; case kc.CAP_SQUARE: e.createSquare(t) } } getLineCurve(t, e) { if (this._distance = e, this.isLineOffsetEmpty(e)) return null; const n = Math.abs(e), i = this.getSegGen(n); if (t.length <= 1) this.computePointCurve(t[0], i); else if (this._bufParams.isSingleSided()) { const n = e < 0; this.computeSingleSidedBufferCurve(t, n, i) } else this.computeLineBufferCurve(t, i); return i.getCoordinates() } getBufferParameters() { return this._bufParams } simplifyTolerance(t) { return t * this._bufParams.getSimplifyFactor() } getRingCurve(t, e, n) { if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n); if (0 === n) return Ef.copyCoordinates(t); const i = this.getSegGen(n); return this.computeRingBufferCurve(t, e, i), i.getCoordinates() } computeOffsetCurve(t, e, n) { const i = this.simplifyTolerance(this._distance); if (e) { const e = yf.simplify(t, -i), r = e.length - 1; n.initSideSegments(e[r], e[r - 1], jc.LEFT), n.addFirstSegment(); for (let t = r - 2; t >= 0; t--)n.addNextSegment(e[t], !0) } else { const e = yf.simplify(t, i), r = e.length - 1; n.initSideSegments(e[0], e[1], jc.LEFT), n.addFirstSegment(); for (let t = 2; t <= r; t++)n.addNextSegment(e[t], !0) } n.addLastSegment() } isLineOffsetEmpty(t) { return 0 === t || t < 0 && !this._bufParams.isSingleSided() } getSegGen(t) { return new xf(this._precisionModel, this._bufParams, t) } } class If { constructor() { If.constructor_.apply(this, arguments) } static constructor_() { this._subgraphs = null, this._seg = new hf; const t = arguments[0]; this._subgraphs = t } findStabbedSegments() { if (1 === arguments.length) { const t = arguments[0], e = new Qh; for (let n = this._subgraphs.iterator(); n.hasNext();) { const i = n.next(), r = i.getEnvelope(); t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e) } return e } if (3 === arguments.length) if (Nh(arguments[2], Zh) && arguments[0] instanceof Th && arguments[1] instanceof Fu) { const t = arguments[0], e = arguments[1], n = arguments[2], i = e.getEdge().getCoordinates(); for (let r = 0; r < i.length - 1; r++) { this._seg.p0 = i[r], this._seg.p1 = i[r + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(); if (Math.max(this._seg.p0.x, this._seg.p1.x) < t.x) continue; if (this._seg.isHorizontal()) continue; if (t.y < this._seg.p0.y || t.y > this._seg.p1.y) continue; if (sc.index(this._seg.p0, this._seg.p1, t) === sc.RIGHT) continue; let s = e.getDepth(jc.LEFT); this._seg.p0.equals(i[r]) || (s = e.getDepth(jc.RIGHT)); const o = new Cf(this._seg, s); n.add(o) } } else if (Nh(arguments[2], Zh) && arguments[0] instanceof Th && Nh(arguments[1], Zh)) { const t = arguments[0], e = arguments[2]; for (let n = arguments[1].iterator(); n.hasNext();) { const i = n.next(); i.isForward() && this.findStabbedSegments(t, i, e) } } } getDepth(t) { const e = this.findStabbedSegments(t); if (0 === e.size()) return 0; return Vu.min(e)._leftDepth } } class Cf { constructor() { Cf.constructor_.apply(this, arguments) } static constructor_() { this._upwardSeg = null, this._leftDepth = null; const t = arguments[0], e = arguments[1]; this._upwardSeg = new hf(t), this._leftDepth = e } compareTo(t) { const e = t; if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1; if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1; let n = this._upwardSeg.orientationIndex(e._upwardSeg); return 0 !== n ? n : (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg), 0 !== n ? n : this._upwardSeg.compareTo(e._upwardSeg)) } compareX(t, e) { const n = t.p0.compareTo(e.p0); return 0 !== n ? n : t.p1.compareTo(e.p1) } toString() { return this._upwardSeg.toString() } get interfaces_() { return [mh] } } If.DepthSegment = Cf; class wf extends dh { constructor() { super(), wf.constructor_.apply(this, arguments) } static constructor_() { dh.constructor_.call(this, "Projective point not representable on the Cartesian plane.") } } class Sf { constructor() { Sf.constructor_.apply(this, arguments) } static constructor_() { if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1; else if (1 === arguments.length) { const t = arguments[0]; this.x = t.x, this.y = t.y, this.w = 1 } else if (2 === arguments.length) { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; this.x = t, this.y = e, this.w = 1 } else if (arguments[0] instanceof Sf && arguments[1] instanceof Sf) { const t = arguments[0], e = arguments[1]; this.x = t.y * e.w - e.y * t.w, this.y = e.x * t.w - t.x * e.w, this.w = t.x * e.y - e.x * t.y } else if (arguments[0] instanceof Th && arguments[1] instanceof Th) { const t = arguments[0], e = arguments[1]; this.x = t.y - e.y, this.y = e.x - t.x, this.w = t.x * e.y - e.x * t.y } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this.x = t, this.y = e, this.w = n } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3], r = t.y - e.y, s = e.x - t.x, o = t.x * e.y - e.x * t.y, a = n.y - i.y, l = i.x - n.x, h = n.x * i.y - i.x * n.y; this.x = s * h - l * o, this.y = a * o - r * h, this.w = r * l - a * s } } getY() { const t = this.y / this.w; if (yh.isNaN(t) || yh.isInfinite(t)) throw new wf; return t } getX() { const t = this.x / this.w; if (yh.isNaN(t) || yh.isInfinite(t)) throw new wf; return t } getCoordinate() { const t = new Th; return t.x = this.getX(), t.y = this.getY(), t } } class bf { constructor() { bf.constructor_.apply(this, arguments) } static constructor_() { this.p0 = null, this.p1 = null, this.p2 = null; const t = arguments[0], e = arguments[1], n = arguments[2]; this.p0 = t, this.p1 = e, this.p2 = n } static area(t, e, n) { return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2) } static signedArea(t, e, n) { return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2 } static det(t, e, n, i) { return t * i - e * n } static interpolateZ(t, e, n, i) { const r = e.x, s = e.y, o = n.x - r, a = i.x - r, l = n.y - s, h = i.y - s, c = o * h - a * l, u = t.x - r, f = t.y - s, p = (h * u - a * f) / c, d = (-l * u + o * f) / c; return e.getZ() + p * (n.getZ() - e.getZ()) + d * (i.getZ() - e.getZ()) } static longestSideLength(t, e, n) { const i = t.distance(e), r = e.distance(n), s = n.distance(t); let o = i; return r > o && (o = r), s > o && (o = s), o } static circumcentreDD(t, e, n) { const i = ic.valueOf(t.x).subtract(n.x), r = ic.valueOf(t.y).subtract(n.y), s = ic.valueOf(e.x).subtract(n.x), o = ic.valueOf(e.y).subtract(n.y), a = ic.determinant(i, r, s, o).multiply(2), l = i.sqr().add(r.sqr()), h = s.sqr().add(o.sqr()), c = ic.determinant(r, l, o, h), u = ic.determinant(i, l, s, h), f = ic.valueOf(n.x).subtract(c.divide(a)).doubleValue(), p = ic.valueOf(n.y).add(u.divide(a)).doubleValue(); return new Th(f, p) } static isAcute(t, e, n) { return !!vf.isAcute(t, e, n) && (!!vf.isAcute(e, n, t) && !!vf.isAcute(n, t, e)) } static circumcentre(t, e, n) { const i = n.x, r = n.y, s = t.x - i, o = t.y - r, a = e.x - i, l = e.y - r, h = 2 * bf.det(s, o, a, l), c = bf.det(o, s * s + o * o, l, a * a + l * l), u = bf.det(s, s * s + o * o, a, a * a + l * l); return new Th(i - c / h, r + u / h) } static perpendicularBisector(t, e) { const n = e.x - t.x, i = e.y - t.y, r = new Sf(t.x + n / 2, t.y + i / 2, 1), s = new Sf(t.x - i + n / 2, t.y + n + i / 2, 1); return new Sf(r, s) } static angleBisector(t, e, n) { const i = e.distance(t), r = i / (i + e.distance(n)), s = n.x - t.x, o = n.y - t.y; return new Th(t.x + r * s, t.y + r * o) } static area3D(t, e, n) { const i = e.x - t.x, r = e.y - t.y, s = e.getZ() - t.getZ(), o = n.x - t.x, a = n.y - t.y, l = n.getZ() - t.getZ(), h = r * l - s * a, c = s * o - i * l, u = i * a - r * o, f = h * h + c * c + u * u; return Math.sqrt(f) / 2 } static centroid(t, e, n) { const i = (t.x + e.x + n.x) / 3, r = (t.y + e.y + n.y) / 3; return new Th(i, r) } static inCentre(t, e, n) { const i = e.distance(n), r = t.distance(n), s = t.distance(e), o = i + r + s, a = (i * t.x + r * e.x + s * n.x) / o, l = (i * t.y + r * e.y + s * n.y) / o; return new Th(a, l) } area() { return bf.area(this.p0, this.p1, this.p2) } signedArea() { return bf.signedArea(this.p0, this.p1, this.p2) } interpolateZ(t) { if (null === t) throw new gh("Supplied point is null."); return bf.interpolateZ(t, this.p0, this.p1, this.p2) } longestSideLength() { return bf.longestSideLength(this.p0, this.p1, this.p2) } isAcute() { return bf.isAcute(this.p0, this.p1, this.p2) } circumcentre() { return bf.circumcentre(this.p0, this.p1, this.p2) } area3D() { return bf.area3D(this.p0, this.p1, this.p2) } centroid() { return bf.centroid(this.p0, this.p1, this.p2) } inCentre() { return bf.inCentre(this.p0, this.p1, this.p2) } } class Of { constructor() { Of.constructor_.apply(this, arguments) } static constructor_() { this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Qh; const t = arguments[0], e = arguments[1], n = arguments[2]; this._inputGeom = t, this._distance = e, this._curveBuilder = n } addRingSide(t, e, n, i, r) { if (0 === e && t.length < dc.MINIMUM_VALID_SIZE) return null; let s = i, o = r; t.length >= dc.MINIMUM_VALID_SIZE && sc.isCCW(t) && (s = r, o = i, n = jc.opposite(n)); const a = this._curveBuilder.getRingCurve(t, n, e); this.addCurve(a, s, o) } addRingBothSides(t, e) { this.addRingSide(t, e, jc.LEFT, Gc.EXTERIOR, Gc.INTERIOR), this.addRingSide(t, e, jc.RIGHT, Gc.INTERIOR, Gc.EXTERIOR) } addPoint(t) { if (this._distance <= 0) return null; const e = t.getCoordinates(), n = this._curveBuilder.getLineCurve(e, this._distance); this.addCurve(n, Gc.EXTERIOR, Gc.INTERIOR) } addPolygon(t) { let e = this._distance, n = jc.LEFT; this._distance < 0 && (e = -this._distance, n = jc.RIGHT); const i = t.getExteriorRing(), r = Ic.removeRepeatedPoints(i.getCoordinates()); if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null; if (this._distance <= 0 && r.length < 3) return null; this.addRingSide(r, e, n, Gc.EXTERIOR, Gc.INTERIOR); for (let i = 0; i < t.getNumInteriorRing(); i++) { const r = t.getInteriorRingN(i), s = Ic.removeRepeatedPoints(r.getCoordinates()); this._distance > 0 && this.isErodedCompletely(r, -this._distance) || this.addRingSide(s, e, jc.opposite(n), Gc.INTERIOR, Gc.EXTERIOR) } } isTriangleErodedCompletely(t, e) { const n = new bf(t[0], t[1], t[2]), i = n.inCentre(); return Wc.pointToSegment(i, n.p0, n.p1) < Math.abs(e) } addLineString(t) { if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null; const e = Ic.removeRepeatedPoints(t.getCoordinates()); if (Ic.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance); else { const t = this._curveBuilder.getLineCurve(e, this._distance); this.addCurve(t, Gc.EXTERIOR, Gc.INTERIOR) } } addCurve(t, e, n) { if (null === t || t.length < 2) return null; const i = new lf(t, new xu(0, Gc.BOUNDARY, e, n)); this._curveList.add(i) } getCurves() { return this.add(this._inputGeom), this._curveList } add(t) { if (t.isEmpty()) return null; if (t instanceof ac) this.addPolygon(t); else if (t instanceof zh) this.addLineString(t); else if (t instanceof Vh) this.addPoint(t); else if (t instanceof pc) this.addCollection(t); else if (t instanceof Mc) this.addCollection(t); else if (t instanceof bc) this.addCollection(t); else { if (!(t instanceof fc)) throw new jh(t.getGeometryType()); this.addCollection(t) } } isErodedCompletely(t, e) { const n = t.getCoordinates(); if (n.length < 4) return e < 0; if (4 === n.length) return this.isTriangleErodedCompletely(n, e); const i = t.getEnvelopeInternal(), r = Math.min(i.getHeight(), i.getWidth()); return e < 0 && 2 * Math.abs(e) > r } addCollection(t) { for (let e = 0; e < t.getNumGeometries(); e++) { const n = t.getGeometryN(e); this.add(n) } } } class Tf { locate(t) { } } class Rf { constructor() { Rf.constructor_.apply(this, arguments) } static constructor_() { this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null; const t = arguments[0]; this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries() } static isAtomic(t) { return !(t instanceof fc) } next() { if (this._atStart) return this._atStart = !1, Rf.isAtomic(this._parent) && this._index++, this._parent; if (null !== this._subcollectionIterator) { if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next(); this._subcollectionIterator = null } if (this._index >= this._max) throw new Jh; const t = this._parent.getGeometryN(this._index++); return t instanceof fc ? (this._subcollectionIterator = new Rf(t), this._subcollectionIterator.next()) : t } remove() { throw new jh(this.getClass().getName()) } hasNext() { if (this._atStart) return !0; if (null !== this._subcollectionIterator) { if (this._subcollectionIterator.hasNext()) return !0; this._subcollectionIterator = null } return !(this._index >= this._max) } get interfaces_() { return [nf] } } class Nf { constructor() { Nf.constructor_.apply(this, arguments) } static constructor_() { this._geom = null; const t = arguments[0]; this._geom = t } static locatePointInPolygon(t, e) { if (e.isEmpty()) return Gc.EXTERIOR; const n = e.getExteriorRing(), i = Nf.locatePointInRing(t, n); if (i !== Gc.INTERIOR) return i; for (let n = 0; n < e.getNumInteriorRing(); n++) { const i = e.getInteriorRingN(n), r = Nf.locatePointInRing(t, i); if (r === Gc.BOUNDARY) return Gc.BOUNDARY; if (r === Gc.INTERIOR) return Gc.EXTERIOR } return Gc.INTERIOR } static locatePointInRing(t, e) { return e.getEnvelopeInternal().intersects(t) ? mu.locateInRing(t, e.getCoordinates()) : Gc.EXTERIOR } static containsPointInPolygon(t, e) { return Gc.EXTERIOR !== Nf.locatePointInPolygon(t, e) } static locateInGeometry(t, e) { if (e instanceof ac) return Nf.locatePointInPolygon(t, e); if (e instanceof fc) { const n = new Rf(e); for (; n.hasNext();) { const i = n.next(); if (i !== e) { const e = Nf.locateInGeometry(t, i); if (e !== Gc.EXTERIOR) return e } } } return Gc.EXTERIOR } static isContained(t, e) { return Gc.EXTERIOR !== Nf.locate(t, e) } static locate(t, e) { return e.isEmpty() ? Gc.EXTERIOR : e.getEnvelopeInternal().intersects(t) ? Nf.locateInGeometry(t, e) : Gc.EXTERIOR } locate(t) { return Nf.locate(t, this._geom) } get interfaces_() { return [Tf] } } class Lf { constructor() { Lf.constructor_.apply(this, arguments) } static constructor_() { this._edgeMap = new Pu, this._edgeList = null, this._ptInAreaLocation = [Gc.NONE, Gc.NONE] } getNextCW(t) { this.getEdges(); const e = this._edgeList.indexOf(t); let n = e - 1; return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n) } propagateSideLabels(t) { let e = Gc.NONE; for (let n = this.iterator(); n.hasNext();) { const i = n.next().getLabel(); i.isArea(t) && i.getLocation(t, jc.LEFT) !== Gc.NONE && (e = i.getLocation(t, jc.LEFT)) } if (e === Gc.NONE) return null; let n = e; for (let e = this.iterator(); e.hasNext();) { const i = e.next(), r = i.getLabel(); if (r.getLocation(t, jc.ON) === Gc.NONE && r.setLocation(t, jc.ON, n), r.isArea(t)) { const e = r.getLocation(t, jc.LEFT), s = r.getLocation(t, jc.RIGHT); if (s !== Gc.NONE) { if (s !== n) throw new Xc("side location conflict", i.getCoordinate()); e === Gc.NONE && wh.shouldNeverReachHere("found single null side (at " + i.getCoordinate() + ")"), n = e } else wh.isTrue(r.getLocation(t, jc.LEFT) === Gc.NONE, "found single null side"), r.setLocation(t, jc.RIGHT, n), r.setLocation(t, jc.LEFT, n) } } } getCoordinate() { const t = this.iterator(); if (!t.hasNext()) return null; return t.next().getCoordinate() } print(t) { Ec.out.println("EdgeEndStar:   " + this.getCoordinate()); for (let e = this.iterator(); e.hasNext();) { e.next().print(t) } } isAreaLabelsConsistent(t) { return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0) } checkAreaLabelsConsistent(t) { const e = this.getEdges(); if (e.size() <= 0) return !0; const n = e.size() - 1, i = e.get(n).getLabel().getLocation(t, jc.LEFT); wh.isTrue(i !== Gc.NONE, "Found unlabelled area edge"); let r = i; for (let e = this.iterator(); e.hasNext();) { const n = e.next().getLabel(); wh.isTrue(n.isArea(t), "Found non-area edge"); const i = n.getLocation(t, jc.LEFT), s = n.getLocation(t, jc.RIGHT); if (i === s) return !1; if (s !== r) return !1; r = i } return !0 } findIndex(t) { this.iterator(); for (let e = 0; e < this._edgeList.size(); e++) { if (this._edgeList.get(e) === t) return e } return -1 } iterator() { return this.getEdges().iterator() } getEdges() { return null === this._edgeList && (this._edgeList = new Qh(this._edgeMap.values())), this._edgeList } getLocation(t, e, n) { return this._ptInAreaLocation[t] === Gc.NONE && (this._ptInAreaLocation[t] = Nf.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t] } toString() { const t = new ec; t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n"); for (let e = this.iterator(); e.hasNext();) { const n = e.next(); t.append(n), t.append("\n") } return t.toString() } computeEdgeEndLabels(t) { for (let e = this.iterator(); e.hasNext();) { e.next().computeLabel(t) } } computeLabelling(t) { this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1); const e = [!1, !1]; for (let t = this.iterator(); t.hasNext();) { const n = t.next().getLabel(); for (let t = 0; t < 2; t++)n.isLine(t) && n.getLocation(t) === Gc.BOUNDARY && (e[t] = !0) } for (let n = this.iterator(); n.hasNext();) { const i = n.next(), r = i.getLabel(); for (let n = 0; n < 2; n++)if (r.isAnyNull(n)) { let s = Gc.NONE; if (e[n]) s = Gc.EXTERIOR; else { const e = i.getCoordinate(); s = this.getLocation(n, e, t) } r.setAllLocationsIfNull(n, s) } } } getDegree() { return this._edgeMap.size() } insertEdgeEnd(t, e) { this._edgeMap.put(t, e), this._edgeList = null } } class Pf extends Lf { constructor() { super(), Pf.constructor_.apply(this, arguments) } static constructor_() { this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2 } linkResultDirectedEdges() { this.getResultAreaEdges(); let t = null, e = null, n = this._SCANNING_FOR_INCOMING; for (let i = 0; i < this._resultAreaEdgeList.size(); i++) { const r = this._resultAreaEdgeList.get(i), s = r.getSym(); if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) { case this._SCANNING_FOR_INCOMING: if (!s.isInResult()) continue; e = s, n = this._LINKING_TO_OUTGOING; break; case this._LINKING_TO_OUTGOING: if (!r.isInResult()) continue; e.setNext(r), n = this._SCANNING_FOR_INCOMING } } if (n === this._LINKING_TO_OUTGOING) { if (null === t) throw new Xc("no outgoing dirEdge found", this.getCoordinate()); wh.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t) } } insert(t) { const e = t; this.insertEdgeEnd(e, e) } getRightmostEdge() { const t = this.getEdges(), e = t.size(); if (e < 1) return null; const n = t.get(0); if (1 === e) return n; const i = t.get(e - 1), r = n.getQuadrant(), s = i.getQuadrant(); if (Du.isNorthern(r) && Du.isNorthern(s)) return n; if (!Du.isNorthern(r) && !Du.isNorthern(s)) return i; if (0 !== n.getDy()) return n; if (0 !== i.getDy()) return i; return wh.shouldNeverReachHere("found two horizontal edges incident on node"), null } print(t) { Ec.out.println("DirectedEdgeStar: " + this.getCoordinate()); for (let e = this.iterator(); e.hasNext();) { const n = e.next(); t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println() } } getResultAreaEdges() { if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList; this._resultAreaEdgeList = new Qh; for (let t = this.iterator(); t.hasNext();) { const e = t.next(); (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e) } return this._resultAreaEdgeList } updateLabelling(t) { for (let e = this.iterator(); e.hasNext();) { const n = e.next().getLabel(); n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1)) } } linkAllDirectedEdges() { this.getEdges(); let t = null, e = null; for (let n = this._edgeList.size() - 1; n >= 0; n--) { const i = this._edgeList.get(n), r = i.getSym(); null === e && (e = r), null !== t && r.setNext(t), t = i } e.setNext(t) } computeDepths() { if (1 === arguments.length) { const t = arguments[0], e = this.findIndex(t), n = t.getDepth(jc.LEFT), i = t.getDepth(jc.RIGHT), r = this.computeDepths(e + 1, this._edgeList.size(), n); if (this.computeDepths(0, e, r) !== i) throw new Xc("depth mismatch at " + t.getCoordinate()) } else if (3 === arguments.length) { const t = arguments[1]; let e = arguments[2]; for (let n = arguments[0]; n < t; n++) { const t = this._edgeList.get(n); t.setEdgeDepths(jc.RIGHT, e), e = t.getDepth(jc.LEFT) } return e } } mergeSymLabels() { for (let t = this.iterator(); t.hasNext();) { const e = t.next(); e.getLabel().merge(e.getSym().getLabel()) } } linkMinimalDirectedEdges(t) { let e = null, n = null, i = this._SCANNING_FOR_INCOMING; for (let r = this._resultAreaEdgeList.size() - 1; r >= 0; r--) { const s = this._resultAreaEdgeList.get(r), o = s.getSym(); switch (null === e && s.getEdgeRing() === t && (e = s), i) { case this._SCANNING_FOR_INCOMING: if (o.getEdgeRing() !== t) continue; n = o, i = this._LINKING_TO_OUTGOING; break; case this._LINKING_TO_OUTGOING: if (s.getEdgeRing() !== t) continue; n.setNextMin(s), i = this._SCANNING_FOR_INCOMING } } i === this._LINKING_TO_OUTGOING && (wh.isTrue(null !== e, "found null for first outgoing dirEdge"), wh.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e)) } getOutgoingDegree() { if (0 === arguments.length) { let t = 0; for (let e = this.iterator(); e.hasNext();) { e.next().isInResult() && t++ } return t } if (1 === arguments.length) { const t = arguments[0]; let e = 0; for (let n = this.iterator(); n.hasNext();) { n.next().getEdgeRing() === t && e++ } return e } } getLabel() { return this._label } findCoveredLineEdges() { let t = Gc.NONE; for (let e = this.iterator(); e.hasNext();) { const n = e.next(), i = n.getSym(); if (!n.isLineEdge()) { if (n.isInResult()) { t = Gc.INTERIOR; break } if (i.isInResult()) { t = Gc.EXTERIOR; break } } } if (t === Gc.NONE) return null; let e = t; for (let t = this.iterator(); t.hasNext();) { const n = t.next(), i = n.getSym(); n.isLineEdge() ? n.getEdge().setCovered(e === Gc.INTERIOR) : (n.isInResult() && (e = Gc.EXTERIOR), i.isInResult() && (e = Gc.INTERIOR)) } } computeLabelling(t) { super.computeLabelling.call(this, t), this._label = new xu(Gc.NONE); for (let t = this.iterator(); t.hasNext();) { const e = t.next().getEdge().getLabel(); for (let t = 0; t < 2; t++) { const n = e.getLocation(t); n !== Gc.INTERIOR && n !== Gc.BOUNDARY || this._label.setLocation(t, Gc.INTERIOR) } } } } class Mf extends ku { constructor() { super() } createNode(t) { return new Su(t, new Pf) } } class Df { constructor() { Df.constructor_.apply(this, arguments) } static constructor_() { this._pts = null, this._orientation = null; const t = arguments[0]; this._pts = t, this._orientation = Df.orientation(t) } static orientation(t) { return 1 === Ic.increasingDirection(t) } static compareOriented(t, e, n, i) { const r = e ? 1 : -1, s = i ? 1 : -1, o = e ? t.length : -1, a = i ? n.length : -1; let l = e ? 0 : t.length - 1, h = i ? 0 : n.length - 1; for (; ;) { const e = t[l].compareTo(n[h]); if (0 !== e) return e; l += r, h += s; const i = l === o, c = h === a; if (i && !c) return -1; if (!i && c) return 1; if (i && c) return 0 } } compareTo(t) { const e = t; return Df.compareOriented(this._pts, this._orientation, e._pts, e._orientation) } get interfaces_() { return [mh] } } class Af { constructor() { Af.constructor_.apply(this, arguments) } static constructor_() { this._edges = new Qh, this._ocaMap = new Pu } print(t) { t.print("MULTILINESTRING ( "); for (let e = 0; e < this._edges.size(); e++) { const n = this._edges.get(e); e > 0 && t.print(","), t.print("("); const i = n.getCoordinates(); for (let e = 0; e < i.length; e++)e > 0 && t.print(","), t.print(i[e].x + " " + i[e].y); t.println(")") } t.print(")  ") } addAll(t) { for (let e = t.iterator(); e.hasNext();)this.add(e.next()) } findEdgeIndex(t) { for (let e = 0; e < this._edges.size(); e++)if (this._edges.get(e).equals(t)) return e; return -1 } iterator() { return this._edges.iterator() } getEdges() { return this._edges } get(t) { return this._edges.get(t) } findEqualEdge(t) { const e = new Df(t.getCoordinates()); return this._ocaMap.get(e) } add(t) { this._edges.add(t); const e = new Df(t.getCoordinates()); this._ocaMap.put(e, t) } } class Ff { processIntersections(t, e, n, i) { } isDone() { } } class kf { constructor() { kf.constructor_.apply(this, arguments) } static constructor_() { this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0; const t = arguments[0]; this._li = t } static isAdjacentSegments(t, e) { return 1 === Math.abs(t - e) } isTrivialIntersection(t, e, n, i) { if (t === n && 1 === this._li.getIntersectionNum()) { if (kf.isAdjacentSegments(e, i)) return !0; if (t.isClosed()) { const n = t.size() - 1; if (0 === e && i === n || 0 === i && e === n) return !0 } } return !1 } getProperIntersectionPoint() { return this._properIntersectionPoint } hasProperInteriorIntersection() { return this._hasProperInterior } getLineIntersector() { return this._li } hasProperIntersection() { return this._hasProper } processIntersections(t, e, n, i) { if (t === n && e === i) return null; this.numTests++; const r = t.getCoordinates()[e], s = t.getCoordinates()[e + 1], o = n.getCoordinates()[i], a = n.getCoordinates()[i + 1]; this._li.computeIntersection(r, s, o, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0))) } hasIntersection() { return this._hasIntersection } isDone() { return !1 } hasInteriorIntersection() { return this._hasInterior } get interfaces_() { return [Ff] } } class Gf { constructor() { Gf.constructor_.apply(this, arguments) } static constructor_() { this.coord = null, this.segmentIndex = null, this.dist = null; const t = arguments[0], e = arguments[1], n = arguments[2]; this.coord = new Th(t), this.segmentIndex = e, this.dist = n } getSegmentIndex() { return this.segmentIndex } getCoordinate() { return this.coord } print(t) { t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist) } compareTo(t) { const e = t; return this.compare(e.segmentIndex, e.dist) } isEndPoint(t) { return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t } toString() { return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist } getDistance() { return this.dist } compare(t, e) { return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0 } get interfaces_() { return [mh] } } class jf { constructor() { jf.constructor_.apply(this, arguments) } static constructor_() { this._nodeMap = new Pu, this.edge = null; const t = arguments[0]; this.edge = t } print(t) { t.println("Intersections:"); for (let e = this.iterator(); e.hasNext();) { e.next().print(t) } } iterator() { return this._nodeMap.values().iterator() } addSplitEdges(t) { this.addEndpoints(); const e = this.iterator(); let n = e.next(); for (; e.hasNext();) { const i = e.next(), r = this.createSplitEdge(n, i); t.add(r), n = i } } addEndpoints() { const t = this.edge.pts.length - 1; this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0) } createSplitEdge(t, e) { let n = e.segmentIndex - t.segmentIndex + 2; const i = this.edge.pts[e.segmentIndex], r = e.dist > 0 || !e.coord.equals2D(i); r || n--; const s = new Array(n).fill(null); let o = 0; s[o++] = new Th(t.coord); for (let n = t.segmentIndex + 1; n <= e.segmentIndex; n++)s[o++] = this.edge.pts[n]; return r && (s[o] = e.coord), new Uf(s, new xu(this.edge._label)) } add(t, e, n) { const i = new Gf(t, e, n), r = this._nodeMap.get(i); return null !== r ? r : (this._nodeMap.put(i, i), i) } isIntersection(t) { for (let e = this.iterator(); e.hasNext();) { if (e.next().coord.equals(t)) return !0 } return !1 } } class Bf { constructor() { Bf.constructor_.apply(this, arguments) } static constructor_() { if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map(() => Array(3)), this.setAll(Yh.FALSE); else if (1 === arguments.length) if ("string" == typeof arguments[0]) { const t = arguments[0]; Bf.constructor_.call(this), this.set(t) } else if (arguments[0] instanceof Bf) { const t = arguments[0]; Bf.constructor_.call(this), this._matrix[Gc.INTERIOR][Gc.INTERIOR] = t._matrix[Gc.INTERIOR][Gc.INTERIOR], this._matrix[Gc.INTERIOR][Gc.BOUNDARY] = t._matrix[Gc.INTERIOR][Gc.BOUNDARY], this._matrix[Gc.INTERIOR][Gc.EXTERIOR] = t._matrix[Gc.INTERIOR][Gc.EXTERIOR], this._matrix[Gc.BOUNDARY][Gc.INTERIOR] = t._matrix[Gc.BOUNDARY][Gc.INTERIOR], this._matrix[Gc.BOUNDARY][Gc.BOUNDARY] = t._matrix[Gc.BOUNDARY][Gc.BOUNDARY], this._matrix[Gc.BOUNDARY][Gc.EXTERIOR] = t._matrix[Gc.BOUNDARY][Gc.EXTERIOR], this._matrix[Gc.EXTERIOR][Gc.INTERIOR] = t._matrix[Gc.EXTERIOR][Gc.INTERIOR], this._matrix[Gc.EXTERIOR][Gc.BOUNDARY] = t._matrix[Gc.EXTERIOR][Gc.BOUNDARY], this._matrix[Gc.EXTERIOR][Gc.EXTERIOR] = t._matrix[Gc.EXTERIOR][Gc.EXTERIOR] } } static matches() { if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; return e === Yh.SYM_DONTCARE || (e === Yh.SYM_TRUE && (t >= 0 || t === Yh.TRUE) || (e === Yh.SYM_FALSE && t === Yh.FALSE || (e === Yh.SYM_P && t === Yh.P || (e === Yh.SYM_L && t === Yh.L || e === Yh.SYM_A && t === Yh.A)))) } if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) { const t = arguments[1]; return new Bf(arguments[0]).matches(t) } } static isTrue(t) { return t >= 0 || t === Yh.TRUE } isIntersects() { return !this.isDisjoint() } isCovers() { return (Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) || Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.BOUNDARY]) || Bf.isTrue(this._matrix[Gc.BOUNDARY][Gc.INTERIOR]) || Bf.isTrue(this._matrix[Gc.BOUNDARY][Gc.BOUNDARY])) && this._matrix[Gc.EXTERIOR][Gc.INTERIOR] === Yh.FALSE && this._matrix[Gc.EXTERIOR][Gc.BOUNDARY] === Yh.FALSE } isCoveredBy() { return (Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) || Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.BOUNDARY]) || Bf.isTrue(this._matrix[Gc.BOUNDARY][Gc.INTERIOR]) || Bf.isTrue(this._matrix[Gc.BOUNDARY][Gc.BOUNDARY])) && this._matrix[Gc.INTERIOR][Gc.EXTERIOR] === Yh.FALSE && this._matrix[Gc.BOUNDARY][Gc.EXTERIOR] === Yh.FALSE } set() { if (1 === arguments.length) { const t = arguments[0]; for (let e = 0; e < t.length; e++) { const n = Math.trunc(e / 3), i = e % 3; this._matrix[n][i] = Yh.toDimensionValue(t.charAt(e)) } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._matrix[t][e] = n } } isContains() { return Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) && this._matrix[Gc.EXTERIOR][Gc.INTERIOR] === Yh.FALSE && this._matrix[Gc.EXTERIOR][Gc.BOUNDARY] === Yh.FALSE } setAtLeast() { if (1 === arguments.length) { const t = arguments[0]; for (let e = 0; e < t.length; e++) { const n = Math.trunc(e / 3), i = e % 3; this.setAtLeast(n, i, Yh.toDimensionValue(t.charAt(e))) } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._matrix[t][e] < n && (this._matrix[t][e] = n) } } setAtLeastIfValid(t, e, n) { t >= 0 && e >= 0 && this.setAtLeast(t, e, n) } isWithin() { return Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) && this._matrix[Gc.INTERIOR][Gc.EXTERIOR] === Yh.FALSE && this._matrix[Gc.BOUNDARY][Gc.EXTERIOR] === Yh.FALSE } isTouches(t, e) { return t > e ? this.isTouches(e, t) : (t === Yh.A && e === Yh.A || t === Yh.L && e === Yh.L || t === Yh.L && e === Yh.A || t === Yh.P && e === Yh.A || t === Yh.P && e === Yh.L) && (this._matrix[Gc.INTERIOR][Gc.INTERIOR] === Yh.FALSE && (Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.BOUNDARY]) || Bf.isTrue(this._matrix[Gc.BOUNDARY][Gc.INTERIOR]) || Bf.isTrue(this._matrix[Gc.BOUNDARY][Gc.BOUNDARY]))) } isOverlaps(t, e) { return t === Yh.P && e === Yh.P || t === Yh.A && e === Yh.A ? Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) && Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.EXTERIOR]) && Bf.isTrue(this._matrix[Gc.EXTERIOR][Gc.INTERIOR]) : t === Yh.L && e === Yh.L && (1 === this._matrix[Gc.INTERIOR][Gc.INTERIOR] && Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.EXTERIOR]) && Bf.isTrue(this._matrix[Gc.EXTERIOR][Gc.INTERIOR])) } isEquals(t, e) { return t === e && (Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) && this._matrix[Gc.INTERIOR][Gc.EXTERIOR] === Yh.FALSE && this._matrix[Gc.BOUNDARY][Gc.EXTERIOR] === Yh.FALSE && this._matrix[Gc.EXTERIOR][Gc.INTERIOR] === Yh.FALSE && this._matrix[Gc.EXTERIOR][Gc.BOUNDARY] === Yh.FALSE) } toString() { const t = new Cc("123456789"); for (let e = 0; e < 3; e++)for (let n = 0; n < 3; n++)t.setCharAt(3 * e + n, Yh.toDimensionSymbol(this._matrix[e][n])); return t.toString() } setAll(t) { for (let e = 0; e < 3; e++)for (let n = 0; n < 3; n++)this._matrix[e][n] = t } get(t, e) { return this._matrix[t][e] } transpose() { let t = this._matrix[1][0]; return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this } matches(t) { if (9 !== t.length) throw new gh("Should be length 9: " + t); for (let e = 0; e < 3; e++)for (let n = 0; n < 3; n++)if (!Bf.matches(this._matrix[e][n], t.charAt(3 * e + n))) return !1; return !0 } add(t) { for (let e = 0; e < 3; e++)for (let n = 0; n < 3; n++)this.setAtLeast(e, n, t.get(e, n)) } isDisjoint() { return this._matrix[Gc.INTERIOR][Gc.INTERIOR] === Yh.FALSE && this._matrix[Gc.INTERIOR][Gc.BOUNDARY] === Yh.FALSE && this._matrix[Gc.BOUNDARY][Gc.INTERIOR] === Yh.FALSE && this._matrix[Gc.BOUNDARY][Gc.BOUNDARY] === Yh.FALSE } isCrosses(t, e) { return t === Yh.P && e === Yh.L || t === Yh.P && e === Yh.A || t === Yh.L && e === Yh.A ? Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) && Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.EXTERIOR]) : t === Yh.L && e === Yh.P || t === Yh.A && e === Yh.P || t === Yh.A && e === Yh.L ? Bf.isTrue(this._matrix[Gc.INTERIOR][Gc.INTERIOR]) && Bf.isTrue(this._matrix[Gc.EXTERIOR][Gc.INTERIOR]) : t === Yh.L && e === Yh.L && 0 === this._matrix[Gc.INTERIOR][Gc.INTERIOR] } get interfaces_() { return [vh] } } class Yf { constructor() { Yf.constructor_.apply(this, arguments) } static constructor_() { if (this._data = null, this._size = 0, 0 === arguments.length) Yf.constructor_.call(this, 10); else if (1 === arguments.length) { const t = arguments[0]; this._data = new Array(t).fill(null) } } size() { return this._size } addAll(t) { return null === t || 0 === t.length ? null : (this.ensureCapacity(this._size + t.length), Ec.arraycopy(t, 0, this._data, this._size, t.length), void (this._size += t.length)) } ensureCapacity(t) { if (t <= this._data.length) return null; const e = Math.max(t, 2 * this._data.length); this._data = tc.copyOf(this._data, e) } toArray() { const t = new Array(this._size).fill(null); return Ec.arraycopy(this._data, 0, t, 0, this._size), t } add(t) { this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size } } class qf { static toIntArray(t) { const e = new Array(t.size()).fill(null); for (let n = 0; n < e.length; n++)e[n] = t.get(n).intValue(); return e } getChainStartIndices(t) { let e = 0; const n = new Yf(Math.trunc(t.length / 2)); n.add(e); do { const i = this.findChainEnd(t, e); n.add(i), e = i } while (e < t.length - 1); return n.toArray() } findChainEnd(t, e) { const n = Du.quadrant(t[e], t[e + 1]); let i = e + 1; for (; i < t.length;) { if (Du.quadrant(t[i - 1], t[i]) !== n) break; i++ } return i - 1 } OLDgetChainStartIndices(t) { let e = 0; const n = new Qh; n.add(e); do { const i = this.findChainEnd(t, e); n.add(i), e = i } while (e < t.length - 1); return qf.toIntArray(n) } } class Xf { constructor() { Xf.constructor_.apply(this, arguments) } static constructor_() { this.e = null, this.pts = null, this.startIndex = null; const t = arguments[0]; this.e = t, this.pts = t.getCoordinates(); const e = new qf; this.startIndex = e.getChainStartIndices(this.pts) } getCoordinates() { return this.pts } getMaxX(t) { const e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x; return e > n ? e : n } getMinX(t) { const e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x; return e < n ? e : n } computeIntersectsForChain() { if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i) } else if (6 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3], r = arguments[4], s = arguments[5]; if (e - t == 1 && r - i == 1) return s.addIntersections(this.e, t, n.e, i), null; if (!this.overlaps(t, e, n, i, r)) return null; const o = Math.trunc((t + e) / 2), a = Math.trunc((i + r) / 2); t < o && (i < a && this.computeIntersectsForChain(t, o, n, i, a, s), a < r && this.computeIntersectsForChain(t, o, n, a, r, s)), o < e && (i < a && this.computeIntersectsForChain(o, e, n, i, a, s), a < r && this.computeIntersectsForChain(o, e, n, a, r, s)) } } overlaps(t, e, n, i, r) { return Dh.intersects(this.pts[t], this.pts[e], n.pts[i], n.pts[r]) } getStartIndexes() { return this.startIndex } computeIntersects(t, e) { for (let n = 0; n < this.startIndex.length - 1; n++)for (let i = 0; i < t.startIndex.length - 1; i++)this.computeIntersectsForChain(n, t, i, e) } } class zf { constructor() { zf.constructor_.apply(this, arguments) } static constructor_() { this._depth = Array(2).fill().map(() => Array(3)); for (let t = 0; t < 2; t++)for (let e = 0; e < 3; e++)this._depth[t][e] = zf.NULL_VALUE } static depthAtLocation(t) { return t === Gc.EXTERIOR ? 0 : t === Gc.INTERIOR ? 1 : zf.NULL_VALUE } getDepth(t, e) { return this._depth[t][e] } setDepth(t, e, n) { this._depth[t][e] = n } isNull() { if (0 === arguments.length) { for (let t = 0; t < 2; t++)for (let e = 0; e < 3; e++)if (this._depth[t][e] !== zf.NULL_VALUE) return !1; return !0 } if (1 === arguments.length) { const t = arguments[0]; return this._depth[t][1] === zf.NULL_VALUE } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return this._depth[t][e] === zf.NULL_VALUE } } normalize() { for (let t = 0; t < 2; t++)if (!this.isNull(t)) { let e = this._depth[t][1]; this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0); for (let n = 1; n < 3; n++) { let i = 0; this._depth[t][n] > e && (i = 1), this._depth[t][n] = i } } } getDelta(t) { return this._depth[t][jc.RIGHT] - this._depth[t][jc.LEFT] } getLocation(t, e) { return this._depth[t][e] <= 0 ? Gc.EXTERIOR : Gc.INTERIOR } toString() { return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2] } add() { if (1 === arguments.length) { const t = arguments[0]; for (let e = 0; e < 2; e++)for (let n = 1; n < 3; n++) { const i = t.getLocation(e, n); i !== Gc.EXTERIOR && i !== Gc.INTERIOR || (this.isNull(e, n) ? this._depth[e][n] = zf.depthAtLocation(i) : this._depth[e][n] += zf.depthAtLocation(i)) } } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1]; arguments[2] === Gc.INTERIOR && this._depth[t][e]++ } } } zf.NULL_VALUE = -1; class Uf extends wu { constructor() { super(), Uf.constructor_.apply(this, arguments) } static constructor_() { if (this.pts = null, this._env = null, this.eiList = new jf(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new zf, this._depthDelta = 0, 1 === arguments.length) { const t = arguments[0]; Uf.constructor_.call(this, t, null) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this.pts = t, this._label = e } } static updateIM() { if (!(2 === arguments.length && arguments[1] instanceof Bf && arguments[0] instanceof xu)) return super.updateIM.apply(this, arguments); { const t = arguments[0], e = arguments[1]; e.setAtLeastIfValid(t.getLocation(0, jc.ON), t.getLocation(1, jc.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, jc.LEFT), t.getLocation(1, jc.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, jc.RIGHT), t.getLocation(1, jc.RIGHT), 2)) } } getDepth() { return this._depth } getCollapsedEdge() { const t = new Array(2).fill(null); t[0] = this.pts[0], t[1] = this.pts[1]; return new Uf(t, xu.toLineLabel(this._label)) } isIsolated() { return this._isIsolated } getCoordinates() { return this.pts } setIsolated(t) { this._isIsolated = t } setName(t) { this._name = t } equals(t) { if (!(t instanceof Uf)) return !1; const e = t; if (this.pts.length !== e.pts.length) return !1; let n = !0, i = !0, r = this.pts.length; for (let t = 0; t < this.pts.length; t++)if (this.pts[t].equals2D(e.pts[t]) || (n = !1), this.pts[t].equals2D(e.pts[--r]) || (i = !1), !n && !i) return !1; return !0 } getCoordinate() { if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null; if (1 === arguments.length) { const t = arguments[0]; return this.pts[t] } } print(t) { t.print("edge " + this._name + ": "), t.print("LINESTRING ("); for (let e = 0; e < this.pts.length; e++)e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y); t.print(")  " + this._label + " " + this._depthDelta) } computeIM(t) { Uf.updateIM(this._label, t) } isCollapsed() { return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2])) } isClosed() { return this.pts[0].equals(this.pts[this.pts.length - 1]) } getMaximumSegmentIndex() { return this.pts.length - 1 } getDepthDelta() { return this._depthDelta } getNumPoints() { return this.pts.length } printReverse(t) { t.print("edge " + this._name + ": "); for (let e = this.pts.length - 1; e >= 0; e--)t.print(this.pts[e] + " "); t.println("") } getMonotoneChainEdge() { return null === this._mce && (this._mce = new Xf(this)), this._mce } getEnvelope() { if (null === this._env) { this._env = new Dh; for (let t = 0; t < this.pts.length; t++)this._env.expandToInclude(this.pts[t]) } return this._env } addIntersection(t, e, n, i) { const r = new Th(t.getIntersection(i)); let s = e, o = t.getEdgeDistance(n, i); const a = s + 1; if (a < this.pts.length) { const t = this.pts[a]; r.equals2D(t) && (s = a, o = 0) } this.eiList.add(r, s, o) } toString() { const t = new Cc; t.append("edge " + this._name + ": "), t.append("LINESTRING ("); for (let e = 0; e < this.pts.length; e++)e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y); return t.append(")  " + this._label + " " + this._depthDelta), t.toString() } isPointwiseEqual(t) { if (this.pts.length !== t.pts.length) return !1; for (let e = 0; e < this.pts.length; e++)if (!this.pts[e].equals2D(t.pts[e])) return !1; return !0 } setDepthDelta(t) { this._depthDelta = t } getEdgeIntersectionList() { return this.eiList } addIntersections(t, e, n) { for (let i = 0; i < t.getIntersectionNum(); i++)this.addIntersection(t, e, n, i) } } class Vf { constructor() { Vf.constructor_.apply(this, arguments) } static constructor_() { this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Af; const t = arguments[0]; this._bufParams = t } static depthDelta(t) { const e = t.getLocation(0, jc.LEFT), n = t.getLocation(0, jc.RIGHT); return e === Gc.INTERIOR && n === Gc.EXTERIOR ? 1 : e === Gc.EXTERIOR && n === Gc.INTERIOR ? -1 : 0 } static convertSegStrings(t) { const e = new Dc, n = new Qh; for (; t.hasNext();) { const i = t.next(), r = e.createLineString(i.getCoordinates()); n.add(r) } return e.buildGeometry(n) } setWorkingPrecisionModel(t) { this._workingPrecisionModel = t } insertUniqueEdge(t) { const e = this._edgeList.findEqualEdge(t); if (null !== e) { const n = e.getLabel(); let i = t.getLabel(); e.isPointwiseEqual(t) || (i = new xu(t.getLabel()), i.flip()), n.merge(i); const r = Vf.depthDelta(i), s = e.getDepthDelta() + r; e.setDepthDelta(s) } else this._edgeList.add(t), t.setDepthDelta(Vf.depthDelta(t.getLabel())) } buildSubgraphs(t, e) { const n = new Qh; for (let i = t.iterator(); i.hasNext();) { const t = i.next(), r = t.getRightmostCoordinate(), s = new If(n).getDepth(r); t.computeDepth(s), t.findResultEdges(), n.add(t), e.add(t.getDirectedEdges(), t.getNodes()) } } createSubgraphs(t) { const e = new Qh; for (let n = t.getNodes().iterator(); n.hasNext();) { const t = n.next(); if (!t.isVisited()) { const n = new Uc; n.create(t), e.add(n) } } return Vu.sort(e, Vu.reverseOrder()), e } createEmptyResultGeometry() { return this._geomFact.createPolygon() } getNoder(t) { if (null !== this._workingNoder) return this._workingNoder; const e = new gf, n = new _u; return n.setPrecisionModel(t), e.setSegmentIntersector(new kf(n)), e } buffer(t, e) { let n = this._workingPrecisionModel; null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory(); const i = new Ef(n, this._bufParams), r = new Of(t, e, i).getCurves(); if (r.size() <= 0) return this.createEmptyResultGeometry(); this.computeNodedEdges(r, n), this._graph = new Gu(new Mf), this._graph.addEdges(this._edgeList.getEdges()); const s = this.createSubgraphs(this._graph), o = new ju(this._geomFact); this.buildSubgraphs(s, o); const a = o.getPolygons(); if (a.size() <= 0) return this.createEmptyResultGeometry(); return this._geomFact.buildGeometry(a) } computeNodedEdges(t, e) { const n = this.getNoder(e); n.computeNodes(t); for (let t = n.getNodedSubstrings().iterator(); t.hasNext();) { const e = t.next(), n = e.getCoordinates(); if (2 === n.length && n[0].equals2D(n[1])) continue; const i = e.getData(), r = new Uf(e.getCoordinates(), new xu(i)); this.insertUniqueEdge(r) } } setNoder(t) { this._workingNoder = t } } class Wf { constructor() { Wf.constructor_.apply(this, arguments) } static constructor_() { if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) { const t = arguments[0], e = arguments[1]; Wf.constructor_.call(this, t, e, 0, 0) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1]; this._noder = t, this._scaleFactor = e, this._isScaled = !this.isIntegerPrecision() } } rescale() { if (Nh(arguments[0], Hh)) { for (let t = arguments[0].iterator(); t.hasNext();) { const e = t.next(); this.rescale(e.getCoordinates()) } } else if (arguments[0] instanceof Array) { const t = arguments[0]; for (let e = 0; e < t.length; e++)t[e].x = t[e].x / this._scaleFactor + this._offsetX, t[e].y = t[e].y / this._scaleFactor + this._offsetY; 2 === t.length && t[0].equals2D(t[1]) && Ec.out.println(t) } } scale() { if (Nh(arguments[0], Hh)) { const t = arguments[0], e = new Qh(t.size()); for (let n = t.iterator(); n.hasNext();) { const t = n.next(); e.add(new lf(this.scale(t.getCoordinates()), t.getData())) } return e } if (arguments[0] instanceof Array) { const t = arguments[0], e = new Array(t.length).fill(null); for (let n = 0; n < t.length; n++)e[n] = new Th(Math.round((t[n].x - this._offsetX) * this._scaleFactor), Math.round((t[n].y - this._offsetY) * this._scaleFactor), t[n].getZ()); return Ic.removeRepeatedPoints(e) } } isIntegerPrecision() { return 1 === this._scaleFactor } getNodedSubstrings() { const t = this._noder.getNodedSubstrings(); return this._isScaled && this.rescale(t), t } computeNodes(t) { let e = t; this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e) } get interfaces_() { return [pf] } } class Hf { constructor() { Hf.constructor_.apply(this, arguments) } static constructor_() { this._li = new _u, this._segStrings = null; const t = arguments[0]; this._segStrings = t } checkEndPtVertexIntersections() { if (0 === arguments.length) for (let t = this._segStrings.iterator(); t.hasNext();) { const e = t.next().getCoordinates(); this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings) } else if (2 === arguments.length) { const t = arguments[0]; for (let e = arguments[1].iterator(); e.hasNext();) { const n = e.next().getCoordinates(); for (let e = 1; e < n.length - 1; e++)if (n[e].equals(t)) throw new Ih("found endpt/interior pt intersection at index " + e + " :pt " + t) } } } checkInteriorIntersections() { if (0 === arguments.length) for (let t = this._segStrings.iterator(); t.hasNext();) { const e = t.next(); for (let t = this._segStrings.iterator(); t.hasNext();) { const n = t.next(); this.checkInteriorIntersections(e, n) } } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1], n = t.getCoordinates(), i = e.getCoordinates(); for (let r = 0; r < n.length - 1; r++)for (let n = 0; n < i.length - 1; n++)this.checkInteriorIntersections(t, r, e, n) } else if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3]; if (t === n && e === i) return null; const r = t.getCoordinates()[e], s = t.getCoordinates()[e + 1], o = n.getCoordinates()[i], a = n.getCoordinates()[i + 1]; if (this._li.computeIntersection(r, s, o, a), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, r, s) || this.hasInteriorIntersection(this._li, o, a))) throw new Ih("found non-noded intersection at " + r + "-" + s + " and " + o + "-" + a) } } checkValid() { this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses() } checkCollapses() { if (0 === arguments.length) for (let t = this._segStrings.iterator(); t.hasNext();) { const e = t.next(); this.checkCollapses(e) } else if (1 === arguments.length) { const t = arguments[0].getCoordinates(); for (let e = 0; e < t.length - 2; e++)this.checkCollapse(t[e], t[e + 1], t[e + 2]) } } hasInteriorIntersection(t, e, n) { for (let i = 0; i < t.getIntersectionNum(); i++) { const r = t.getIntersection(i); if (!r.equals(e) && !r.equals(n)) return !0 } return !1 } checkCollapse(t, e, n) { if (t.equals(n)) throw new Ih("found non-noded collapse at " + Hf.fact.createLineString([t, e, n])) } } Hf.fact = new Dc; class Kf { constructor() { Kf.constructor_.apply(this, arguments) } static constructor_() { this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null; const t = arguments[0], e = arguments[1], n = arguments[2]; if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new gh("Scale factor must be non-zero"); 1 !== e && (this._pt = new Th(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new Th, this._p1Scaled = new Th), this.initCorners(this._pt) } intersectsScaled(t, e) { const n = Math.min(t.x, e.x), i = Math.max(t.x, e.x), r = Math.min(t.y, e.y), s = Math.max(t.y, e.y), o = this._maxx < n || this._minx > i || this._maxy < r || this._miny > s; if (o) return !1; const a = this.intersectsToleranceSquare(t, e); return wh.isTrue(!(o && a), "Found bad envelope test"), a } initCorners(t) { this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new Th(this._maxx, this._maxy), this._corner[1] = new Th(this._minx, this._maxy), this._corner[2] = new Th(this._minx, this._miny), this._corner[3] = new Th(this._maxx, this._miny) } intersects(t, e) { return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled)) } scale(t) { return Math.round(t * this._scaleFactor) } getCoordinate() { return this._originalPt } copyScaled(t, e) { e.x = this.scale(t.x), e.y = this.scale(t.y) } getSafeEnvelope() { if (null === this._safeEnv) { const t = Kf.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor; this._safeEnv = new Dh(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t) } return this._safeEnv } intersectsPixelClosure(t, e) { return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection()))) } intersectsToleranceSquare(t, e) { let n = !1, i = !1; return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n || !i) || (!!t.equals(this._pt) || !!e.equals(this._pt)))))) } addSnappedNode(t, e) { const n = t.getCoordinate(e), i = t.getCoordinate(e + 1); return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0) } } Kf.SAFE_ENV_EXPANSION_FACTOR = .75; class Zf { constructor() { Zf.constructor_.apply(this, arguments) } static constructor_() { this.selectedSegment = new hf } select() { if (1 === arguments.length) { } else if (2 === arguments.length) { const t = arguments[1]; arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment) } } } class Jf { constructor() { Jf.constructor_.apply(this, arguments) } static constructor_() { this._index = null; const t = arguments[0]; this._index = t } snap() { if (1 === arguments.length) { const t = arguments[0]; return this.snap(t, null, -1) } if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = t.getSafeEnvelope(), r = new Qf(t, e, n); return this._index.query(i, new class { get interfaces_() { return [Ku] } visitItem(t) { t.select(i, r) } }), r.isNodeAdded() } } } class Qf extends Zf { constructor() { super(), Qf.constructor_.apply(this, arguments) } static constructor_() { this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1; const t = arguments[0], e = arguments[1], n = arguments[2]; this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n } isNodeAdded() { return this._isNodeAdded } select() { if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof uf)) return super.select.apply(this, arguments); { const t = arguments[1], e = arguments[0].getContext(); if (this._parentEdge === e && (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)) return null; this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t) } } } Jf.HotPixelSnapAction = Qf; class $f { constructor() { $f.constructor_.apply(this, arguments) } static constructor_() { this._li = null, this._interiorIntersections = null; const t = arguments[0]; this._li = t, this._interiorIntersections = new Qh } processIntersections(t, e, n, i) { if (t === n && e === i) return null; const r = t.getCoordinates()[e], s = t.getCoordinates()[e + 1], o = n.getCoordinates()[i], a = n.getCoordinates()[i + 1]; if (this._li.computeIntersection(r, s, o, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) { for (let t = 0; t < this._li.getIntersectionNum(); t++)this._interiorIntersections.add(this._li.getIntersection(t)); t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1) } } isDone() { return !1 } getInteriorIntersections() { return this._interiorIntersections } get interfaces_() { return [Ff] } } class tp { constructor() { tp.constructor_.apply(this, arguments) } static constructor_() { this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null; const t = arguments[0]; this._pm = t, this._li = new _u, this._li.setPrecisionModel(t), this._scaleFactor = t.getScale() } checkCorrectness(t) { const e = lf.getNodedSubstrings(t), n = new Hf(e); try { n.checkValid() } catch (t) { if (!(t instanceof dh)) throw t; t.printStackTrace() } } getNodedSubstrings() { return lf.getNodedSubstrings(this._nodedSegStrings) } snapRound(t, e) { const n = this.findInteriorIntersections(t, e); this.computeIntersectionSnaps(n), this.computeVertexSnaps(t) } findInteriorIntersections(t, e) { const n = new $f(e); return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections() } computeVertexSnaps() { if (Nh(arguments[0], Hh)) { for (let t = arguments[0].iterator(); t.hasNext();) { const e = t.next(); this.computeVertexSnaps(e) } } else if (arguments[0] instanceof lf) { const t = arguments[0], e = t.getCoordinates(); for (let n = 0; n < e.length; n++) { const i = new Kf(e[n], this._scaleFactor, this._li); this._pointSnapper.snap(i, t, n) && t.addIntersection(e[n], n) } } } computeNodes(t) { this._nodedSegStrings = t, this._noder = new gf, this._pointSnapper = new Jf(this._noder.getIndex()), this.snapRound(t, this._li) } computeIntersectionSnaps(t) { for (let e = t.iterator(); e.hasNext();) { const t = e.next(), n = new Kf(t, this._scaleFactor, this._li); this._pointSnapper.snap(n) } } get interfaces_() { return [pf] } } class ep { constructor() { ep.constructor_.apply(this, arguments) } static constructor_() { if (this._argGeom = null, this._distance = null, this._bufParams = new kc, this._resultGeometry = null, this._saveException = null, 1 === arguments.length) { const t = arguments[0]; this._argGeom = t } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this._argGeom = t, this._bufParams = e } } static bufferOp() { if (2 === arguments.length) { const t = arguments[1]; return new ep(arguments[0]).getResultGeometry(t) } if (3 === arguments.length) { if (Number.isInteger(arguments[2]) && arguments[0] instanceof Ah && "number" == typeof arguments[1]) { const t = arguments[1], e = arguments[2], n = new ep(arguments[0]); n.setQuadrantSegments(e); return n.getResultGeometry(t) } if (arguments[2] instanceof kc && arguments[0] instanceof Ah && "number" == typeof arguments[1]) { const t = arguments[1]; return new ep(arguments[0], arguments[2]).getResultGeometry(t) } } else if (4 === arguments.length) { const t = arguments[1], e = arguments[2], n = arguments[3], i = new ep(arguments[0]); i.setQuadrantSegments(e), i.setEndCapStyle(n); return i.getResultGeometry(t) } } static precisionScaleFactor(t, e, n) { const i = t.getEnvelopeInternal(), r = xc.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())) + 2 * (e > 0 ? e : 0), s = n - Math.trunc(Math.log(r) / Math.log(10) + 1); return Math.pow(10, s) } bufferFixedPrecision(t) { const e = new Wf(new tp(new Lc(1)), t.getScale()), n = new Vf(this._bufParams); n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance) } bufferReducedPrecision() { if (0 === arguments.length) { for (let t = ep.MAX_PRECISION_DIGITS; t >= 0; t--) { try { this.bufferReducedPrecision(t) } catch (t) { if (!(t instanceof Xc)) throw t; this._saveException = t } if (null !== this._resultGeometry) return null } throw this._saveException } if (1 === arguments.length) { const t = arguments[0], e = ep.precisionScaleFactor(this._argGeom, this._distance, t), n = new Lc(e); this.bufferFixedPrecision(n) } } computeGeometry() { if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null; const t = this._argGeom.getFactory().getPrecisionModel(); t.getType() === Lc.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision() } setQuadrantSegments(t) { this._bufParams.setQuadrantSegments(t) } bufferOriginalPrecision() { try { const t = new Vf(this._bufParams); this._resultGeometry = t.buffer(this._argGeom, this._distance) } catch (t) { if (!(t instanceof Ih)) throw t; this._saveException = t } } getResultGeometry(t) { return this._distance = t, this.computeGeometry(), this._resultGeometry } setEndCapStyle(t) { this._bufParams.setEndCapStyle(t) } } ep.CAP_ROUND = kc.CAP_ROUND, ep.CAP_BUTT = kc.CAP_FLAT, ep.CAP_FLAT = kc.CAP_FLAT, ep.CAP_SQUARE = kc.CAP_SQUARE, ep.MAX_PRECISION_DIGITS = 12; var np = n(2), ip = n.n(np); function rp(t) { return (rp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function sp(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function op(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ap(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function lp(t, e, n) { return (lp = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = fp(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function hp(t, e) { return (hp = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function cp(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = fp(t); if (e) { var r = fp(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return up(this, n) } } function up(t, e) { return !e || "object" !== rp(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function fp(t) { return (fp = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var pp = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && hp(t, e) }(s, t); var e, n, i, r = cp(s); function s(t) { var e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), (e = r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? sp(Object(n), !0).forEach((function (e) { op(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sp(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Buffer geometry", className: "ole-control-buffer", image: ip.a, buffer: 50 }, t))).selectInteraction = new Yl({ layers: e.layerFilter, hitTolerance: void 0 === t.hitTolerance ? 10 : t.hitTolerance, multi: void 0 === t.multi || t.multi, style: t.style }), e } return e = s, (n = [{ key: "getDialogTemplate", value: function () { return '\n      <label>Buffer width: &nbsp;\n        <input type="text" id="buffer-width"\n          value="'.concat(this.properties.buffer, '"\n        />\n      </label>\n      <input type="button" value="OK" id="buffer-btn" />\n    ') } }, { key: "buffer", value: function (t) { var e = new Fc; e.inject(Ki, vr, Cr, Pr, Fr, Pa, Da); for (var n = this.selectInteraction.getFeatures().getArray(), i = 0; i < n.length; i += 1) { var r = e.read(n[i].getGeometry()), s = new ep(r).getResultGeometry(t); n[i].setGeometry(e.write(s)) } } }, { key: "activate", value: function () { var t = this; this.map.addInteraction(this.selectInteraction), lp(fp(s.prototype), "activate", this).call(this), document.getElementById("buffer-width").addEventListener("change", (function (e) { t.setProperties({ buffer: e.target.value }) })), document.getElementById("buffer-btn").addEventListener("click", (function () { var e = document.getElementById("buffer-width"), n = parseInt(e.value, 10); n && t.buffer(n) })) } }, { key: "deactivate", value: function () { this.map.removeInteraction(this.selectInteraction), lp(fp(s.prototype), "deactivate", this).call(this) } }]) && ap(e.prototype, n), i && ap(e, i), s }(Dn); class dp { constructor() { dp.constructor_.apply(this, arguments) } static constructor_() { this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1 } transformPoint(t, e) { return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t)) } transformPolygon(t, e) { let n = !0; const i = this.transformLinearRing(t.getExteriorRing(), t); null !== i && i instanceof dc && !i.isEmpty() || (n = !1); const r = new Qh; for (let e = 0; e < t.getNumInteriorRing(); e++) { const i = this.transformLinearRing(t.getInteriorRingN(e), t); null === i || i.isEmpty() || (i instanceof dc || (n = !1), r.add(i)) } if (n) return this._factory.createPolygon(i, r.toArray([])); { const t = new Qh; return null !== i && t.add(i), t.addAll(r), this._factory.buildGeometry(t) } } createCoordinateSequence(t) { return this._factory.getCoordinateSequenceFactory().create(t) } getInputGeometry() { return this._inputGeom } transformMultiLineString(t, e) { const n = new Qh; for (let e = 0; e < t.getNumGeometries(); e++) { const i = this.transformLineString(t.getGeometryN(e), t); null !== i && (i.isEmpty() || n.add(i)) } return this._factory.buildGeometry(n) } transformCoordinates(t, e) { return this.copy(t) } transformLineString(t, e) { return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t)) } transformMultiPoint(t, e) { const n = new Qh; for (let e = 0; e < t.getNumGeometries(); e++) { const i = this.transformPoint(t.getGeometryN(e), t); null !== i && (i.isEmpty() || n.add(i)) } return this._factory.buildGeometry(n) } transformMultiPolygon(t, e) { const n = new Qh; for (let e = 0; e < t.getNumGeometries(); e++) { const i = this.transformPolygon(t.getGeometryN(e), t); null !== i && (i.isEmpty() || n.add(i)) } return this._factory.buildGeometry(n) } copy(t) { return t.copy() } transformGeometryCollection(t, e) { const n = new Qh; for (let e = 0; e < t.getNumGeometries(); e++) { const i = this.transform(t.getGeometryN(e)); null !== i && (this._pruneEmptyGeometry && i.isEmpty() || n.add(i)) } return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(Dc.toGeometryArray(n)) : this._factory.buildGeometry(n) } transform(t) { if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Vh) return this.transformPoint(t, null); if (t instanceof pc) return this.transformMultiPoint(t, null); if (t instanceof dc) return this.transformLinearRing(t, null); if (t instanceof zh) return this.transformLineString(t, null); if (t instanceof Mc) return this.transformMultiLineString(t, null); if (t instanceof ac) return this.transformPolygon(t, null); if (t instanceof bc) return this.transformMultiPolygon(t, null); if (t instanceof fc) return this.transformGeometryCollection(t, null); throw new gh("Unknown Geometry subtype: " + t.getGeometryType()) } transformLinearRing(t, e) { const n = this.transformCoordinates(t.getCoordinateSequence(), t); if (null === n) return this._factory.createLinearRing(null); const i = n.size(); return i > 0 && i < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n) } } class gp { constructor() { gp.constructor_.apply(this, arguments) } static constructor_() { if (this._snapTolerance = 0, this._srcPts = null, this._seg = new hf, this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof zh && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; gp.constructor_.call(this, t.getCoordinates(), e) } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) { const t = arguments[0], e = arguments[1]; this._srcPts = t, this._isClosed = gp.isClosed(t), this._snapTolerance = e } } static isClosed(t) { return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]) } snapVertices(t, e) { const n = this._isClosed ? t.size() - 1 : t.size(); for (let i = 0; i < n; i++) { const n = t.get(i), r = this.findSnapForVertex(n, e); null !== r && (t.set(i, new Th(r)), 0 === i && this._isClosed && t.set(t.size() - 1, new Th(r))) } } findSnapForVertex(t, e) { for (let n = 0; n < e.length; n++) { if (t.equals2D(e[n])) return null; if (t.distance(e[n]) < this._snapTolerance) return e[n] } return null } snapTo(t) { const e = new vc(this._srcPts); this.snapVertices(e, t), this.snapSegments(e, t); return e.toCoordinateArray() } snapSegments(t, e) { if (0 === e.length) return null; let n = e.length; e[0].equals2D(e[e.length - 1]) && (n = e.length - 1); for (let i = 0; i < n; i++) { const n = e[i], r = this.findSegmentIndexToSnap(n, t); r >= 0 && t.add(r + 1, new Th(n), !1) } } findSegmentIndexToSnap(t, e) { let n = yh.MAX_VALUE, i = -1; for (let r = 0; r < e.size() - 1; r++) { if (this._seg.p0 = e.get(r), this._seg.p1 = e.get(r + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) { if (this._allowSnappingToSourceVertices) continue; return -1 } const s = this._seg.distance(t); s < this._snapTolerance && s < n && (n = s, i = r) } return i } setAllowSnappingToSourceVertices(t) { this._allowSnappingToSourceVertices = t } } class _p { constructor() { _p.constructor_.apply(this, arguments) } static constructor_() { this._srcGeom = null; const t = arguments[0]; this._srcGeom = t } static snap(t, e, n) { const i = new Array(2).fill(null), r = new _p(t); i[0] = r.snapTo(e, n); const s = new _p(e); return i[1] = s.snapTo(i[0], n), i } static computeOverlaySnapTolerance() { if (1 === arguments.length) { const t = arguments[0]; let e = _p.computeSizeBasedSnapTolerance(t); const n = t.getPrecisionModel(); if (n.getType() === Lc.FIXED) { const t = 1 / n.getScale() * 2 / 1.415; t > e && (e = t) } return e } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return Math.min(_p.computeOverlaySnapTolerance(t), _p.computeOverlaySnapTolerance(e)) } } static computeSizeBasedSnapTolerance(t) { const e = t.getEnvelopeInternal(); return Math.min(e.getHeight(), e.getWidth()) * _p.SNAP_PRECISION_FACTOR } static snapToSelf(t, e, n) { return new _p(t).snapToSelf(e, n) } snapTo(t, e) { const n = this.extractTargetCoordinates(t); return new yp(e, n).transform(this._srcGeom) } snapToSelf(t, e) { const n = this.extractTargetCoordinates(this._srcGeom), i = new yp(t, n, !0).transform(this._srcGeom); let r = i; return e && Nh(r, oc) && (r = i.buffer(0)), r } computeSnapTolerance(t) { return this.computeMinimumSegmentLength(t) / 10 } extractTargetCoordinates(t) { const e = new cc, n = t.getCoordinates(); for (let t = 0; t < n.length; t++)e.add(n[t]); return e.toArray(new Array(0).fill(null)) } computeMinimumSegmentLength(t) { let e = yh.MAX_VALUE; for (let n = 0; n < t.length - 1; n++) { const i = t[n].distance(t[n + 1]); i < e && (e = i) } return e } } _p.SNAP_PRECISION_FACTOR = 1e-9; class yp extends dp { constructor() { super(), yp.constructor_.apply(this, arguments) } static constructor_() { if (this._snapTolerance = null, this._snapPts = null, this._isSelfSnap = !1, 2 === arguments.length) { const t = arguments[0], e = arguments[1]; this._snapTolerance = t, this._snapPts = e } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._snapTolerance = t, this._snapPts = e, this._isSelfSnap = n } } snapLine(t, e) { const n = new gp(t, this._snapTolerance); return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e) } transformCoordinates(t, e) { const n = t.toCoordinateArray(), i = this.snapLine(n, this._snapPts); return this._factory.getCoordinateSequenceFactory().create(i) } } class mp { isInBoundary(t) { } } class vp { isInBoundary(t) { return t % 2 == 1 } get interfaces_() { return [mp] } } class xp { isInBoundary(t) { return t > 0 } get interfaces_() { return [mp] } } class Ep { isInBoundary(t) { return t > 1 } get interfaces_() { return [mp] } } class Ip { isInBoundary(t) { return 1 === t } get interfaces_() { return [mp] } } mp.Mod2BoundaryNodeRule = vp, mp.EndPointBoundaryNodeRule = xp, mp.MultiValentEndPointBoundaryNodeRule = Ep, mp.MonoValentEndPointBoundaryNodeRule = Ip, mp.MOD2_BOUNDARY_RULE = new vp, mp.ENDPOINT_BOUNDARY_RULE = new xp, mp.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new Ep, mp.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new Ip, mp.OGC_SFS_BOUNDARY_RULE = mp.MOD2_BOUNDARY_RULE; class Cp { constructor() { Cp.constructor_.apply(this, arguments) } static constructor_() { if (this._boundaryRule = mp.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length); else if (1 === arguments.length) { const t = arguments[0]; if (null === t) throw new gh("Rule must be non-null"); this._boundaryRule = t } } locateInPolygonRing(t, e) { return e.getEnvelopeInternal().intersects(t) ? mu.locateInRing(t, e.getCoordinates()) : Gc.EXTERIOR } intersects(t, e) { return this.locate(t, e) !== Gc.EXTERIOR } updateLocationInfo(t) { t === Gc.INTERIOR && (this._isIn = !0), t === Gc.BOUNDARY && this._numBoundaries++ } computeLocation(t, e) { if (e instanceof Vh && this.updateLocationInfo(this.locateOnPoint(t, e)), e instanceof zh) this.updateLocationInfo(this.locateOnLineString(t, e)); else if (e instanceof ac) this.updateLocationInfo(this.locateInPolygon(t, e)); else if (e instanceof Mc) { const n = e; for (let e = 0; e < n.getNumGeometries(); e++) { const i = n.getGeometryN(e); this.updateLocationInfo(this.locateOnLineString(t, i)) } } else if (e instanceof bc) { const n = e; for (let e = 0; e < n.getNumGeometries(); e++) { const i = n.getGeometryN(e); this.updateLocationInfo(this.locateInPolygon(t, i)) } } else if (e instanceof fc) { const n = new Rf(e); for (; n.hasNext();) { const i = n.next(); i !== e && this.computeLocation(t, i) } } } locateOnPoint(t, e) { return e.getCoordinate().equals2D(t) ? Gc.INTERIOR : Gc.EXTERIOR } locateOnLineString(t, e) { if (!e.getEnvelopeInternal().intersects(t)) return Gc.EXTERIOR; const n = e.getCoordinateSequence(); return e.isClosed() || !t.equals(n.getCoordinate(0)) && !t.equals(n.getCoordinate(n.size() - 1)) ? mu.isOnLine(t, n) ? Gc.INTERIOR : Gc.EXTERIOR : Gc.BOUNDARY } locateInPolygon(t, e) { if (e.isEmpty()) return Gc.EXTERIOR; const n = e.getExteriorRing(), i = this.locateInPolygonRing(t, n); if (i === Gc.EXTERIOR) return Gc.EXTERIOR; if (i === Gc.BOUNDARY) return Gc.BOUNDARY; for (let n = 0; n < e.getNumInteriorRing(); n++) { const i = e.getInteriorRingN(n), r = this.locateInPolygonRing(t, i); if (r === Gc.INTERIOR) return Gc.EXTERIOR; if (r === Gc.BOUNDARY) return Gc.BOUNDARY } return Gc.INTERIOR } locate(t, e) { return e.isEmpty() ? Gc.EXTERIOR : e instanceof zh ? this.locateOnLineString(t, e) : e instanceof ac ? this.locateInPolygon(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? Gc.BOUNDARY : this._numBoundaries > 0 || this._isIn ? Gc.INTERIOR : Gc.EXTERIOR) } } class wp { constructor() { wp.constructor_.apply(this, arguments) } static constructor_() { this._pts = null, this._data = null; const t = arguments[0], e = arguments[1]; this._pts = t, this._data = e } getCoordinates() { return this._pts } size() { return this._pts.length } getCoordinate(t) { return this._pts[t] } isClosed() { return this._pts[0].equals(this._pts[this._pts.length - 1]) } getSegmentOctant(t) { return t === this._pts.length - 1 ? -1 : sf.octant(this.getCoordinate(t), this.getCoordinate(t + 1)) } setData(t) { this._data = t } getData() { return this._data } toString() { return du.toLineString(new wc(this._pts)) } get interfaces_() { return [of] } } class Sp { constructor() { Sp.constructor_.apply(this, arguments) } static constructor_() { this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._keepIntersections = !0, this._isInteriorIntersectionsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Qh, this._intersectionCount = 0; const t = arguments[0]; this._li = t, this._interiorIntersection = null } static createAllIntersectionsFinder(t) { const e = new Sp(t); return e.setFindAllIntersections(!0), e } static isInteriorVertexIntersection() { if (4 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[3]; return (!arguments[2] || !n) && !!t.equals2D(e) } if (8 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3], r = arguments[4], s = arguments[5], o = arguments[6], a = arguments[7]; return !!Sp.isInteriorVertexIntersection(t, n, r, o) || (!!Sp.isInteriorVertexIntersection(t, i, r, a) || (!!Sp.isInteriorVertexIntersection(e, n, s, o) || !!Sp.isInteriorVertexIntersection(e, i, s, a))) } } static createInteriorIntersectionCounter(t) { const e = new Sp(t); return e.setInteriorIntersectionsOnly(!0), e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e } static createIntersectionCounter(t) { const e = new Sp(t); return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e } static isEndSegment(t, e) { return 0 === e || e >= t.size() - 2 } static createAnyIntersectionFinder(t) { return new Sp(t) } static createInteriorIntersectionsFinder(t) { const e = new Sp(t); return e.setFindAllIntersections(!0), e.setInteriorIntersectionsOnly(!0), e } setCheckEndSegmentsOnly(t) { this._isCheckEndSegmentsOnly = t } getIntersectionSegments() { return this._intSegments } count() { return this._intersectionCount } getIntersections() { return this._intersections } setFindAllIntersections(t) { this._findAllIntersections = t } setKeepIntersections(t) { this._keepIntersections = t } getIntersection() { return this._interiorIntersection } processIntersections(t, e, n, i) { if (!this._findAllIntersections && this.hasIntersection()) return null; const r = t === n; if (r && e === i) return null; if (this._isCheckEndSegmentsOnly) { if (!(Sp.isEndSegment(t, e) || Sp.isEndSegment(n, i))) return null } const s = t.getCoordinate(e), o = t.getCoordinate(e + 1), a = n.getCoordinate(i), l = n.getCoordinate(i + 1), h = 0 === e, c = e + 2 === t.size(), u = 0 === i, f = i + 2 === n.size(); this._li.computeIntersection(s, o, a, l); const p = this._li.hasIntersection() && this._li.isInteriorIntersection(); let d = !1; if (!this._isInteriorIntersectionsOnly) { d = !(r && Math.abs(i - e) <= 1) && Sp.isInteriorVertexIntersection(s, o, a, l, h, c, u, f) } (p || d) && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = s, this._intSegments[1] = o, this._intSegments[2] = a, this._intSegments[3] = l, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++) } hasIntersection() { return null !== this._interiorIntersection } isDone() { return !this._findAllIntersections && null !== this._interiorIntersection } setInteriorIntersectionsOnly(t) { this._isInteriorIntersectionsOnly = t } get interfaces_() { return [Ff] } } class bp { constructor() { bp.constructor_.apply(this, arguments) } static constructor_() { this._li = new _u, this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0; const t = arguments[0]; this._segStrings = t } static computeIntersections(t) { const e = new bp(t); return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections() } execute() { if (null !== this._segInt) return null; this.checkInteriorIntersections() } getIntersections() { return this._segInt.getIntersections() } isValid() { return this.execute(), this._isValid } setFindAllIntersections(t) { this._findAllIntersections = t } checkInteriorIntersections() { this._isValid = !0, this._segInt = new Sp(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections); const t = new gf; if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null } checkValid() { if (this.execute(), !this._isValid) throw new Xc(this.getErrorMessage(), this._segInt.getIntersection()) } getErrorMessage() { if (this._isValid) return "no intersections found"; const t = this._segInt.getIntersectionSegments(); return "found non-noded intersection between " + du.toLineString(t[0], t[1]) + " and " + du.toLineString(t[2], t[3]) } } class Op { constructor() { Op.constructor_.apply(this, arguments) } static constructor_() { this._nv = null; const t = arguments[0]; this._nv = new bp(Op.toSegmentStrings(t)) } static toSegmentStrings(t) { const e = new Qh; for (let n = t.iterator(); n.hasNext();) { const t = n.next(); e.add(new wp(t.getCoordinates(), t)) } return e } static checkValid(t) { new Op(t).checkValid() } checkValid() { this._nv.checkValid() } } class Tp { constructor() { Tp.constructor_.apply(this, arguments) } static constructor_() { this._mapOp = null; const t = arguments[0]; this._mapOp = t } static map(t, e) { return new Tp(e).map(t) } map(t) { const e = new Qh; for (let n = 0; n < t.getNumGeometries(); n++) { const i = this._mapOp.map(t.getGeometryN(n)); i.isEmpty() || e.add(i) } return t.getFactory().createGeometryCollection(Dc.toGeometryArray(e)) } } class Rp { constructor() { Rp.constructor_.apply(this, arguments) } static constructor_() { this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Qh, this._resultLineList = new Qh; const t = arguments[0], e = arguments[1], n = arguments[2]; this._op = t, this._geometryFactory = e, this._ptLocator = n } collectLines(t) { for (let e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) { const n = e.next(); this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList) } } labelIsolatedLine(t, e) { const n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e)); t.getLabel().setLocation(e, n) } build(t) { return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList } collectLineEdge(t, e, n) { const i = t.getLabel(), r = t.getEdge(); t.isLineEdge() && (t.isVisited() || !Qp.isResultOfOp(i, e) || r.isCovered() || (n.add(r), t.setVisitedEdge(!0))) } findCoveredLineEdges() { for (let t = this._op.getGraph().getNodes().iterator(); t.hasNext();) { t.next().getEdges().findCoveredLineEdges() } for (let t = this._op.getGraph().getEdgeEnds().iterator(); t.hasNext();) { const e = t.next(), n = e.getEdge(); if (e.isLineEdge() && !n.isCoveredSet()) { const t = this._op.isCoveredByA(e.getCoordinate()); n.setCovered(t) } } } labelIsolatedLines(t) { for (let e = t.iterator(); e.hasNext();) { const t = e.next(), n = t.getLabel(); t.isIsolated() && (n.isNull(0) ? this.labelIsolatedLine(t, 0) : this.labelIsolatedLine(t, 1)) } } buildLines(t) { for (let t = this._lineEdgesList.iterator(); t.hasNext();) { const e = t.next(), n = this._geometryFactory.createLineString(e.getCoordinates()); this._resultLineList.add(n), e.setInResult(!0) } } collectBoundaryTouchEdge(t, e, n) { const i = t.getLabel(); return t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult() ? null : (wh.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Qp.isResultOfOp(i, e) && e === Qp.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0)))) } } class Np { constructor() { Np.constructor_.apply(this, arguments) } static constructor_() { this._op = null, this._geometryFactory = null, this._resultPointList = new Qh; const t = arguments[0], e = arguments[1]; this._op = t, this._geometryFactory = e } filterCoveredNodeToPoint(t) { const e = t.getCoordinate(); if (!this._op.isCoveredByLA(e)) { const t = this._geometryFactory.createPoint(e); this._resultPointList.add(t) } } extractNonCoveredResultNodes(t) { for (let e = this._op.getGraph().getNodes().iterator(); e.hasNext();) { const n = e.next(); if (!n.isInResult() && (!n.isIncidentEdgeInResult() && (0 === n.getEdges().getDegree() || t === Qp.INTERSECTION))) { const e = n.getLabel(); Qp.isResultOfOp(e, t) && this.filterCoveredNodeToPoint(n) } } } build(t) { return this.extractNonCoveredResultNodes(t), this._resultPointList } } class Lp { constructor() { this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = new _h, this._commonSignExp = null } getCommon() { return yh.longBitsToDouble(this._commonBits) } add(t) { const e = yh.doubleToLongBits(t); if (this._isFirst) return this._commonBits = e, this._commonSignExp = Lp.signExpBits(this._commonBits), this._isFirst = !1, null; if (Lp.signExpBits(e) !== this._commonSignExp) return this._commonBits.high = 0, this._commonBits.low = 0, null; this._commonMantissaBitsCount = Lp.numCommonMostSigMantissaBits(this._commonBits, e), this._commonBits = Lp.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount)) } toString() { if (1 === arguments.length) { const t = arguments[0], e = yh.longBitsToDouble(t), n = "0000000000000000000000000000000000000000000000000000000000000000" + _h.toBinaryString(t), i = n.substring(n.length - 64); return i.substring(0, 1) + "  " + i.substring(1, 12) + "(exp) " + i.substring(12) + " [ " + e + " ]" } } getClass() { return Lp } get interfaces_() { return [] } static getBit(t, e) { const n = 1 << e % 32; return e < 32 ? 0 != (t.low & n) ? 1 : 0 : 0 != (t.high & n) ? 1 : 0 } static signExpBits(t) { return t.high >>> 20 } static zeroLowerBits(t, e) { let n = "low"; if (e > 32 && (t.low = 0, e %= 32, n = "high"), e > 0) { const i = e < 32 ? ~((1 << e) - 1) : 0; t[n] &= i } return t } static numCommonMostSigMantissaBits(t, e) { let n = 0; for (let i = 52; i >= 0; i--) { if (Lp.getBit(t, i) !== Lp.getBit(e, i)) return n; n++ } return 52 } } class Pp { constructor() { Pp.constructor_.apply(this, arguments) } static constructor_() { this._commonCoord = null, this._ccFilter = new Mp } addCommonBits(t) { const e = new Dp(this._commonCoord); t.apply(e), t.geometryChanged() } removeCommonBits(t) { if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t; const e = new Th(this._commonCoord); e.x = -e.x, e.y = -e.y; const n = new Dp(e); return t.apply(n), t.geometryChanged(), t } getCommonCoordinate() { return this._commonCoord } add(t) { t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate() } } class Mp { constructor() { Mp.constructor_.apply(this, arguments) } static constructor_() { this._commonBitsX = new Lp, this._commonBitsY = new Lp } filter(t) { this._commonBitsX.add(t.x), this._commonBitsY.add(t.y) } getCommonCoordinate() { return new Th(this._commonBitsX.getCommon(), this._commonBitsY.getCommon()) } get interfaces_() { return [Fh] } } class Dp { constructor() { Dp.constructor_.apply(this, arguments) } static constructor_() { this.trans = null; const t = arguments[0]; this.trans = t } filter(t, e) { const n = t.getOrdinate(e, 0) + this.trans.x, i = t.getOrdinate(e, 1) + this.trans.y; t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i) } isDone() { return !1 } isGeometryChanged() { return !0 } get interfaces_() { return [Xh] } } Pp.CommonCoordinateFilter = Mp, Pp.Translater = Dp; class Ap { constructor() { Ap.constructor_.apply(this, arguments) } static constructor_() { this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null; const t = arguments[0], e = arguments[1]; this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance() } static overlayOp(t, e, n) { return new Ap(t, e).getResultGeometry(n) } static union(t, e) { return Ap.overlayOp(t, e, Qp.UNION) } static intersection(t, e) { return Ap.overlayOp(t, e, Qp.INTERSECTION) } static symDifference(t, e) { return Ap.overlayOp(t, e, Qp.SYMDIFFERENCE) } static difference(t, e) { return Ap.overlayOp(t, e, Qp.DIFFERENCE) } selfSnap(t) { return new _p(t).snapTo(t, this._snapTolerance) } removeCommonBits(t) { this._cbr = new Pp, this._cbr.add(t[0]), this._cbr.add(t[1]); const e = new Array(2).fill(null); return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e } prepareResult(t) { return this._cbr.addCommonBits(t), t } getResultGeometry(t) { const e = this.snap(this._geom), n = Qp.overlayOp(e[0], e[1], t); return this.prepareResult(n) } checkValid(t) { t.isValid() || Ec.out.println("Snapped geometry is invalid") } computeSnapTolerance() { this._snapTolerance = _p.computeOverlaySnapTolerance(this._geom[0], this._geom[1]) } snap(t) { const e = this.removeCommonBits(t); return _p.snap(e[0], e[1], this._snapTolerance) } } class Fp { constructor() { Fp.constructor_.apply(this, arguments) } static constructor_() { this._geom = new Array(2).fill(null); const t = arguments[0], e = arguments[1]; this._geom[0] = t, this._geom[1] = e } static overlayOp(t, e, n) { return new Fp(t, e).getResultGeometry(n) } static union(t, e) { return Fp.overlayOp(t, e, Qp.UNION) } static intersection(t, e) { return Fp.overlayOp(t, e, Qp.INTERSECTION) } static symDifference(t, e) { return Fp.overlayOp(t, e, Qp.SYMDIFFERENCE) } static difference(t, e) { return Fp.overlayOp(t, e, Qp.DIFFERENCE) } getResultGeometry(t) { let e = null, n = !1, i = null; try { e = Qp.overlayOp(this._geom[0], this._geom[1], t); !0 && (n = !0) } catch (t) { if (!(t instanceof Ih)) throw t; i = t } if (!n) try { e = Ap.overlayOp(this._geom[0], this._geom[1], t) } catch (t) { throw t instanceof Ih ? i : t } return e } } class kp { constructor() { kp.constructor_.apply(this, arguments) } static constructor_() { this.mce = null, this.chainIndex = null; const t = arguments[0], e = arguments[1]; this.mce = t, this.chainIndex = e } computeIntersections(t, e) { this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e) } } class Gp { constructor() { Gp.constructor_.apply(this, arguments) } static constructor_() { if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) { const t = arguments[0], e = arguments[1]; this._eventType = Gp.DELETE, this._xValue = t, this._insertEvent = e } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._eventType = Gp.INSERT, this._label = t, this._xValue = e, this._obj = n } } isDelete() { return this._eventType === Gp.DELETE } setDeleteEventIndex(t) { this._deleteEventIndex = t } getObject() { return this._obj } compareTo(t) { const e = t; return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0 } getInsertEvent() { return this._insertEvent } isInsert() { return this._eventType === Gp.INSERT } isSameLabel(t) { return null !== this._label && this._label === t._label } getDeleteEventIndex() { return this._deleteEventIndex } get interfaces_() { return [mh] } } Gp.INSERT = 1, Gp.DELETE = 2; class jp { constructor() { jp.constructor_.apply(this, arguments) } static constructor_() { this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1; const t = arguments[0], e = arguments[1], n = arguments[2]; this._li = t, this._includeProper = e, this._recordIsolated = n } static isAdjacentSegments(t, e) { return 1 === Math.abs(t - e) } isTrivialIntersection(t, e, n, i) { if (t === n && 1 === this._li.getIntersectionNum()) { if (jp.isAdjacentSegments(e, i)) return !0; if (t.isClosed()) { const n = t.getNumPoints() - 1; if (0 === e && i === n || 0 === i && e === n) return !0 } } return !1 } getProperIntersectionPoint() { return this._properIntersectionPoint } setIsDoneIfProperInt(t) { this._isDoneWhenProperInt = t } hasProperInteriorIntersection() { return this._hasProperInterior } isBoundaryPointInternal(t, e) { for (let n = e.iterator(); n.hasNext();) { const e = n.next().getCoordinate(); if (t.isIntersection(e)) return !0 } return !1 } hasProperIntersection() { return this._hasProper } hasIntersection() { return this._hasIntersection } isDone() { return this._isDone } isBoundaryPoint(t, e) { return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1])) } setBoundaryNodes(t, e) { this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e } addIntersections(t, e, n, i) { if (t === n && e === i) return null; this.numTests++; const r = t.getCoordinates()[e], s = t.getCoordinates()[e + 1], o = n.getCoordinates()[i], a = n.getCoordinates()[i + 1]; this._li.computeIntersection(r, s, o, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0)))) } } class Bp extends class { }{ constructor() { super(), Bp.constructor_.apply(this, arguments) } static constructor_() { this.events = new Qh, this.nOverlaps = null } prepareEvents() { Vu.sort(this.events); for (let t = 0; t < this.events.size(); t++) { const e = this.events.get(t); e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t) } } computeIntersections() { if (1 === arguments.length) { const t = arguments[0]; this.nOverlaps = 0, this.prepareEvents(); for (let e = 0; e < this.events.size(); e++) { const n = this.events.get(e); if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break } } else if (3 === arguments.length) if (arguments[2] instanceof jp && Nh(arguments[0], Zh) && Nh(arguments[1], Zh)) { const t = arguments[0], e = arguments[1], n = arguments[2]; this.addEdges(t, t), this.addEdges(e, e), this.computeIntersections(n) } else if ("boolean" == typeof arguments[2] && Nh(arguments[0], Zh) && arguments[1] instanceof jp) { const t = arguments[0], e = arguments[1]; arguments[2] ? this.addEdges(t, null) : this.addEdges(t), this.computeIntersections(e) } } addEdge(t, e) { const n = t.getMonotoneChainEdge(), i = n.getStartIndexes(); for (let t = 0; t < i.length - 1; t++) { const i = new kp(n, t), r = new Gp(e, n.getMinX(t), i); this.events.add(r), this.events.add(new Gp(n.getMaxX(t), r)) } } processOverlaps(t, e, n, i) { const r = n.getObject(); for (let s = t; s < e; s++) { const t = this.events.get(s); if (t.isInsert()) { const e = t.getObject(); n.isSameLabel(t) || (r.computeIntersections(e, i), this.nOverlaps++) } } } addEdges() { if (1 === arguments.length) { for (let t = arguments[0].iterator(); t.hasNext();) { const e = t.next(); this.addEdge(e, e) } } else if (2 === arguments.length) { const t = arguments[1]; for (let e = arguments[0].iterator(); e.hasNext();) { const n = e.next(); this.addEdge(n, t) } } } } class Yp { constructor() { Yp.constructor_.apply(this, arguments) } static constructor_() { this._min = yh.POSITIVE_INFINITY, this._max = yh.NEGATIVE_INFINITY } getMin() { return this._min } intersects(t, e) { return !(this._min > e || this._max < t) } getMax() { return this._max } toString() { return du.toLineString(new Th(this._min, 0), new Th(this._max, 0)) } } Yp.NodeComparator = class { compare(t, e) { const n = t, i = e, r = (n._min + n._max) / 2, s = (i._min + i._max) / 2; return r < s ? -1 : r > s ? 1 : 0 } get interfaces_() { return [xh] } }; class qp extends Yp { constructor() { super(), qp.constructor_.apply(this, arguments) } static constructor_() { this._item = null; const t = arguments[0], e = arguments[1], n = arguments[2]; this._min = t, this._max = e, this._item = n } query(t, e, n) { if (!this.intersects(t, e)) return null; n.visitItem(this._item) } } class Xp extends Yp { constructor() { super(), Xp.constructor_.apply(this, arguments) } static constructor_() { this._node1 = null, this._node2 = null; const t = arguments[0], e = arguments[1]; this._node1 = t, this._node2 = e, this.buildExtent(this._node1, this._node2) } buildExtent(t, e) { this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max) } query(t, e, n) { if (!this.intersects(t, e)) return null; null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n) } } class zp { constructor() { zp.constructor_.apply(this, arguments) } static constructor_() { this._leaves = new Qh, this._root = null, this._level = 0 } buildTree() { Vu.sort(this._leaves, new Yp.NodeComparator); let t = this._leaves, e = null, n = new Qh; for (; ;) { if (this.buildLevel(t, n), 1 === n.size()) return n.get(0); e = t, t = n, n = e } } insert(t, e, n) { if (null !== this._root) throw new IllegalStateException("Index cannot be added to once it has been queried"); this._leaves.add(new qp(t, e, n)) } query(t, e, n) { if (this.init(), null === this._root) return null; this._root.query(t, e, n) } buildRoot() { if (null !== this._root) return null; this._root = this.buildTree() } printNode(t) { Ec.out.println(du.toLineString(new Th(t._min, this._level), new Th(t._max, this._level))) } init() { return null !== this._root || 0 === this._leaves.size() ? null : void this.buildRoot() } buildLevel(t, e) { this._level++, e.clear(); for (let n = 0; n < t.size(); n += 2) { const i = t.get(n); if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(i); else { const i = new Xp(t.get(n), t.get(n + 1)); e.add(i) } } } } class Up { constructor() { Up.constructor_.apply(this, arguments) } static constructor_() { if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) { const t = arguments[0]; this._lines = t } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; this._lines = t, this._isForcedToLineString = e } } static getGeometry() { if (1 === arguments.length) { const t = arguments[0]; return t.getFactory().buildGeometry(Up.getLines(t)) } if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return t.getFactory().buildGeometry(Up.getLines(t, e)) } } static getLines() { if (1 === arguments.length) { const t = arguments[0]; return Up.getLines(t, !1) } if (2 === arguments.length) { if (Nh(arguments[0], Hh) && Nh(arguments[1], Hh)) { const t = arguments[1]; for (let e = arguments[0].iterator(); e.hasNext();) { const n = e.next(); Up.getLines(n, t) } return t } if (arguments[0] instanceof Ah && "boolean" == typeof arguments[1]) { const t = arguments[0], e = arguments[1], n = new Qh; return t.apply(new Up(n, e)), n } if (arguments[0] instanceof Ah && Nh(arguments[1], Hh)) { const t = arguments[0], e = arguments[1]; return t instanceof zh ? e.add(t) : t.apply(new Up(e)), e } } else if (3 === arguments.length) { if ("boolean" == typeof arguments[2] && Nh(arguments[0], Hh) && Nh(arguments[1], Hh)) { const t = arguments[1], e = arguments[2]; for (let n = arguments[0].iterator(); n.hasNext();) { const i = n.next(); Up.getLines(i, t, e) } return t } if ("boolean" == typeof arguments[2] && arguments[0] instanceof Ah && Nh(arguments[1], Hh)) { const t = arguments[1], e = arguments[2]; return arguments[0].apply(new Up(t, e)), t } } } filter(t) { if (this._isForcedToLineString && t instanceof dc) { const e = t.getFactory().createLineString(t.getCoordinateSequence()); return this._lines.add(e), null } t instanceof zh && this._lines.add(t) } setForceToLineString(t) { this._isForcedToLineString = t } get interfaces_() { return [Mh] } } class Vp { constructor() { Vp.constructor_.apply(this, arguments) } static constructor_() { this._items = new Qh } visitItem(t) { this._items.add(t) } getItems() { return this._items } get interfaces_() { return [Ku] } } class Wp { constructor() { Wp.constructor_.apply(this, arguments) } static constructor_() { this._geom = null, this._index = null; const t = arguments[0]; if (!(Nh(t, oc) || t instanceof dc)) throw new gh("Argument must be Polygonal or LinearRing"); this._geom = t } locate(t) { null === this._index && (this._index = new Kp(this._geom), this._geom = null); const e = new yu(t), n = new Hp(e); return this._index.query(t.y, t.y, n), e.getLocation() } get interfaces_() { return [Tf] } } class Hp { constructor() { Hp.constructor_.apply(this, arguments) } static constructor_() { this._counter = null; const t = arguments[0]; this._counter = t } visitItem(t) { const e = t; this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1)) } get interfaces_() { return [Ku] } } class Kp { constructor() { Kp.constructor_.apply(this, arguments) } static constructor_() { this._isEmpty = !1, this._index = new zp; const t = arguments[0]; t.isEmpty() ? this._isEmpty = !0 : this.init(t) } init(t) { for (let e = Up.getLines(t).iterator(); e.hasNext();) { const t = e.next().getCoordinates(); this.addLine(t) } } addLine(t) { for (let e = 1; e < t.length; e++) { const n = new hf(t[e - 1], t[e]), i = Math.min(n.p0.y, n.p1.y), r = Math.max(n.p0.y, n.p1.y); this._index.insert(i, r, n) } } query() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; if (this._isEmpty) return new Qh; const n = new Vp; return this._index.query(t, e, n), n.getItems() } if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; if (this._isEmpty) return null; this._index.query(t, e, n) } } } Wp.SegmentVisitor = Hp, Wp.IntervalIndexedGeometry = Kp; class Zp extends Gu { constructor() { super(), Zp.constructor_.apply(this, arguments) } static constructor_() { if (this._parentGeom = null, this._lineEdgeMap = new Nc, this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Cp, 2 === arguments.length) { const t = arguments[0], e = arguments[1]; Zp.constructor_.call(this, t, e, mp.OGC_SFS_BOUNDARY_RULE) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; this._argIndex = t, this._parentGeom = e, this._boundaryNodeRule = n, null !== e && this.add(e) } } static determineBoundary(t, e) { return t.isInBoundary(e) ? Gc.BOUNDARY : Gc.INTERIOR } insertBoundaryPoint(t, e) { const n = this._nodes.addNode(e).getLabel(); let i = 1, r = Gc.NONE; r = n.getLocation(t, jc.ON), r === Gc.BOUNDARY && i++; const s = Zp.determineBoundary(this._boundaryNodeRule, i); n.setLocation(t, s) } computeSelfNodes() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; return this.computeSelfNodes(t, e, !1) } if (3 === arguments.length) { const t = arguments[1], e = arguments[2], n = new jp(arguments[0], !0, !1); n.setIsDoneIfProperInt(e); const i = this.createEdgeSetIntersector(), r = this._parentGeom instanceof dc || this._parentGeom instanceof ac || this._parentGeom instanceof bc, s = t || !r; return i.computeIntersections(this._edges, n, s), this.addSelfIntersectionNodes(this._argIndex), n } } computeSplitEdges(t) { for (let e = this._edges.iterator(); e.hasNext();) { e.next().eiList.addSplitEdges(t) } } computeEdgeIntersections(t, e, n) { const i = new jp(e, n, !0); i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()); return this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, i), i } getGeometry() { return this._parentGeom } getBoundaryNodeRule() { return this._boundaryNodeRule } hasTooFewPoints() { return this._hasTooFewPoints } addPoint() { if (arguments[0] instanceof Vh) { const t = arguments[0].getCoordinate(); this.insertPoint(this._argIndex, t, Gc.INTERIOR) } else if (arguments[0] instanceof Th) { const t = arguments[0]; this.insertPoint(this._argIndex, t, Gc.INTERIOR) } } addPolygon(t) { this.addPolygonRing(t.getExteriorRing(), Gc.EXTERIOR, Gc.INTERIOR); for (let e = 0; e < t.getNumInteriorRing(); e++) { const n = t.getInteriorRingN(e); this.addPolygonRing(n, Gc.INTERIOR, Gc.EXTERIOR) } } addEdge(t) { this.insertEdge(t); const e = t.getCoordinates(); this.insertPoint(this._argIndex, e[0], Gc.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], Gc.BOUNDARY) } addLineString(t) { const e = Ic.removeRepeatedPoints(t.getCoordinates()); if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null; const n = new Uf(e, new xu(this._argIndex, Gc.INTERIOR)); this._lineEdgeMap.put(t, n), this.insertEdge(n), wh.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1]) } getInvalidPoint() { return this._invalidPoint } getBoundaryPoints() { const t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null); let n = 0; for (let i = t.iterator(); i.hasNext();) { const t = i.next(); e[n++] = t.getCoordinate().copy() } return e } getBoundaryNodes() { return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes } addSelfIntersectionNode(t, e, n) { if (this.isBoundaryNode(t, e)) return null; n === Gc.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n) } addPolygonRing(t, e, n) { if (t.isEmpty()) return null; const i = Ic.removeRepeatedPoints(t.getCoordinates()); if (i.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = i[0], null; let r = e, s = n; sc.isCCW(i) && (r = n, s = e); const o = new Uf(i, new xu(this._argIndex, Gc.BOUNDARY, r, s)); this._lineEdgeMap.put(t, o), this.insertEdge(o), this.insertPoint(this._argIndex, i[0], Gc.BOUNDARY) } insertPoint(t, e, n) { const i = this._nodes.addNode(e), r = i.getLabel(); null === r ? i._label = new xu(t, n) : r.setLocation(t, n) } createEdgeSetIntersector() { return new Bp } addSelfIntersectionNodes(t) { for (let e = this._edges.iterator(); e.hasNext();) { const n = e.next(), i = n.getLabel().getLocation(t); for (let e = n.eiList.iterator(); e.hasNext();) { const n = e.next(); this.addSelfIntersectionNode(t, n.coord, i) } } } add() { if (!(1 === arguments.length && arguments[0] instanceof Ah)) return super.add.apply(this, arguments); { const t = arguments[0]; if (t.isEmpty()) return null; if (t instanceof bc && (this._useBoundaryDeterminationRule = !1), t instanceof ac) this.addPolygon(t); else if (t instanceof zh) this.addLineString(t); else if (t instanceof Vh) this.addPoint(t); else if (t instanceof pc) this.addCollection(t); else if (t instanceof Mc) this.addCollection(t); else if (t instanceof bc) this.addCollection(t); else { if (!(t instanceof fc)) throw new jh(t.getGeometryType()); this.addCollection(t) } } } addCollection(t) { for (let e = 0; e < t.getNumGeometries(); e++) { const n = t.getGeometryN(e); this.add(n) } } locate(t) { return Nh(this._parentGeom, oc) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new Wp(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom) } findEdge() { if (1 === arguments.length && arguments[0] instanceof zh) { const t = arguments[0]; return this._lineEdgeMap.get(t) } return super.findEdge.apply(this, arguments) } } class Jp { constructor() { Jp.constructor_.apply(this, arguments) } static constructor_() { if (this._li = new _u, this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) { const t = arguments[0]; this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Zp(0, t) } else if (2 === arguments.length) { const t = arguments[0], e = arguments[1]; Jp.constructor_.call(this, t, e, mp.OGC_SFS_BOUNDARY_RULE) } else if (3 === arguments.length) { const t = arguments[0], e = arguments[1], n = arguments[2]; t.getPrecisionModel().compareTo(e.getPrecisionModel()) >= 0 ? this.setComputationPrecision(t.getPrecisionModel()) : this.setComputationPrecision(e.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Zp(0, t, n), this._arg[1] = new Zp(1, e, n) } } getArgGeometry(t) { return this._arg[t].getGeometry() } setComputationPrecision(t) { this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel) } } class Qp extends Jp { constructor() { super(), Qp.constructor_.apply(this, arguments) } static constructor_() { this._ptLocator = new Cp, this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Af, this._resultPolyList = new Qh, this._resultLineList = new Qh, this._resultPointList = new Qh; const t = arguments[0], e = arguments[1]; Jp.constructor_.call(this, t, e), this._graph = new Gu(new Mf), this._geomFact = t.getFactory() } static overlayOp(t, e, n) { return new Qp(t, e).getResultGeometry(n) } static union(t, e) { if (t.isEmpty() || e.isEmpty()) { if (t.isEmpty() && e.isEmpty()) return Qp.createEmptyResult(Qp.UNION, t, e, t.getFactory()); if (t.isEmpty()) return e.copy(); if (e.isEmpty()) return t.copy() } if (t.isGeometryCollection() || e.isGeometryCollection()) throw new gh("This method does not support GeometryCollection arguments"); return Fp.overlayOp(t, e, Qp.UNION) } static intersection(t, e) { if (t.isEmpty() || e.isEmpty()) return Qp.createEmptyResult(Qp.INTERSECTION, t, e, t.getFactory()); if (t.isGeometryCollection()) { const n = e; return Tp.map(t, new class { get interfaces_() { return [MapOp] } map(t) { return Qp.intersection(t, n) } }) } return Fp.overlayOp(t, e, Qp.INTERSECTION) } static symDifference(t, e) { if (t.isEmpty() || e.isEmpty()) { if (t.isEmpty() && e.isEmpty()) return Qp.createEmptyResult(Qp.SYMDIFFERENCE, t, e, t.getFactory()); if (t.isEmpty()) return e.copy(); if (e.isEmpty()) return t.copy() } if (t.isGeometryCollection() || e.isGeometryCollection()) throw new gh("This method does not support GeometryCollection arguments"); return Fp.overlayOp(t, e, Qp.SYMDIFFERENCE) } static resultDimension(t, e, n) { const i = e.getDimension(), r = n.getDimension(); let s = -1; switch (t) { case Qp.INTERSECTION: s = Math.min(i, r); break; case Qp.UNION: s = Math.max(i, r); break; case Qp.DIFFERENCE: s = i; break; case Qp.SYMDIFFERENCE: s = Math.max(i, r) }return s } static createEmptyResult(t, e, n, i) { const r = Qp.resultDimension(t, e, n); return i.createEmpty(r) } static difference(t, e) { if (t.isEmpty()) return Qp.createEmptyResult(Qp.DIFFERENCE, t, e, t.getFactory()); if (e.isEmpty()) return t.copy(); if (t.isGeometryCollection() || e.isGeometryCollection()) throw new gh("This method does not support GeometryCollection arguments"); return Fp.overlayOp(t, e, Qp.DIFFERENCE) } static isResultOfOp() { if (2 === arguments.length) { const t = arguments[0], e = arguments[1], n = t.getLocation(0), i = t.getLocation(1); return Qp.isResultOfOp(n, i, e) } if (3 === arguments.length) { let t = arguments[0], e = arguments[1], n = arguments[2]; switch (t === Gc.BOUNDARY && (t = Gc.INTERIOR), e === Gc.BOUNDARY && (e = Gc.INTERIOR), n) { case Qp.INTERSECTION: return t === Gc.INTERIOR && e === Gc.INTERIOR; case Qp.UNION: return t === Gc.INTERIOR || e === Gc.INTERIOR; case Qp.DIFFERENCE: return t === Gc.INTERIOR && e !== Gc.INTERIOR; case Qp.SYMDIFFERENCE: return t === Gc.INTERIOR && e !== Gc.INTERIOR || t !== Gc.INTERIOR && e === Gc.INTERIOR }return !1 } } insertUniqueEdge(t) { const e = this._edgeList.findEqualEdge(t); if (null !== e) { const n = e.getLabel(); let i = t.getLabel(); e.isPointwiseEqual(t) || (i = new xu(t.getLabel()), i.flip()); const r = e.getDepth(); r.isNull() && r.add(n), r.add(i), n.merge(i) } else this._edgeList.add(t) } getGraph() { return this._graph } cancelDuplicateResultEdges() { for (let t = this._graph.getEdgeEnds().iterator(); t.hasNext();) { const e = t.next(), n = e.getSym(); e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1)) } } isCoveredByLA(t) { return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList) } computeGeometry(t, e, n, i) { const r = new Qh; return r.addAll(t), r.addAll(e), r.addAll(n), r.isEmpty() ? Qp.createEmptyResult(i, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(r) } mergeSymLabels() { for (let t = this._graph.getNodes().iterator(); t.hasNext();) { t.next().getEdges().mergeSymLabels() } } isCovered(t, e) { for (let n = e.iterator(); n.hasNext();) { const e = n.next(); if (this._ptLocator.locate(t, e) !== Gc.EXTERIOR) return !0 } return !1 } replaceCollapsedEdges() { const t = new Qh; for (let e = this._edgeList.iterator(); e.hasNext();) { const n = e.next(); n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge())) } this._edgeList.addAll(t) } updateNodeLabelling() { for (let t = this._graph.getNodes().iterator(); t.hasNext();) { const e = t.next(), n = e.getEdges().getLabel(); e.getLabel().merge(n) } } getResultGeometry(t) { return this.computeOverlay(t), this._resultGeom } insertUniqueEdges(t) { for (let e = t.iterator(); e.hasNext();) { const t = e.next(); this.insertUniqueEdge(t) } } computeOverlay(t) { this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0); const e = new Qh; this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e); this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Op.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges(); const n = new ju(this._geomFact); n.add(this._graph), this._resultPolyList = n.getPolygons(); const i = new Rp(this, this._geomFact, this._ptLocator); this._resultLineList = i.build(t); const r = new Np(this, this._geomFact, this._ptLocator); this._resultPointList = r.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t) } labelIncompleteNode(t, e) { const n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry()); t.getLabel().setLocation(e, n) } copyPoints(t) { for (let e = this._arg[t].getNodeIterator(); e.hasNext();) { const n = e.next(); this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t)) } } findResultAreaEdges(t) { for (let e = this._graph.getEdgeEnds().iterator(); e.hasNext();) { const n = e.next(), i = n.getLabel(); i.isArea() && !n.isInteriorAreaEdge() && Qp.isResultOfOp(i.getLocation(0, jc.RIGHT), i.getLocation(1, jc.RIGHT), t) && n.setInResult(!0) } } computeLabelsFromDepths() { for (let t = this._edgeList.iterator(); t.hasNext();) { const e = t.next(), n = e.getLabel(), i = e.getDepth(); if (!i.isNull()) { i.normalize(); for (let t = 0; t < 2; t++)n.isNull(t) || !n.isArea() || i.isNull(t) || (0 === i.getDelta(t) ? n.toLine(t) : (wh.isTrue(!i.isNull(t, jc.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(t, jc.LEFT, i.getLocation(t, jc.LEFT)), wh.isTrue(!i.isNull(t, jc.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(t, jc.RIGHT, i.getLocation(t, jc.RIGHT)))) } } } computeLabelling() { for (let t = this._graph.getNodes().iterator(); t.hasNext();) { t.next().getEdges().computeLabelling(this._arg) } this.mergeSymLabels(), this.updateNodeLabelling() } labelIncompleteNodes() { for (let t = this._graph.getNodes().iterator(); t.hasNext();) { const e = t.next(), n = e.getLabel(); e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n) } } isCoveredByA(t) { return !!this.isCovered(t, this._resultPolyList) } } function $p(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } Qp.INTERSECTION = 1, Qp.UNION = 2, Qp.DIFFERENCE = 3, Qp.SYMDIFFERENCE = 4; var td = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t) } var e, n, i; return e = t, i = [{ key: "logError", value: function (t) { console.error(t) } }], (n = null) && $p(e.prototype, n), i && $p(e, i), t }(); function ed(t) { return (ed = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function nd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function id(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function rd(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function sd(t, e, n) { return (sd = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = hd(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function od(t, e) { return (od = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function ad(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = hd(t); if (e) { var r = hd(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return ld(this, n) } } function ld(t, e) { return !e || "object" !== ed(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function hd(t) { return (hd = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var cd = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && od(t, e) }(s, t); var e, n, i, r = ad(s); function s(t) { var e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), (e = r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? nd(Object(n), !0).forEach((function (e) { id(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : nd(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "TopoloyOp", className: "ole-control-topology", image: ip.a }, t))).selectInteraction = new Yl({ toggleCondition: function () { return !0 }, layers: e.layerFilter, hitTolerance: void 0 === t.hitTolerance ? 10 : t.hitTolerance, multi: !0, style: t.style }), e.selectInteraction.on("select", (function () { var t = e.selectInteraction.getFeatures(); try { e.applyTopologyOperation(t.getArray()) } catch (e) { td.logError("Unable to process features."), t.clear() } })), e } return e = s, (n = [{ key: "applyTopologyOperation", value: function (t) { this.topologyFeatures = t } }, { key: "activate", value: function () { this.map.addInteraction(this.selectInteraction), this.addedFeatures = [], sd(hd(s.prototype), "activate", this).call(this) } }, { key: "deactivate", value: function (t) { this.addedFeatures = [], this.map.removeInteraction(this.selectInteraction), sd(hd(s.prototype), "deactivate", this).call(this, t) } }]) && rd(e.prototype, n), i && rd(e, i), s }(Dn), ud = n(12), fd = n.n(ud); function pd(t) { return (pd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function dd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function gd(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function _d(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function yd(t, e, n) { return (yd = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Ed(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function md(t, e) { return (md = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function vd(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Ed(t); if (e) { var r = Ed(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return xd(this, n) } } function xd(t, e) { return !e || "object" !== pd(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Ed(t) { return (Ed = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Id = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && md(t, e) }(s, t); var e, n, i, r = vd(s); function s(t) { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? dd(Object(n), !0).forEach((function (e) { gd(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : dd(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Union", className: "ole-control-union", image: fd.a }, t)) } return e = s, (n = [{ key: "applyTopologyOperation", value: function (t) { yd(Ed(s.prototype), "applyTopologyOperation", this).call(this, t); var e = new Fc; e.inject(Ki, vr, Cr, Pr, Fr, Pa, Da); for (var n = 1; n < t.length; n += 1) { var i = e.read(t[0].getGeometry()), r = e.read(t[n].getGeometry()), o = Qp.union(i, r); t[0].setGeometry(e.write(o)), t[n].setGeometry(null) } } }]) && _d(e.prototype, n), i && _d(e, i), s }(cd), Cd = n(13), wd = n.n(Cd); function Sd(t) { return (Sd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function bd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function Od(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Td(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function Rd(t, e, n) { return (Rd = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Md(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function Nd(t, e) { return (Nd = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Ld(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Md(t); if (e) { var r = Md(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return Pd(this, n) } } function Pd(t, e) { return !e || "object" !== Sd(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Md(t) { return (Md = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Dd = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Nd(t, e) }(s, t); var e, n, i, r = Ld(s); function s(t) { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? bd(Object(n), !0).forEach((function (e) { Od(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : bd(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Intersection", className: "ole-control-intersection", image: wd.a }, t)) } return e = s, (n = [{ key: "applyTopologyOperation", value: function (t) { if (Rd(Md(s.prototype), "applyTopologyOperation", this).call(this, t), !(t.length < 2)) { var e = new Fc; e.inject(Ki, vr, Cr, Pr, Fr, Pa, Da); for (var n = 1; n < t.length; n += 1) { var i = e.read(t[0].getGeometry()), r = e.read(t[n].getGeometry()), o = Qp.intersection(i, r); t[0].setGeometry(e.write(o)), t[n].setGeometry(null) } } } }]) && Td(e.prototype, n), i && Td(e, i), s }(cd), Ad = n(14), Fd = n.n(Ad); function kd(t) { return (kd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Gd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function jd(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Bd(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function Yd(t, e, n) { return (Yd = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Ud(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function qd(t, e) { return (qd = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Xd(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = Ud(t); if (e) { var r = Ud(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return zd(this, n) } } function zd(t, e) { return !e || "object" !== kd(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Ud(t) { return (Ud = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Vd = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && qd(t, e) }(s, t); var e, n, i, r = Xd(s); function s(t) { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s), r.call(this, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Gd(Object(n), !0).forEach((function (e) { jd(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Gd(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ title: "Difference", className: "ole-control-difference", image: Fd.a }, t)) } return e = s, (n = [{ key: "applyTopologyOperation", value: function (t) { if (Yd(Ud(s.prototype), "applyTopologyOperation", this).call(this, t), !(t.length < 2)) { var e = new Fc; e.inject(Ki, vr, Cr, Pr, Fr, Pa, Da); for (var n = 1; n < t.length; n += 1) { var i = e.read(t[0].getGeometry()), r = e.read(t[n].getGeometry()), o = Qp.difference(i, r); t[0].setGeometry(e.write(o)), t[n].setGeometry(null) } } } }]) && Bd(e.prototype, n), i && Bd(e, i), s }(cd); function Wd(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function Hd(t) { return (Hd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Kd(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function Zd(t, e, n) { return (Zd = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = tg(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function Jd(t, e) { return (Jd = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Qd(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = tg(t); if (e) { var r = tg(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return $d(this, n) } } function $d(t, e) { return !e || "object" !== Hd(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function tg(t) { return (tg = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var eg = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Jd(t, e) }(s, t); var e, n, i, r = Qd(s); function s(t) { var e; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, s); var n = t || {}; return (e = r.call(this)).controls = n.controls, e.ignoreKeys = ["title", "image", "className"], e } return e = s, (n = [{ key: "activate", value: function () { var t = this; Zd(tg(s.prototype), "activate", this).call(this), this.controls = this.controls || this.editor.getControls().getArray(), this.restoreProperties(), this.restoreActiveControls(), this.controls.forEach((function (e) { e.addEventListener("propertychange", (function (e) { t.storeProperties(e.detail.control.getProperties().title, e.detail.properties) })), e.addEventListener("change:active", (function () { t.storeActiveControls() })) })) } }, { key: "deactivate", value: function () { Zd(tg(s.prototype), "deactivate", this).call(this), this.controls.forEach((function (t) { t.removeEventListener("propertychange") })) } }, { key: "storeProperties", value: function (t, e) { for (var n = {}, i = Object.keys(e), r = 0; r < i.length; r += 1) { var s = i[r]; -1 !== this.ignoreKeys.indexOf(s) || e[s] instanceof Object || (n[s] = e[s]) } return n } }, { key: "restoreProperties", value: function () { } }, { key: "storeActiveControls", value: function () { return this.editor.getActiveControls().getArray().map((function (t) { return t.getProperties().title })) } }, { key: "restoreActiveControls", value: function () { } }]) && Kd(e.prototype, n), i && Kd(e, i), s }(function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.active = !1, this.editor = null, this.map = null } var e, n, i; return e = t, (n = [{ key: "activate", value: function () { this.active = !0 } }, { key: "deactivate", value: function () { this.active = !1 } }, { key: "setEditor", value: function (t) { this.editor = t } }, { key: "setMap", value: function (t) { this.map = t } }]) && Wd(e.prototype, n), i && Wd(e, i), t }()); function ng(t) { return (ng = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function ig(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function rg(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function sg(t, e, n) { return (sg = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var i = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = hg(t));); return t }(t, e); if (i) { var r = Object.getOwnPropertyDescriptor(i, e); return r.get ? r.get.call(n) : r.value } })(t, e, n || t) } function og(t, e) { return (og = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function ag(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, i = hg(t); if (e) { var r = hg(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return lg(this, n) } } function lg(t, e) { return !e || "object" !== ng(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function hg(t) { return (hg = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var cg = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && og(t, e) }(s, t); var e, n, i, r = ag(s); function s() { return ig(this, s), r.apply(this, arguments) } return e = s, (n = [{ key: "storeProperties", value: function (t, e) { var n = sg(hg(s.prototype), "storeProperties", this).call(this, t, e); window.localStorage.setItem(t, JSON.stringify(n)) } }, { key: "restoreProperties", value: function () { for (var t = 0; t < this.controls.length; t += 1) { var e = this.controls[t].getProperties().title, n = window.localStorage.getItem(e); n && this.controls[t].setProperties(JSON.parse(n), !0) } } }, { key: "storeActiveControls", value: function () { var t = sg(hg(s.prototype), "storeActiveControls", this).call(this); window.localStorage.setItem("active", JSON.stringify(t)) } }, { key: "restoreActiveControls", value: function () { var t = window.localStorage.getItem("active"); if ((t = t ? JSON.parse(t) : []).length) for (var e = 0; e < this.controls.length; e += 1) { var n = this.controls[e].getProperties().title; t.indexOf(n) > -1 ? this.controls[e].activate() : this.controls[e].deactivate() } } }]) && rg(e.prototype, n), i && rg(e, i), s }(eg) }]) }));
//# sourceMappingURL=index.js.map